{"version":3,"sources":["URL.js","PangenomeSchematic.js","ComponentConnectorRect.js","ComponentRect.js","ComponentNucleotides.js","LinkColumn.js","LinkArrow.js","LinkRecord.js","NucleotideTooltip.js","ControlHeader.js","utilities.js","App.js","serviceWorker.js","ViewportInputsStore.js","index.js"],"names":["urlExists","dataName","http","XMLHttpRequest","open","send","status","theUrl","callback","a","xmlHttp","onreadystatechange","readyState","responseText","PangenomeSchematic","props","pathNames","components","jsonCache","nucleotides","loadIndexFile","store","jsonName","observe","chunkFastaURLs","loadFasta","jsonFilename","console","log","indexPath","process","fetch","then","res","json","setChunkIndex","filepath","Error","url","data","json_version","MediaError","this","path_names","processArray","path_fasta","response","text","sequence","replace","substr","push","getBeginBin","getEndBin","beginBin","endBin","chunksProcessed","length","chunkURLs","urlIndex","jsonChunk","x","setBeginColumnX","first_bin","setChunkBeginBin","entries","index","component","componentItem","Component","addChunkProcessed","slice","React","columnX","firstBin","lastBin","last_bin","arrivals","arrival","LinkColumn","departures","departure","relativePixelX","occupants","Array","from","matrix","num_bin","linkColumn","upstream","downstream","participants","key","edgeToKey","String","padStart","ConnectorRect","state","color","y","width","height","fill","MatrixCell","tooltipContent","pathName","item","ranges","j","start","end","updateCellTooltipContent","inverted","pixelsPerRow","align","verticalAlign","onMouseEnter","onHover","bind","onMouseLeave","onLeave","inversionText","zip","arr","arrs","map","val","i","reduce","compress_visible_rows","rows_present","row","some","find_rows_visible_in_viewport","row_mapping","rows_encountered","sum","b","ComponentRect","handleClick","setState","count","parts","row_n","renderMatrixRow","updateMaxHeight","parent","x_val","pixelsPerColumn","this_y","useVerticalCompression","compressed_row_mapping","hasOwnProperty","cell","topOffset","row_number","connectorsColumn","undefined","column","useConnector","renderComponentConnector","useWidthCompression","binScalingFactor","widthInColumns","onClick","renderMatrix","renderAllConnectors","ComponentNucleotides","listOfObjects","nucleotideHeight","handleMouseOut","handleMouseOver","updateHighlightedNode","alpha","contents","linkCells","y_coord","d","opacity","stroke","onMouseOver","onMouseOut","isInfinity","n","Number","isFinite","LinkArrow","link","event","beginEndBin","newBeginBin","newEndBin","mid_bin","destination_bin","Math","abs","max","updateSelectedLink","arrowXCoord","points","xArrival","departureX","xDepart","arrX","turnDirection","departOrigin","departCorner","elevation","departTop","arriveTop","arriveCorner","arriveCornerEnd","isArrival","isNaN","calculatePoints","bezier","strokeWidth","stroke-opacity","pointerLength","pointerWidth","tension","LinkRecord","xCoordArrival","xCoordDeparture","calculateLinkCoordinates","schematic","leftXStart","linkToXMapping","schematizeComponent","paddedKey","k","linkToXmapping","distanceSortedLinks","Object","values","sort","distance","elevationOccupied","record","linkBegin","min","linkEnd","range","reserveElevationAirSpace","top","calculateLinkElevations","NucleotideTooltip","MouseTooltip","visible","offsetX","offsetY","style","background","zIndex","cellToolTipContent","ControlHeader","percentage","size","diff","floor","updateBeginEndBin","pathNucPos","path","nucPos","httpGetAsync","pathIndexServerAddress","result","alert","parseInt","ceil","getBinWidth","target","value","options","selectedIndex","setIndexSelectedZoomLevel","indexSelZoomLevel","indexSelectedZoomLevel","availableZoomLevels","id","className","type","defaultValue","onChange","tryJSONpath","title","marginLeft","decIndexSelectedZoomLevel","change_zoom_level","incIndexSelectedZoomLevel","shift","readOnly","list","placeholder","updatePathNucPos","getPath","handleJump","Fragment","updateHeight","updateWidth","VerticalCompressedViewSwitch","checked","toggleUseVerticalCompression","RenderConnectorSwitch","toggleUseConnector","WidthCompressedViewSwitch","toggleUseWidthCompression","arraysEqual","A","B","every","e","indexOf","stringToColorAndOpacity","highlightedLinkColumn","selectedLink","whichLinkToConsider","colorKey","matchColor","stringToColourSave","toString","hash","charCodeAt","colour","App","layerRef","createRef","layerRef2","timerHighlightingLink","timerSelectionLink","componentDidMount","clientHeight","document","getElementById","getElementsByClassName","position","buttonsHeight","current","getCanvas","_canvas","_updateHighlightedNode","linkRect","highlightedLink","recalcXLayout","clearTimeout","setTimeout","update_state","renderNucleotidesSchematic","loading","nucleotides_slice","chunkBeginBin","visibleHeightPixels","schematize","actualWidth","fetchAllChunks","updateSchematicMetadata","recalcY","render","openRelevantChunksFromIndex","makeInspectable","chunkIndex","zoom_levels","keys","setAvailableZoomLevels","selZoomLev","getSelectedZoomLevel","widthInCells","chunkURLarray","fileArrayFasta","currEnd","workingWidth","level","get","ichunk","files","chunk","columnsLeftToAdd","fasta","density","round","calculateEndBinFromScreen","fileArray","URLprefix","filename","switchChunkFastaURLs","switchChunkURLs","chunkPath","jsonFetch","loadJsonCache","warn","maxNumRowsAcrossComponents","calcMaxNumRowsAcrossComponents","setLoading","columnsInComponents","accumulator","currentValue","paddingBetweenComponents","links","updateTopOffset","maxNumberRowsInOneComponent","numberOccupants","filter","Boolean","firstDepartureColumn","beginColumnX","renderLinkColumn","leftPad","localColor","localOpacity","localStroke","renderComponent","renderLink","fontSize","minWidth","leftOffset","ref","renderSortedLinks","loadingMessage","renderSchematic","window","location","hostname","match","Chunk","types","model","file","string","maybeNull","integer","component_count","link_count","ZoomLevel","bin_width","array","ChunkIndex","pangenome_length","PathNucPos","optional","maximumHeightThisFrame","pangenomelast_bin","actions","self","newBegin","newEnd","newTopOffset","isSafeInteger","updateHighlightedLink","latestHeight","resetRenderStats","newContents","updateBinScalingFactor","newFactor","arrayOfFile","singleChunk","views","create","ReactDOM","navigator","serviceWorker","ready","registration","unregister"],"mappings":"2QAEO,SAASA,EAAUC,GACxB,GAAiB,KAAbA,EACF,OAAO,EAGP,IAAIC,EAAO,IAAIC,eAGf,OAFAD,EAAKE,KAAK,OAAQH,GAAU,GAC5BC,EAAKG,OACkB,MAAhBH,EAAKI,O,4CAIT,WAA4BC,EAAQC,GAApC,eAAAC,EAAA,6DACDC,EAAU,IAAIP,gBACVQ,mBAAqB,WACA,IAAvBD,EAAQE,YAAuC,MAAnBF,EAAQJ,QACtCE,EAASE,EAAQG,eAJhB,SAMCH,EAAQN,KAAK,MAAOG,GAAQ,GAN7B,OAOLG,EAAQL,KAAK,MAPR,4C,0BCVDS,E,kDACJ,WAAYC,GAAQ,IAAD,8BAKjB,cAAMA,IACDC,UAAY,GACjB,EAAKC,WAAa,GAClB,EAAKC,UAAY,GAGjB,EAAKC,YAAc,GAEnB,EAAKC,cAAc,EAAKL,MAAMM,MAAMC,UAGpCC,kBAAQ,EAAKR,MAAMM,MAAO,YAAY,WACpC,EAAKD,cAAc,EAAKL,MAAMM,MAAMC,aAItCC,kBAAQ,EAAKR,MAAMM,MAAMG,gBAAgB,WACvC,EAAKC,eAtBU,E,wGAmCLC,GAAe,IAAD,OAC1BC,QAAQC,IAAI,qDAEZ,IAAIC,EACFC,iIAA8BJ,EAAe,iBAE/C,OADAC,QAAQC,IAAI,gCAAiCC,GACtCE,MAAMF,GACVG,MAAK,SAACC,GAAD,OAASA,EAAIC,UAClBF,MAAK,SAACE,GACLP,QAAQC,IAAI,8BAA+BC,GAG3C,EAAKd,MAAMM,MAAMc,cAAcD,Q,gCAI3BE,GACR,IAAKA,EACH,MAAM,IAAIC,MACR,sEAGJ,OADAV,QAAQC,IAAI,WAAYQ,GACjBL,MAAMK,GAAUJ,MAAK,SAACC,GAAD,OAASA,EAAIC,Y,oCAG7BI,EAAKC,GAGjB,GAFAZ,QAAQC,IAAI,iDAEc,KAAtBW,EAAKC,aACP,MAAMC,WACJ,0DACAF,EAAKC,aADL,qNAQJE,KAAKxB,UAAUoB,GAAOC,EACtBG,KAAK1B,UAAYuB,EAAKI,WACtBD,KAAKE,iB,kCAGM,IAAD,OACVjB,QAAQC,IAAI,aAGZc,KAAKvB,YAAc,GAJT,oBAOauB,KAAK3B,MAAMM,MAAMG,gBAP9B,yBAODqB,EAPC,QAQJ7C,EAAU6C,KACZlB,QAAQC,IAAI,sBAAuBiB,GAEnCd,MAAMc,GACHb,MAAK,SAACc,GACL,OAAOA,EAASC,UAEjBf,MAAK,SAACe,GAAU,IAAD,EACRC,EAAWD,EACdE,QAAQ,KAAM,IACdC,OAAO,GACPD,QAAQ,YAAa,KAGxB,IAAK9B,aAAYgC,KAAjB,oBAAyBH,IAEzBrB,QAAQC,IAAI,oBAAqBiB,QAjBzC,2BAAyD,IAP/C,iC,qCAqCVlB,QAAQC,IACN,oEAEF,IAAIP,EAAQqB,KAAK3B,MAAMM,MALV,EAMY,CAACA,EAAM+B,cAAe/B,EAAMgC,aAAhDC,EANQ,KAMEC,EANF,KASsB,IAAjClC,EAAMmC,gBAAgBC,QACtBpC,EAAMmC,gBAAgB,KAAOd,KAAK3B,MAAMM,MAAMqC,UAAU,KAExDhB,KAAKzB,WAAa,IAGpBU,QAAQC,IAAI,qCAAsC0B,EAAU,MAAOC,GAEnE,IAAK,IAAII,EAAW,EAAGA,EAAWtC,EAAMqC,UAAUD,OAAQE,IAExD,GAAIA,GAAYtC,EAAMmC,gBAAgBC,OAAQ,CAE5C,KAAIpC,EAAMqC,UAAUC,KAAajB,KAAKxB,WA4BpC,OAAO,EA3BP,IAAIoB,EAAMjB,EAAMqC,UAAUC,GACtBC,EAAYlB,KAAKxB,UAAUoB,GAE/BX,QAAQC,IACN,6CACEgC,EAAU3C,WAAW,GAAG4C,GAEX,IAAbF,IAEFtC,EAAMyC,gBAAgBF,EAAU3C,WAAW,GAAG4C,GAC9ClC,QAAQC,IACN,uCAAyCgC,EAAUG,WAErD1C,EAAM2C,iBAAiBJ,EAAUG,YAdY,oBAiBhBH,EAAU3C,WAAWgD,WAjBL,IAiB/C,2BAA+D,CAAC,IAAD,yBAArDC,EAAqD,KAA9CC,EAA8C,KAC7D,GAAIA,EAAUJ,UAAY,EAAG,CAC3B,IAAIK,EAAgB,IAAIC,EAAUF,EAAWD,GAC7CxB,KAAKzB,WAAWkC,KAAKiB,KApBsB,8BAyB/C/C,EAAMiD,kBAAkBhC,GAkB9B,OAVAX,QAAQC,IACN,eACAP,EAAMmC,gBAAgB,GACtBnC,EAAMmC,gBAAgBe,OAAO,GAAG,GAChC,SACA7B,KAAK3B,MAAMM,MAAMqC,UAAUD,OAC3B,WAIK,M,GAlLsBe,IAAMH,WAsLjCA,EAEJ,WAAYF,EAAWD,GAAQ,oBAC7BxB,KAAK+B,QAAUN,EAAUN,EACzBnB,KAAKwB,MAAQA,EACbxB,KAAKgC,SAAWP,EAAUJ,UAC1BrB,KAAKiC,QAAUR,EAAUS,SACzBlC,KAAKmC,SAAW,GALY,oBAMRV,EAAUU,UANF,IAM5B,2BAAwC,CAAC,IAAhCC,EAA+B,QACtCpC,KAAKmC,SAAS1B,KAAK,IAAI4B,EAAWD,KAPR,8BAS5BpC,KAAKsC,WAAa,GATU,oBAUNb,EAAUa,YAVJ,IAU5B,2BAA4C,CAAC,IAApCC,EAAmC,QAE1CvC,KAAKsC,WAAW7B,KAAK,IAAI4B,EAAWE,KAZV,8BAe5BvC,KAAKwC,eAAiBf,EAAUN,EAEhCnB,KAAKyC,UAAYC,MAAMC,KAAKlB,EAAUgB,WACtCzC,KAAK4C,OAASF,MAAMC,KAAKlB,EAAUmB,QACnC5C,KAAK6C,QAAU7C,KAAKiC,QAAUjC,KAAKgC,SAAW,GAI5CK,E,WACJ,WAAYS,GAAa,oBACvB9C,KAAK+C,SAAWD,EAAWC,SAC3B/C,KAAKgD,WAAaF,EAAWE,WAC7BhD,KAAKiD,aAAeH,EAAWG,aAC/BjD,KAAKkD,IAAMlD,KAAKmD,Y,wDAKhB,OACEC,OAAOpD,KAAKgD,YAAYK,SAAS,GAAI,KACrCD,OAAOpD,KAAK+C,UAAUM,SAAS,GAAI,S,KAK1BjF,IChOFkF,EAAb,4MACEC,MAAQ,CACNC,MAAO,EAAKnF,MAAMmF,OAFtB,uDAMI,OACE,kBAAC,OAAD,CACErC,EAAGnB,KAAK3B,MAAM8C,EACdsC,EAAGzD,KAAK3B,MAAMoF,EACdC,MAAO1D,KAAK3B,MAAMqF,MAClBC,OAAQ3D,KAAK3B,MAAMsF,QAAU,EAC7BC,KAAM5D,KAAKuD,MAAMC,YAZzB,GAAmC1B,IAAMH,WA2B5BkC,EAAb,wKAMI,IAAIC,EAAiB,IACrBA,GACE9D,KAAK3B,MAAM0F,SACX,gBACA/D,KAAK3B,MAAM2F,KAAK,GAChB,gBACAhE,KAAK3B,MAAM2F,KAAK,GAChB,UAGF,IADA,IAAMC,EAASjE,KAAK3B,MAAM2F,KAAK,GACtBE,EAAI,EAAGA,EAAID,EAAOlD,OAAQmD,IAAK,CACtC,IAAIC,EAAQF,EAAOC,GAAG,GAClBE,EAAMH,EAAOC,GAAG,GAElBJ,GADQ,IAANI,EACgBC,EAAQ,IAAMC,EAEd,IAAMD,EAAQ,IAAMC,EAG1CpE,KAAK3B,MAAMM,MAAM0F,yBAAyBP,KAzB9C,gCA6BI9D,KAAK3B,MAAMM,MAAM0F,yBAAyB,MA7B9C,oCAkCgBC,GACZ,OAAItE,KAAK3B,MAAMM,MAAM4F,aAAe,GAAKD,EAErC,kBAAC,OAAD,CACEnD,EAAGnB,KAAK3B,MAAM8C,EACdsC,EAAGzD,KAAK3B,MAAMoF,EACdC,MAAO1D,KAAK3B,MAAMqF,MAClBC,OAAQ3D,KAAK3B,MAAMsF,QAAU,EAC7Ba,MAAO,SACPC,cAAe,SACfpE,KAAMiE,EAAW,IAAM,IACvBI,aAAc1E,KAAK2E,QAAQC,KAAK5E,MAChC6E,aAAc7E,KAAK8E,QAAQF,KAAK5E,QAI7B,OAlDb,+BAsDI,IAAMsE,EAAWtE,KAAK3B,MAAM2F,KAAK,GAAK,GAElCR,EAAQ,UAWZ,OATIc,IACFd,EAAQ,WAGNxD,KAAK3B,MAAM2F,KAAK,GAAK,IACvBR,EAAQ,WAKR,oCACE,kBAAC,OAAD,CACErC,EAAGnB,KAAK3B,MAAM8C,EACdsC,EAAGzD,KAAK3B,MAAMoF,EACdC,MAAO1D,KAAK3B,MAAMqF,MAClBC,OAAQ3D,KAAK3B,MAAMsF,QAAU,EAC7BC,KAAMJ,EACNkB,aAAc1E,KAAK2E,QAAQC,KAAK5E,MAChC6E,aAAc7E,KAAK8E,QAAQF,KAAK5E,QAEjCA,KAAK+E,cAAcT,QA9E5B,GAAgCxC,IAAMH,WCzBhCqD,EAAM,SAACC,GAAkB,IAAD,uBAATC,EAAS,iCAATA,EAAS,kBAE5B,OAAOD,EAAIE,KAAI,SAACC,EAAKC,GAAN,OAAYH,EAAKI,QAAO,SAACvH,EAAGkH,GAAJ,4BAAgBlH,GAAhB,CAAmBkH,EAAII,OAAK,CAACD,QAG/D,SAASG,EAAsBhH,GAMpC,IAHA,IAAIiH,EAYN,SAAuCjH,GAIrC,OAAIA,EAAWwC,OACCiE,EAAG,WAAH,cAAOzG,EAAW4G,KAAI,SAAChE,GAAD,OAAOA,EAAEsB,eAClB0C,KAAI,SAACM,GAAD,OAASA,EAAIC,MAAK,SAACvE,GAAD,OAAOA,QAGjD,EAAC,GArBSwE,CAA8BpH,GAC7CqH,EAAc,GACdC,EAAmB,EACdR,EAAI,EAAGA,EAAIG,EAAazE,OAAQsE,IACnCG,EAAaH,KACfO,EAAYP,GAAKQ,EACjBA,KAGJ,OAAOD,EAgBT,SAASE,EAAI/H,EAAGgI,GACd,OAAOhI,EAAIgI,E,IA6JEC,E,4MAzJbzC,MAAQ,CACNC,MAAO,a,EAGTyC,YAAc,WACa,cAArB,EAAK1C,MAAMC,MACb,EAAK0C,SAAS,CAAE1C,MAAO,cACO,cAArB,EAAKD,MAAMC,OACpB,EAAK0C,SAAS,CAAE1C,MAAO,e,6DAIX,IAAD,OACT2C,EAAQ,EACRC,EAAQpG,KAAK3B,MAAM2F,KAAKpB,OAAOuC,KAAI,SAACM,EAAKY,GAC3C,OAAIZ,EAAI1E,QACNoF,IACO,EAAKG,gBAAgBb,EAAKU,EAAOE,IAEjC,QAIX,OADArG,KAAK3B,MAAMM,MAAM4H,gBAAgBJ,GAC1B,oCAAGC,K,sCAGIX,EAAKU,EAAOE,GAAQ,IAAD,OAC3BG,EAASxG,KAAK3B,MAAM2F,KACpByC,EACJD,EAAOhE,eACPgE,EAAOrE,SAASpB,OAASf,KAAK3B,MAAMM,MAAM+H,gBACtChD,EAAQ,EAAI1D,KAAK3B,MAAMM,MAAM+H,gBAC/BC,EAASR,EACb,IAAKnG,KAAK3B,MAAMM,MAAMiI,uBAAwB,CAC5C,IAAK5G,KAAK3B,MAAMwI,uBAAuBC,eAAeT,GACpD,OAAO,KAETM,EAAS3G,KAAK3B,MAAMwI,uBAAuBR,GAG7C,OAAOZ,EAAIN,KAAI,SAAC4B,EAAM5F,GACpB,OAAI4F,EAAKhG,OAEL,oCACE,kBAAC,EAAD,CACEmC,IAAK,WAAamD,EAAQlF,EAC1B6C,KAAM+C,EACNpI,MAAO,EAAKN,MAAMM,MAClBoF,SAAU,EAAK1F,MAAMC,UAAU+H,GAC/BlF,EAAGsF,EAAQtF,EAAI,EAAK9C,MAAMM,MAAM+H,gBAChCjD,EACEkD,EAAS,EAAKtI,MAAMM,MAAM4F,aAC1B,EAAKlG,MAAMM,MAAMqI,UAEnBC,WAAYZ,EACZ3C,MAAOA,EACPC,OAAQ,EAAKtF,MAAMM,MAAM4F,gBAKxB,U,4CAKU,IAAD,OACdjC,EAAatC,KAAK3B,MAAM2F,KAAK1B,WAC/B4E,EAAmB5E,EAAWT,OAAO,GAAG,GAC5C,QAAyBsF,IAArBD,EAAgC,CAGlC,IAAIf,EAAQ,EASZ,OARI7D,EAAWvB,OAAS,IACtBoF,GAAS7D,EACNT,MAAM,GAAI,GACVsD,KAAI,SAACiC,GACJ,OAAOA,EAAOnE,aAAaqC,OAAOQ,MAEnCR,OAAOQ,IAGV,oCACGoB,EAAiBjE,aAAakC,KAAI,SAACkC,EAAcnD,GAChD,OAAImD,GACFlB,IACO,EAAKmB,yBAAyBD,EAAclB,EAAOjC,IAEnD,SAMf,OAAO,O,+CAGcmD,EAAclB,EAAOjC,GAC5C,IAAIzC,EAAYzB,KAAK3B,MAAM2F,KAErByC,EACJhF,EAAUe,gBACTf,EAAUU,SAASpB,QACjBf,KAAK3B,MAAMM,MAAM4I,oBACdvH,KAAK3B,MAAMM,MAAM6I,iBACjB/F,EAAUoB,SACdpB,EAAUa,WAAWvB,OACrB,GACAf,KAAK3B,MAAMM,MAAM+H,gBACjBC,EAASR,EAIb,OAHKnG,KAAK3B,MAAMM,MAAMiI,yBACpBD,EAAS3G,KAAK3B,MAAMwI,uBAAuB3C,IAG3C,kBAAC,EAAD,CACEhB,IAAK,YAAcgB,EACnB/C,EAAGsF,EACHhD,EAAGzD,KAAK3B,MAAMM,MAAMqI,UAAYL,EAAS3G,KAAK3B,MAAMM,MAAM4F,aAC1Db,MAAO1D,KAAK3B,MAAMM,MAAM+H,gBACxB/C,OAAQ3D,KAAK3B,MAAMM,MAAM4F,aACzBf,MAAO,c,+BAMX,OACE,oCACE,kBAAC,OAAD,CACErC,EAAGnB,KAAK3B,MAAM2F,KAAKxB,eACnBiB,EAAGzD,KAAK3B,MAAMM,MAAMqI,UACpB9D,IAAKlD,KAAKuD,MAAML,IAAM,IACtBQ,MAAO1D,KAAK3B,MAAMoJ,eAAiBzH,KAAK3B,MAAMM,MAAM+H,gBACpD/C,OAAQ3D,KAAK3B,MAAMsF,OAAS,EAC5BC,KAAM5D,KAAKuD,MAAMC,MACjBkE,QAAS1H,KAAKiG,cAEdjG,KAAK3B,MAAMM,MAAM4I,oBAA4C,KAAtBvH,KAAK2H,eAC7C3H,KAAK3B,MAAMM,MAAM0I,aAAerH,KAAK4H,sBAAwB,U,GA3I1C9F,IAAMH,WCAnBkG,E,gLA7BX,IARA,IAAMrB,EAASxG,KAAK3B,MAAM2F,KACpByC,EACJD,EAAOhE,eACPgE,EAAOrE,SAASpB,OAASf,KAAK3B,MAAMM,MAAM+H,gBAIxCoB,EAAgB,GACX3G,EAAI,EAAGA,EAAInB,KAAK3B,MAAM2F,KAAKnB,QAAS1B,IAC3C2G,EAAcrH,KACZ,kBAAC,OAAD,CACEyC,IAAK,WAAa/B,EAClBA,EAAGsF,EAAQtF,EAAInB,KAAK3B,MAAMM,MAAM+H,gBAChCjD,EAAGzD,KAAK3B,MAAMM,MAAMqI,UAAYhH,KAAK3B,MAAMM,MAAMoJ,iBACjD1H,KAAML,KAAK3B,MAAMI,YAAY0C,GAC7BqD,MAAM,SACNb,OAAQ3D,KAAK3B,MAAMM,MAAMoJ,iBACzBrE,MAAO1D,KAAK3B,MAAMM,MAAM+H,mBAI9B,OAAOoB,I,+BAKP,OAAO9H,KAAKsG,sB,GA5BmBxE,IAAMH,WC0E1BU,E,kDAzEb,WAAYhE,GAAQ,IAAD,8BACjB,cAAMA,IACD2J,eAAiB,EAAKA,eAAepD,KAApB,gBACtB,EAAKqD,gBAAkB,EAAKA,gBAAgBrD,KAArB,gBAHN,E,8DAMjB5E,KAAK3B,MAAM6J,sBAAsBlI,KAAK3B,MAAM2F,Q,uCAG5ChE,KAAK3B,MAAM6J,sBAAsB,Q,kCAGjC,IADU,EACNC,EAAQ,GACRhC,EAAQ,EAFF,cAGmBnG,KAAK3B,MAAM2F,KAAKf,aAAa1B,WAHhD,IAGV,2BAAqE,CAAC,IAAD,yBAAzD8D,EAAyD,KACnE,GADmE,KACpD,CACb,IAAIsB,EAASR,IACb,IAAKnG,KAAK3B,MAAMM,MAAMiI,uBAAwB,CAC5C,IAAK5G,KAAK3B,MAAMwI,uBAAuBC,eAAezB,GACpD,SAEFsB,EAAS3G,KAAK3B,MAAMwI,uBAAuBxB,GAE7C,IAAII,EAAMkB,EAAS3G,KAAK3B,MAAMM,MAAM4F,aACpC4D,EAAM1H,KAAKgF,KAbL,8BAgBV,OAAO0C,I,0CAGPnI,KAAKkG,SAAS,CACZ1C,MAAOxD,KAAK3B,MAAMmF,U,+BAGZ,IAAD,OACD4E,EAAWpI,KAAKqI,YACtB,OACE,oCACGD,EAASjD,KAAI,SAACmD,EAASC,GACtB,OACE,kBAAC,OAAD,CACErF,IAAK,MAAQqF,EACbpH,EAAG,EAAK9C,MAAM8C,EACdsC,EACE,EAAKpF,MAAMM,MAAMqI,UACjBsB,EAEF5E,MAAO,EAAKrF,MAAMM,MAAM+H,gBACxB/C,OAAQ,EAAKtF,MAAMM,MAAM4F,aACzBX,KAAM,EAAKvF,MAAMmF,MACjBgF,QAAS,EAAKnK,MAAMmK,QACpBC,OAAQ,EAAKpK,MAAMoK,OAEnBC,YAAa,EAAKT,gBAClBU,WAAY,EAAKX,yB,GAvDNlG,IAAMH,WCA/B,SAASiH,EAAWC,GAClB,OAAQC,OAAOC,SAASF,G,IA+JXG,E,kDA1Jb,WAAY3K,GAAQ,IAAD,8BACjB,cAAMA,IAoGR4J,gBAAkB,WAChB,EAAK5J,MAAM6J,sBAAsB,EAAK7J,MAAM4K,KAAKnG,aAtGhC,EAwGnBkF,eAAiB,WACf,EAAK3J,MAAM6J,sBAAsB,OAzGhB,EA2GnBjC,YAAc,SAACiD,GAGbjK,QAAQC,IAAI,QAASgK,EAAO,EAAK7K,MAAM4K,MAHhB,kBAKQ,EAAK5K,MAAMM,MAAMwK,YALzB,GAKlBC,EALkB,KAKLC,EALK,mBAOI,EAAKhL,MAAMM,MAAMwK,YAPrB,GAOhBvI,EAPgB,KAONC,EAPM,KAUnB6C,EAAQ7C,EAASD,EACjB0I,EAAU1I,EAAW8C,EAAQ,EAQ7B6F,EAJFC,KAAKC,IAAI,EAAKpL,MAAM4K,KAAKnG,WAAWC,SAAWuG,GAC/CE,KAAKC,IAAI,EAAKpL,MAAM4K,KAAKnG,WAAWE,WAAasG,GAI/C,EAAKjL,MAAM4K,KAAKnG,WAAWE,WAC3B,EAAK3E,MAAM4K,KAAKnG,WAAWC,SAEzBwG,GAAmB3I,GAAY2I,GAAmB1I,IAItDwI,GADAD,EAAcI,KAAKE,IAAI,KAAMH,EAAkB7F,EAAQ,KAC7BA,GAI5B,EAAKrF,MAAMsL,mBACT,EAAKtL,MAAM4K,KAAKnG,WAChBsG,EACAC,IA3IF,EAAKO,YAAc,KACnB,EAAKC,OAAS,GACd,EAAK7B,eAAiB,EAAKA,eAAepD,KAApB,gBACtB,EAAKqD,gBAAkB,EAAKA,gBAAgBrD,KAArB,gBALN,E,4GAgBjB,IAAIqE,EAAOjJ,KAAK3B,MAAM4K,KACtBjJ,KAAK4J,YAAc5J,KAAK3B,MAAM4K,KAAKa,SACnC,IAEIC,EAFgB/J,KAAK3B,MAAM4K,KAAKe,QAGlBhK,KAAK4J,YAAc5J,KAAK3B,MAAMM,MAAM+H,gBAAkB,EACpEuD,EAAOjK,KAAK3B,MAAMM,MAAM+H,gBAAkB,EAE1CwD,EAAgBH,EAAa,GAAK,EAAI,EACpCI,EAAe,CAACJ,EAAY/J,KAAK3B,MAAMM,MAAM+H,gBAAkB,GAC/D0D,EAAe,CAACL,EAAaG,EAAiC,EAAjBjB,EAAKoB,WACpDC,EAAY,CAACP,EAA6B,EAAhBG,GAAoBjB,EAAKoB,WACnDE,EAAY,CAACN,EAAuB,EAAhBC,GAAoBjB,EAAKoB,WAC7CG,EAAe,CAACP,EAAOC,EAAiC,EAAjBjB,EAAKoB,WAC1CI,EAAkB,CAACR,GAAO,GAChCjK,KAAK6J,OAAS,CACZM,EAAa,GACbA,EAAa,GACbC,EAAa,GACbA,EAAa,GACbE,EAAU,GACVA,EAAU,GACVC,EAAU,GACVA,EAAU,GACVC,EAAa,GACbA,EAAa,GACbC,EAAgB,GAChBA,EAAgB,GAChBR,GACC,GAECT,KAAKC,IAAIM,IAAe/J,KAAK3B,MAAMM,MAAM+H,kBAEvCuC,EAAKyB,UACP1K,KAAK6J,OAAS,CACZI,GACC,GACDA,GA9BO,GAkCTjK,KAAK6J,OAAS,CACZM,EAAa,IAnCN,EAoCEnK,KAAK3B,MAAMM,MAAM+H,gBAC1ByD,EAAa,IACZ,KAIHnK,KAAK6J,OAAOnE,KAAKiF,QAAU3K,KAAK6J,OAAOnE,KAAKkD,KAC9C3J,QAAQC,IAAI,wBAA0Bc,KAAK6J,U,+BAY7C,OANA7J,KAAK4K,kBAOH,kBAAC,QAAD,CACEzJ,EAAGnB,KAAK4J,YACRnG,EAAGzD,KAAK3B,MAAMM,MAAMqI,UAAY,GAChCtD,MAAO1D,KAAK3B,MAAMM,MAAM+H,gBACxBmD,OAAQ7J,KAAK6J,OACbgB,QAAQ,EACRC,YAAa9K,KAAK3B,MAAMM,MAAM+H,gBAC9B9C,KAAM5D,KAAK3B,MAAMmF,MACjBiF,OAAQzI,KAAK3B,MAAMmF,MACnBgF,QAASxI,KAAK3B,MAAMmK,QACpBuC,iBAAgB/K,KAAK3B,MAAMmK,QAC3BwC,cAAe,EACfC,aAAc,EACdC,QAAS,EAAI,EACbxC,YAAa1I,KAAKiI,gBAClBU,WAAY3I,KAAKgI,eACjBN,QAAS1H,KAAKiG,kB,GAjGEnE,IAAMH,WCRjBwJ,EAAb,WACE,WAAYrI,GAAgE,IAApDsI,EAAmD,uDAAnC,EAAGC,EAAgC,uDAAd,EAAGX,EAAW,2DACzE1K,KAAK8C,WAAaA,OACCqE,IAAfrE,GACF7D,QAAQC,IAAI4D,EAAYsI,EAAeC,GAEzCrL,KAAK8J,SAAWsB,EAChBpL,KAAKgK,QAAUqB,EACfrL,KAAKqK,UAAY,GACjBrK,KAAK0K,UAAYA,EATrB,uDAYI,OAAOlB,KAAKC,IAAIzJ,KAAKgK,QAAUhK,KAAK8J,WAAa,MAZrD,KAgBO,SAASwB,EACdC,EACA7E,EACAM,EACAO,EACAC,EACAgE,GAYA,IAFA,IAAIC,EAAiB,GAEZpG,EAAI,EAAGA,EAAIkG,EAAUxK,OAAQsE,IAAK,CAIzC,IAHA,IAAIqG,EAAsBH,EAAUlG,GAG3BnB,EAAI,EAAGA,EAAIwH,EAAoBvJ,SAASpB,OAAQmD,IAAK,CAC5D,IAAI9B,EAAUsJ,EAAoBvJ,SAAS+B,GACvCkH,EAAgBI,EAAWE,EAAqBrG,EAAG,EAAGnB,GACtDyH,EAAYvJ,EAAQc,IAClByI,KAAaF,EAUjBA,EAAeE,GAAW7B,SAAWsB,EAPrCK,EAAeE,GAAa,IAAIR,EAC9B/I,EACAgJ,EACAA,GACA,GAON,IAAK,IAAIQ,EAAI,EAAGA,EAAIF,EAAoBpJ,WAAWvB,OAAS,EAAG6K,IAAK,CAClE,IAAIrJ,EAAYmJ,EAAoBpJ,WAAWsJ,GAC3CP,EAAkBG,EACpBE,EACArG,EACAqG,EAAoBvJ,SAASpB,QAC1BwG,EACGC,EACAkE,EAAoB7I,SAC1B+I,GAEED,EAAYpJ,EAAUW,IACpByI,KAAaF,EAUjBA,EAAeE,GAAW3B,QAAUqB,EAPpCI,EAAeE,GAAa,IAAIR,EAC9B5I,EACA8I,EACAA,GACA,IAOR,OAGF,SAAiCQ,EAAgBnF,EAAiBM,GAMhE,IAAI8E,EAAsBC,OAAOC,OAAOH,GAAgBI,MACtD,SAAClO,EAAGgI,GAAJ,OAAUhI,EAAEmO,WAAanG,EAAEmG,cAEzBC,EASN,SACEL,EACApF,EACAM,GAIA,IAHA,EAGIjG,EAASyI,KAAKE,IAAL,MAAAF,KAAI,CACf,GADe,mBAEZsC,EAAoB3G,KAAI,SAAChE,GAAD,OAAOqI,KAAKE,IAAIvI,EAAE6I,QAAS7I,EAAE2I,gBAEtDqC,EAAoB,IAAIzJ,MAAM3B,GAAQ6C,KAAK,IAP/C,cAQmBkI,GARnB,IAQA,2BAAwC,CAAC,IAAhCM,EAA+B,QAClCC,EAAY7C,KAAKE,IAAI,EAAGF,KAAK8C,IAAIF,EAAOtC,SAAUsC,EAAOpC,UACzDuC,EAAU/C,KAAKE,IAAI0C,EAAOtC,SAAUsC,EAAOpC,QAASqC,EAAY,GAChEG,EAAQL,EAAkBtK,MAAMwK,EAAWE,EAAU,GACrDlC,EAAYmC,EAAMzL,OAASyI,KAAKE,IAAL,MAAAF,KAAI,YAAQgD,IAAS,IAChD7B,MAAMN,IAAevB,OAAOC,SAASsB,IACvCpL,QAAQC,IACN,gBACAkN,EACAC,EACAE,EACAC,EACAL,GAIJ9B,GAA0B3D,EAC1B,IAAK,IAAIvF,EAAIkL,EAAWlL,EAAIoL,GAAWpL,EAAIgL,EAAkBpL,OAAQI,IACnEgL,EAAkBhL,GAAKkJ,EAEzB+B,EAAO/B,UAAYA,GA5BrB,8BA8BA,OAAO8B,EA3CiBM,CACtBX,EACApF,GAGEgG,EAAMlD,KAAKE,IAAL,MAAAF,KAAI,YAAQ2C,IAAuC,EAAlBzF,EAC3C,MAAO,CAACoF,EAAqBY,GAlBtBC,CAAwBlB,EAAgB/E,G,oBC7E5BkG,E,uKACT,IAAD,OACP,OACE,kBAACC,EAAA,EAAD,CACEC,SAAS,EACTC,QAAS,GACTC,SAAU,GACVC,MAAO,CAAEC,WAAY,QAASC,OAAQ,EAAG,cAAe,aAExD,kBAAC,IAAD,MACG,kBAAM,8BAAO,EAAK9O,MAAMM,MAAMyO,4B,GAVMtL,IAAMH,WCA/C0L,E,oKACEC,GACJ,IAAM1M,EAAWZ,KAAK3B,MAAMM,MAAM+B,cAC5BG,EAASb,KAAK3B,MAAMM,MAAMgC,YAC5B4M,EAAO1M,EAASD,EAChB4M,EAAOhE,KAAKiE,MAAMF,GAAQD,EAAa,MAC3CrO,QAAQC,IAAI2B,EAAS,IAAMD,EAAW,IAAM2M,EAAO,iBAAgBC,GACnExN,KAAK3B,MAAMM,MAAM+O,kBAAkB9M,EAAW4M,EAAM3M,EAAS2M,K,mCAI7DvO,QAAQC,IACN,oBACEc,KAAK3B,MAAMM,MAAMgP,WAAWC,KAC5B,yBACA5N,KAAK3B,MAAMM,MAAMgP,WAAWE,QAIhC,IAAMlP,EAAQqB,KAAK3B,MAAMM,OTVtB,SAAP,6BSgCImP,CArBanP,EAAMoP,uBACDpP,EAAMgP,WAAWC,KAoBH,IAnBhBjP,EAAMgP,WAAWE,QAEjC,SAAkCG,GAChC,GAAe,MAAXA,EACFC,MACE,2HAEG,CACLhP,QAAQC,IAAI8O,GAEZA,EAASE,SAASF,GAClB,IAAM5E,EAAcI,KAAK2E,KAAKH,EAAShO,KAAK3B,MAAMM,MAAMyP,eACxDnP,QAAQC,IAAIkK,GACZzK,EAAM+O,kBAAkBtE,EAAazK,EAAMgC,mB,wCAU/B0N,GAChBpP,QAAQC,IACN,sBACEmP,EAAOC,MACP,OACAD,EAAOE,QAAQF,EAAOG,eAAenO,MAEzCL,KAAK3B,MAAMM,MAAM8P,0BAA0BP,SAASG,EAAOC,U,kDAI3D,IAAII,EAAoB1O,KAAK3B,MAAMM,MAAMgQ,uBACrCD,EAAoB,GACtB1O,KAAK3B,MAAMM,MAAM8P,0BAA0BC,EAAoB,K,kDAKjE,IAAIA,EAAoB1O,KAAK3B,MAAMM,MAAMgQ,uBACrCD,EAAoB1O,KAAK3B,MAAMM,MAAMiQ,oBAAoB7N,OAAS,GACpEf,KAAK3B,MAAMM,MAAM8P,0BAA0BC,EAAoB,K,+BAIzD,IAAD,OACP,OACE,yBAAKG,GAAG,oBACN,4BAAQC,UAAU,SAASD,GAAG,gBAA9B,cAGA,2BACEE,KAAK,OACLC,aAAchP,KAAK3B,MAAMM,MAAMC,SAC/BqO,MAAO,CAAEvJ,MAAO,SAChBuL,SAAUjP,KAAK3B,MAAMM,MAAMuQ,YAC3BC,MAAO,UAET,0BAAMlC,MAAO,CAAEmC,WAAY,SACzB,kBAAC,IAAD,MACG,kBACC,iDAEE,4BACEN,UAAU,SACVpH,QAAS,kBAAM,EAAK2H,8BAFtB,KAMA,4BACER,GAAG,mBACHI,SAAU,SAAC7J,GAAD,OAAS,EAAKkK,kBAAkBlK,EAAIiJ,SAC9CC,MAAO,EAAKjQ,MAAMM,MAAMgQ,wBAEvB,EAAKtQ,MAAMM,MAAMiQ,oBAAoBzJ,KAAI,SAACnB,EAAMqB,GAAP,OACxC,4BAAQnC,IAAKmC,EAAGiJ,MAAOjJ,GACpBrB,OAIP,4BACE8K,UAAU,SACVpH,QAAS,kBAAM,EAAK6H,8BAFtB,UAWR,0BAAMtC,MAAO,CAAEmC,WAAY,SACzB,4BAAQN,UAAU,SAASpH,QAAS,kBAAM,EAAK8H,OAAO,OAAtD,MAGA,4BAAQV,UAAU,SAASpH,QAAS,kBAAM,EAAK8H,OAAO,MAAtD,KAJF,0BAQE,kBAAC,IAAD,MACG,kBACC,oCACE,2BACET,KAAK,SACLT,MAAO,EAAKjQ,MAAMM,MAAMwK,YAAY,GACpC8F,SAAU,SAAC/F,GAAD,OACR,EAAK7K,MAAMM,MAAM+O,kBACfxE,EAAMmF,OAAOC,MACb,EAAKjQ,MAAMM,MAAMgC,cAGrBsM,MAAO,CAAEvJ,MAAO,UAVpB,IAaE,2BACEqL,KAAK,SACLT,MAAO,EAAKjQ,MAAMM,MAAMwK,YAAY,GACpCsG,UAAQ,EACRxC,MAAO,CAAEvJ,MAAO,cAKxB,4BAAQoL,UAAU,SAASpH,QAAS,kBAAM,EAAK8H,MAAM,MAArD,KAGA,4BAAQV,UAAU,SAASpH,QAAS,kBAAM,EAAK8H,MAAM,OAArD,OAIF,yBAAKV,UAAW,OAAhB,uCAEE,2BACEC,KAAK,SACLW,KAAK,OACLC,YAAa,OACbV,SAAU,SAAC/F,GAAD,OACR,EAAK7K,MAAMM,MAAMiR,iBACf1G,EAAMmF,OAAOC,MACb,EAAKjQ,MAAMM,MAAMgP,WAAWE,SAGhCZ,MAAO,CAAEvJ,MAAO,UAElB,8BAAUmL,GAAG,QACV7O,KAAK3B,MAAMkN,UAAUjN,UAAU6G,KAAI,SAACnB,EAAMd,GAAP,OAClC,4BAAQA,IAAKA,EAAKoL,MAAOtK,QAhB/B,IAoBE,2BACE+K,KAAK,SACLY,YAAa,WACbV,SAAU,SAAC/F,GAAD,OACR,EAAK7K,MAAMM,MAAMiR,iBACf,EAAKvR,MAAMM,MAAMkR,UACjB3G,EAAMmF,OAAOC,QAGjBrB,MAAO,CAAEvJ,MAAO,UAElB,0BAAMuJ,MAAO,CAAEmC,WAAY,QACzB,4BAAQN,UAAU,SAASpH,QAAS,kBAAM,EAAKoI,eAA/C,UAKJ,yBAAKhB,UAAW,OACd,8BACG,IADH,4BAGE,kBAAC,EAAD,CAA8BnQ,MAAOqB,KAAK3B,MAAMM,SAElD,8BACG,IADH,4BAGE,kBAAC,EAAD,CAA2BA,MAAOqB,KAAK3B,MAAMM,SAE9CqB,KAAK3B,MAAMM,MAAM4I,oBAChB,kBAAC,IAAMwI,SAAP,KACE,8BACG,IADH,qBAGE,kBAAC,EAAD,CAAuBpR,MAAOqB,KAAK3B,MAAMM,UAK7C,qCAEF,8BACG,IADH,cAGE,kBAAC,IAAD,MACG,kBACG,2BACIoQ,KAAK,SACLzC,IAAK,EACLgC,MAAO,EAAKjQ,MAAMM,MAAM4F,aACxB0K,SAAU,EAAK5Q,MAAMM,MAAMqR,aAC3B/C,MAAO,CAACvJ,MAAO,cAI3B,8BACG,IADH,gBAGE,2BACEqL,KAAK,SACLzC,IAAK,EACLgC,MAAOtO,KAAK3B,MAAMM,MAAM+H,gBACxBuI,SAAUjP,KAAK3B,MAAMM,MAAMsR,YAC3BhD,MAAO,CAAEvJ,MAAO,iB,GA5OF5B,IAAMH,WAyP5BuO,E,uKACM,IAAD,OACP,OACE,kBAAC,IAAD,MACG,kBACC,2BACEnB,KAAK,WACLoB,QAAS,EAAK9R,MAAMM,MAAMiI,uBAC1BqI,SAAU,EAAK5Q,MAAMM,MAAMyR,sC,GARItO,IAAMH,WAoB3C0O,E,uKACM,IAAD,OACP,OACE,kBAAC,IAAD,MACG,kBACC,2BACEtB,KAAK,WACLoB,QAAS,EAAK9R,MAAMM,MAAM0I,aAC1B4H,SAAU,EAAK5Q,MAAMM,MAAM2R,4B,GARHxO,IAAMH,WAoBpC4O,E,uKACM,IAAD,OACP,OACE,kBAAC,IAAD,MACG,kBACC,2BACExB,KAAK,WACLoB,QAAS,EAAK9R,MAAMM,MAAM4I,oBAC1B0H,SAAU,EAAK5Q,MAAMM,MAAM6R,mC,GARC1O,IAAMH,WAoB/B0L,IC1TR,SAASoD,EAAYC,EAAGC,GAC7B,OAAqB,IAAbD,EAAE3P,QAA6B,IAAb4P,EAAE5P,QACvB2P,EAAE3P,SAAW4P,EAAE5P,QACZ2P,EAAEE,OAAM,SAACC,GAAD,OAAOF,EAAEG,QAAQD,IAAM,KAiDlC,SAASE,EACdjO,EACAkO,EACAC,GAEA,IAAMC,EAAsBD,GAExBD,EAEEG,GAAYrO,EAAWE,WAAa,IAAMF,EAAWC,SAAW,GACtE,GAAImO,EAAqB,CAEvB,IAAIE,GACDF,EAAoBlO,WAAa,IAAMkO,EAAoBnO,SAAW,GAEzE,OAAMiO,IAA0BC,GAAiBE,IAAaC,EACrD,CACLC,EAAmBF,GACnB,EACAH,GAAyBC,EAAe,QAAU,MAG7C,CAAC,OAAQ,GAAK,MAGvB,MAAO,CAACI,EAAmBF,GAAW,EAAK,MAIxC,SAASE,EAAmBF,GACjCA,EAAWA,EAASG,WAEpB,IADA,IAAIC,EAAO,EACFlM,EAAI,EAAGA,EAAI8L,EAASpQ,OAAQsE,IACnCkM,EAAOJ,EAASK,WAAWnM,KAAOkM,GAAQ,GAAKA,GAGjD,IADA,IAAIE,EAAS,IACJvN,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAE1BuN,IAAW,MADIF,GAAa,EAAJrN,EAAU,KACVoN,SAAS,KAAK9Q,QAAQ,GAEhD,OAAOiR,E,qBCwmBMC,E,kDAzqBb,WAAYrT,GAAQ,IAAD,8BACjB,cAAMA,IANRsT,SAAW7P,IAAM8P,YAKE,EAJnBC,UAAY/P,IAAM8P,UAAU,MAIT,EAHnBE,sBAAwB,KAGL,EAFnBC,mBAAqB,KAEF,EAuRnBC,kBAAoB,WAClB,IACIC,EADqBC,SAASC,eAAe,oBACXF,aAEpBC,SAASE,uBAAuB,mBAAmB,GAC3DnF,MAAMoF,SAAW,WAE3B,EAAKnM,SAAS,CAAEoM,cAAeL,IAE/B,EAAKN,SAASY,QAAQC,YAAYC,QAAQ5D,GAAK,OAC/C,EAAK8C,SAASY,QAAQC,YAAYC,QAAQJ,SAAW,WAErD,EAAKR,UAAUU,QAAQC,YAAYC,QAAQ5D,GAAK,QAChD,EAAKgD,UAAUU,QAAQC,YAAYC,QAAQJ,SAAW,YApSrC,EA4SnBK,uBAAyB,SAACC,GACxB,EAAKzM,SAAS,CAAE0M,gBAAiBD,IACjC,EAAKE,iBA9SY,EAkTnB3K,sBAAwB,SAACyK,GAElB,EAAKpP,MAAM0N,eACE,MAAZ0B,GAGFG,aAAa,EAAKhB,uBAGd,EAAKvO,MAAMqP,kBAAoBD,IAGjC,EAAKb,sBAAwBiB,YAC3B,WACE,EAAKL,uBAAuBC,KAE9B,QAMJG,aAAa,EAAKhB,uBAGgB,MAA9B,EAAKvO,MAAMqP,kBACb,EAAKd,sBAAwBiB,YAC3B,WACE,EAAKL,uBAAuBC,KAE9B,SAhVS,EAuVnBhJ,mBAAqB,SAACgJ,EAAUvJ,EAAaC,GAC3CpK,QAAQC,IAAI,sBAD6C,kBAG9B,EAAKb,MAAMM,MAAMwK,YAHa,GAGlDvI,EAHkD,KAGxCC,EAHwC,KAOrDmS,GAAe,EACbpS,GAAYwI,GAAeC,GAAaxI,IAC5C5B,QAAQC,IAAI,uCAEZ,EAAKb,MAAMM,MAAM+O,kBAAkBtE,EAAaC,GAChD2J,GAAe,GAGjBF,aAAa,EAAKhB,wBAIda,IAAa,EAAK1B,cAAgB+B,KACpC/T,QAAQC,IAAI,qCAEZ,EAAKgH,SAAS,CACZ0M,gBAAiBD,EACjB1B,aAAc0B,KAKdA,IACF1T,QAAQC,IAAI,qBAGZ4T,aAAa,EAAKf,oBAElB,EAAKA,mBAAqBgB,YACxB,WAAO,IAAD,cACuB,EAAK1U,MAAMM,MAAMwK,YADxC,GACGvI,EADH,KACaC,EADb,KAEJ,EAAK8I,mBAAmB,KAAM/I,EAAUC,KAE1C,OA/Xa,EAygBnBoS,2BAA6B,WAC3B,IACG,EAAK5U,MAAMM,MAAMuU,SAGiB,IAAnC,EAAK7U,MAAMM,MAAMyP,gBAChB,EAAK/P,MAAMM,MAAM4I,qBAClB,EAAKlJ,MAAMM,MAAM+H,iBAAmB,IACpC,EAAK6E,UAAU9M,YAAYsC,OAAS,EAGpC,OAAO,EAAKwK,UAAUhN,WAAW4G,KAAI,SAACuG,EAAqBrG,GAsBzD,IAAM8N,EAAoB,EAAK5H,UAAU9M,YAAYoD,MACnD6J,EAAoB1J,SAAW,EAAK3D,MAAMM,MAAMyU,cAChD1H,EAAoBzJ,QAAU,EAAK5D,MAAMM,MAAMyU,cAAgB,GAKjE,OACE,kBAAC,IAAMrD,SAAP,CAAgB7M,IAAK,KAAOmC,GAC1B,kBAAC,EAAD,CACE1G,MAAO,EAAKN,MAAMM,MAClBqF,KAAM0H,EACNxI,IAAKmC,EACL1B,OAAQ,EAAK0P,sBACb3P,MACEgI,EAAoBvJ,SAASpB,QAC5B,EAAK1C,MAAMM,MAAM4I,oBACd,EAAKlJ,MAAMM,MAAM6I,iBACjBkE,EAAoB7I,UACvB6I,EAAoBpJ,WAAWvB,OAAS,GAG3CtC,YAAa0U,SA7jBvB,EAAKjL,sBAAwB,EAAKA,sBAAsBtD,KAA3B,gBAC7B,EAAK+E,mBAAqB,EAAKA,mBAAmB/E,KAAxB,gBAE1B,EAAKrB,MAAQ,CACX+P,WAAY,GACZhV,UAAW,GACXiV,YAAa,EACbjB,cAAe,GAEjB,EAAK/G,UAAY,IAAInN,EAAmB,CAAEO,MAAO,EAAKN,MAAMM,QAmB5DE,kBAAQ,EAAKR,MAAMM,MAAMqC,UAAW,EAAKwS,eAAe5O,KAApB,iBAGpC/F,kBACE,EAAKR,MAAMM,MACX,yBACA,EAAK8U,wBAAwB7O,KAA7B,iBAEF/F,kBACE,EAAKR,MAAMM,MACX,sBACA,EAAKkU,cAAcjO,KAAnB,iBAEF/F,kBAAQ,EAAKR,MAAMM,MAAO,eAAgB,EAAKkU,cAAcjO,KAAnB,iBAC1C/F,kBAAQ,EAAKR,MAAMM,MAAO,kBAAmB,EAAKkU,cAAcjO,KAAnB,iBAC7C/F,kBAAQ,EAAKR,MAAMM,MAAO,eAAgB,EAAK+U,QAAQ9O,KAAb,iBAI1C/F,kBACE,EAAKR,MAAMM,MAAMmC,gBACjB,EAAK2S,wBAAwB7O,KAA7B,iBAIF/F,kBAAQ,EAAKR,MAAMM,MAAO,UAAW,EAAKgV,OAAO/O,KAAZ,iBAGrC/F,kBACE,EAAKR,MAAMM,MACX,aACA,EAAKiV,4BAA4BhP,KAAjC,iBAGF/F,kBACE,EAAKR,MAAMM,MACX,yBACA,EAAKiV,4BAA4BhP,KAAjC,iBAEF/F,kBACE,EAAKR,MAAMM,MAAMwK,YAEjB,EAAKyK,4BAA4BhP,KAAjC,iBAGFiP,IAAgB,EAAKxV,MAAMM,OA5EV,E,0EAuFjB,GAJAM,QAAQC,IACN,oEAIgC,OAAhCc,KAAK3B,MAAMM,MAAMmV,YAChB9T,KAAK3B,MAAMM,MAAMmV,WAAWC,YAAYC,OAF3C,CAMA,IAAMpT,EAAWZ,KAAK3B,MAAMM,MAAM+B,cAGlCV,KAAK3B,MAAMM,MAAMsV,uBACfjU,KAAK3B,MAAMM,MAAMmV,WAAjB,YAA2CE,QAE7C,IAAME,EAAalU,KAAK3B,MAAMM,MAAMwV,uBAjBR,EDvGzB,SAAmCvT,EAAUsT,EAAYvV,GAU9D,IATA,IACIyV,EADc,KACezV,EAAM+H,gBACnC2N,EAAgB,GAChBC,EAAiB,GAEjBC,EAAU3T,EAAW,EACrB4T,EAAe,EAEfC,EAAQ9V,EAAMmV,WAAWC,YAAYW,IAAIR,GACpCS,EAAS,EAAGA,EAASF,EAAMG,MAAM7T,OAAQ4T,IAAU,CAE1D,IAAIE,EAAQJ,EAAMG,MAAMD,GACxB,GAAIE,EAAM3S,UAAYtB,EAAU,CAC9B,IAAI8C,EACFmR,EAAK,SACLA,EAAK,UACLA,EAAK,gBACLA,EAAK,WACHC,EAAmBV,EAAeI,EAMtC,GALAA,GAAgB9Q,EAChB2Q,EAAc5T,KAAKoU,EAAK,MACJ,OAAhBA,EAAME,OACRT,EAAe7T,KAAKoU,EAAME,OAExBP,EAAeJ,EAAc,CAE/B,IAAIY,GAAWH,EAAK,SAAeA,EAAK,WAAiBnR,EACzD6Q,EAAU/K,KAAKyL,MAAMH,EAAmBE,GAExC,QASN,MAAO,CAACT,EAASF,EAAeC,GCkFYY,CACxCtU,EACAsT,EACAlU,KAAK3B,MAAMM,OArBe,mBAkBvBkC,EAlBuB,KAkBfsU,EAlBe,KAkBJb,EAlBI,KA0B5BrV,QAAQC,IAAI,CAACgV,EAAYrT,EAAQsU,EAAWb,IAC5C,IAAIc,EACFhW,iIACAY,KAAK3B,MAAMM,MAAMC,SACjB,IACAsV,EACA,IACFiB,EAAYA,EAAUhQ,KAAI,SAACkQ,GACzB,OAAOD,EAAYC,KAErBf,EAAiBA,EAAenP,KAAI,SAACkQ,GACnC,OAAOD,EAAYC,KAGrBrV,KAAK3B,MAAMM,MAAM2W,qBAAqBhB,GAGjCtU,KAAK3B,MAAMM,MAAM4W,gBAAgBJ,IACpCnV,KAAK6S,mB,uCAIS,IAAD,OAMf,GAFA5T,QAAQC,IAAI,yDACZD,QAAQC,IAAI,iBAAkBc,KAAK3B,MAAMM,MAAMqC,WAC1ChB,KAAK3B,MAAMM,MAAMqC,UAAU0T,IAAI,GAApC,CANe,oBAUO1U,KAAK3B,MAAMM,MAAMqC,WAVxB,yBAUNwU,EAVM,QAYbvW,QAAQC,IAAI,mCAAqCsW,GACjD,EAAKjK,UAAUkK,UAAUD,GAAWlW,MAAK,SAACO,GACxCZ,QAAQC,IAAI,iCAAmCsW,GAC/C,EAAKjK,UAAUmK,cAAcF,EAAW3V,OAL5C,2BAAmD,IAVpC,oCAObZ,QAAQ0W,KAAK,2B,gDAaU,IAAD,OAEtBlF,EAAYzQ,KAAK3B,MAAMM,MAAMqC,UAAWhB,KAAK3B,MAAMM,MAAMmC,mBAEzD7B,QAAQC,IACN,wCACEc,KAAKuL,UAAUhN,WAAWwC,QAE9B9B,QAAQC,IACN,wHAIFc,KAAKkG,SACH,CACEoN,WAAYtT,KAAKuL,UAAUhN,WAC3BD,UAAW0B,KAAKuL,UAAUjN,YAE5B,WACE,EAAKuU,gBAEL,EAAKhM,uBAAyBtB,EAC5B,EAAKgG,UAAUhN,YAEjB,EAAKqX,2BAA6B,EAAKC,+BACrC,EAAKtK,UAAUhN,YAEjB,EAAKF,MAAMM,MAAMmX,YAAW,S,sCAMnB,IAAD,OACd7W,QAAQC,IAAI,iBADE,oBAOTc,KAAKuL,UAAUhN,WAAWgD,WAPjB,IAId,2BAG0C,CAAC,IAAD,yBAFxC8D,EAEwC,KADxCqG,EACwC,KACxCA,EAAoBlJ,eAAiBxC,KAAKwL,WACxCE,EACArG,EACA,EACA,IAZU,8BAgBd,IACM0Q,EAAsB/V,KAAKuL,UAAUhN,WACxC4G,KACC,SAAC1D,GAAD,OACEA,EAAUU,SAASpB,QAClBU,EAAUa,WAAWvB,OAAS,IAC9B,EAAK1C,MAAMM,MAAM4I,oBACd,EAAKlJ,MAAMM,MAAM6I,iBACjB/F,EAAUQ,QAAUR,EAAUO,UAClC,KAEHsD,QAXS,SAAC0Q,EAAaC,GAAd,OAA+BD,EAAcC,IAW1C,GACTC,EACJlW,KAAK3B,MAAMM,MAAM+H,gBAAkB1G,KAAKuL,UAAUhN,WAAWwC,OACzDwS,EACJwC,EAAsB/V,KAAK3B,MAAMM,MAAM+H,gBACvCwP,EACFlW,KAAKkG,SAAS,CACZqN,YAAaA,IAlCD,MAoCOjI,EACnBtL,KAAKuL,UAAUhN,WACfyB,KAAK3B,MAAMM,MAAM+H,gBACjB1G,KAAK3B,MAAMM,MAAMqI,UACjBhH,KAAK3B,MAAMM,MAAM4I,oBACjBvH,KAAK3B,MAAMM,MAAM6I,iBACjBxH,KAAKwL,WAAW5G,KAAK5E,OA1CT,mBAoCPmW,EApCO,KAoCAzJ,EApCA,KA4Cd1M,KAAK8L,oBAAsBqK,EAC3BnW,KAAK3B,MAAMM,MAAMyX,gBAAgBlI,SAASxB,M,gCAK1C1M,KAAKkG,SAAS,CAAE0M,gBAAiB,S,qDAGJrU,GAE7B,IADA,IAAI8X,EAA8B,EACzBhR,EAAI,EAAGA,EAAI9G,EAAWwC,OAAQsE,IAAK,CAC1C,IAEMiR,EAFY/X,EAAW8G,GACD5C,UACM8T,OAAOC,SAASzV,OAClDsV,EAA8B7M,KAAKE,IACjC4M,EACAD,GAIJ,OAAOA,I,4CAIP,OACErW,KAAK3B,MAAMM,MAAMiI,yBAChB5G,KAAK6G,6BAGkCM,IAApCnH,KAAK4V,6BACP5V,KAAK4V,2BAA6B5V,KAAK6V,+BACrC7V,KAAKuL,UAAUhN,aAGnBU,QAAQC,IACN,6BACAc,KAAK4V,6BAIJ5V,KAAK4V,2BAA6B,KAAO5V,KAAK3B,MAAMM,MAAM4F,eAK1DwH,OAAOiI,KAAKhU,KAAK6G,wBAAwB9F,OAAS,KACnDf,KAAK3B,MAAMM,MAAM4F,e,iCAkHZmH,EAAqBrG,EAAGoR,EAAsBvS,GA4BvD,QAnBuBlE,KAAK3B,MAAMM,MAAM4I,oBAIpCmE,EAAoB3J,SACnB2J,EAAoBlK,MAAQxB,KAAKuL,UAAUhN,WAAW,GAAGiD,OACxDxB,KAAK3B,MAAMM,MAAM6I,iBALnBkE,EAAoB3J,QACpB/B,KAAK3B,MAAMM,MAAM+X,cAChB1W,KAAK3B,MAAMM,MAAM+B,cAAgBV,KAAK3B,MAAMM,MAAMyU,cAAgB,IAMlDqD,EAAuBvS,GAC1ClE,KAAK3B,MAAMM,MAAM+H,gBASQrB,EAAIrF,KAAK3B,MAAMM,MAAM+H,kB,sCAGlCgF,EAAqBrG,EAAG/G,GAAY,IAAD,OACjD,OACE,oCACE,kBAAC,EAAD,CACEK,MAAOqB,KAAK3B,MAAMM,MAClBqF,KAAM0H,EACNxI,IAAK,IAAMmC,EACX1B,OAAQ3D,KAAKqT,sBACb5L,eACEiE,EAAoBvJ,SAASpB,QAC5Bf,KAAK3B,MAAMM,MAAM4I,oBACdvH,KAAK3B,MAAMM,MAAM6I,iBACjBkE,EAAoB7I,UACvB6I,EAAoBpJ,WAAWvB,OAAS,GAE3C8F,uBAAwB7G,KAAK6G,uBAC7BvI,UAAWA,IAGZoN,EAAoBvJ,SAASgD,KAAI,SAACrC,EAAYoB,GAC7C,OAAO,EAAKyS,iBACVjL,EACArG,EACA,EACAnB,EACApB,MAGH4I,EAAoBpJ,WAAWT,MAAM,GAAI,GAAGsD,KAAI,SAACrC,EAAYoB,GAC5D,IAAI0S,EACFlL,EAAoBvJ,SAASpB,QAC5B,EAAK1C,MAAMM,MAAM4I,oBACd,EAAKlJ,MAAMM,MAAM6I,iBACjBkE,EAAoB7I,SAC1B,OAAO,EAAK8T,iBACVjL,EACArG,EACAuR,EACA1S,EACApB,S,uCAQR4I,EACArG,EACAoR,EACAvS,EACApB,GAEA,IAAMsI,EAAgBpL,KAAKwL,WACzBE,EACArG,EACAoR,EACAvS,GALF,EAOgD6M,EAC9CjO,EACA9C,KAAKuD,MAAMqP,gBACX5S,KAAKuD,MAAM0N,cAVb,mBAOO4F,EAPP,KAOmBC,EAPnB,KAOiCC,EAPjC,KAYA,OACE,kBAAC,EAAD,CACEpY,MAAOqB,KAAK3B,MAAMM,MAClBuE,IAAK,YAAcmC,EAAInB,EACvBF,KAAMlB,EACNxE,UAAW0B,KAAKuD,MAAMjF,UACtB6C,EAAGiK,EACH7G,aAAcvE,KAAK3B,MAAMM,MAAM4F,aAC/Bb,MAAO1D,KAAK3B,MAAMM,MAAM+H,gBACxBlD,MAAOqT,EACPrO,QAASsO,EACTrO,OAAQsO,EACR7O,sBAAuBlI,KAAKkI,sBAC5BrB,uBAAwB7G,KAAK6G,2B,iCAKxBoC,GAAO,IAAD,EACoB8H,EACjC9H,EAAKnG,WACL9C,KAAKuD,MAAMqP,gBACX5S,KAAKuD,MAAM0N,cAJE,mBACR4F,EADQ,KACIC,EADJ,KAOf,OACE,kBAAC,EAAD,CACEnY,MAAOqB,KAAK3B,MAAMM,MAClBuE,IAAK,QAAU+F,EAAKnG,WAAWI,IAC/B+F,KAAMA,EACNzF,MAAOqT,EACPrO,QAASsO,EACT5O,sBAAuBlI,KAAKkI,sBAC5ByB,mBAAoB3J,KAAK2J,uB,wCAoEZ,IAAD,OAGhB,GAFA1K,QAAQC,IAAI,oBAERc,KAAK3B,MAAMM,MAAMuU,QAIrB,OAAOlT,KAAKuL,UAAUhN,WAAW4G,KAAI,SAACuG,EAAqBrG,GACzD,OACE,kBAAC,IAAM0K,SAAP,CAAgB7M,IAAK,IAAMmC,GACxB,EAAK2R,gBAAgBtL,EAAqBrG,EAAG,EAAK9B,MAAMjF,iB,0CAM5C,IAAD,OAClB,IAAI0B,KAAK3B,MAAMM,MAAMuU,QAIrB,OAAOlT,KAAK8L,oBAAoB3G,KAAI,SAACiH,EAAQ/G,GAC3C,OAAO,EAAK4R,WAAW7K,Q,uCAKzB,GAAIpM,KAAK3B,MAAMM,MAAMuU,QACnB,OACE,kBAAC,OAAD,CACEzP,EAAG,IACHyT,SAAU,GACVxT,MAAO,IACPc,MAAM,SACNnE,KAAK,iB,+BASX,OAFApB,QAAQC,IAAI,gBAGV,oCACE,yBACE+N,MAAO,CACLoF,SAAU,SACV3F,IAAK,EACLS,OAAQ,IACRD,WAAY,QAIZxJ,MAAO1D,KAAKuD,MAAMgQ,YAAc,GAGhC4D,SAAU,SAGZ,kBAAC,EAAD,CAAexY,MAAOqB,KAAK3B,MAAMM,MAAO4M,UAAWvL,KAAKuL,YAExD,kBAAC,QAAD,CACEpK,EAAGnB,KAAK3B,MAAMM,MAAMyY,WACpB3T,EAAGzD,KAAK3B,MAAM2I,UACdtD,MAAO1D,KAAKuD,MAAMgQ,YAAc,GAChC5P,OAAQ3D,KAAK3B,MAAMM,MAAMqI,WAEzB,kBAAC,QAAD,CAAOqQ,IAAKrX,KAAK6R,WACd7R,KAAKsX,oBACLtX,KAAKiT,gCAKZ,kBAAC,QAAD,CACE9R,EAAGnB,KAAK3B,MAAMM,MAAMyY,WACpB3T,GAAIzD,KAAK3B,MAAMM,MAAMqI,UACrBtD,MAAO1D,KAAKuD,MAAMgQ,YAAc,GAChC5P,OACE3D,KAAKqT,sBAAwBrT,KAAK3B,MAAMM,MAAMoJ,kBAGhD,kBAAC,QAAD,CAAOsP,IAAKrX,KAAK2R,UACd3R,KAAKuX,iBACLvX,KAAKwX,oBAIV,kBAAC,EAAD,CAAmB7Y,MAAOqB,KAAK3B,MAAMM,a,GAvqB3BgD,aCTE6U,QACW,cAA7BiB,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,WCdAC,EAAQC,QAAMC,MAAM,CACxBC,KAAMF,QAAMG,OACZlD,MAAO+C,QAAMI,UAAUJ,QAAMG,QAC7B5W,UAAWyW,QAAMK,QACjBjW,SAAU4V,QAAMK,QAChBC,gBAAiBN,QAAMK,QACvBE,WAAYP,QAAMK,UAEdG,GAAYR,QAAMC,MAAM,CAC5BQ,UAAWT,QAAMK,QACjBjW,SAAU4V,QAAMK,QAChBvD,MAAOkD,QAAMU,MAAMX,KAEfY,GAAaX,QAAMI,UACvBJ,QAAMC,MAAM,CACVjY,aAAc,GACd4Y,iBAAkBZ,QAAMK,QACxBpE,YAAa+D,QAAM3S,IAAImT,OAGrBK,GAAab,QAAMC,MAAM,aAAc,CAC3CnK,KAAMkK,QAAMG,OACZpK,OAAQiK,QAAMK,UAkOHxZ,GA9NDmZ,QACTC,MAAM,CACLjE,WAAY2E,GACZtP,YAAa2O,QAAMc,SAASd,QAAMU,MAAMV,QAAMK,SAAU,CAAC,EAAG,MAC5DvR,wBAAwB,EACxBW,qBAAqB,EACrBC,iBAAkB,EAClBH,cAAc,EACdX,gBAAiB,GACjBnC,aAAc,GACd6S,WAAY,EACZpQ,UAAW,IACX4L,gBAAiB,EACjBiG,uBAAwB,IACxBzL,mBAAoB,GAEpBxO,SAAU,aAEVgQ,oBAAqBkJ,QAAMc,SAASd,QAAMU,MAAMV,QAAMG,QAAS,CAAC,MAChEtJ,uBAAwB,EACxB3N,UAAW8W,QAAMc,SAASd,QAAMU,MAAMV,QAAMG,QAAS,IACrDnZ,eAAgBgZ,QAAMc,SAASd,QAAMU,MAAMV,QAAMG,QAAS,IAE1DnX,gBAAiBgX,QAAMc,SAASd,QAAMU,MAAMV,QAAMG,QAAS,IAC3D7E,eAAgB,EAEhBzF,WAAYmK,QAAMc,SAASD,GAAY,CAAE/K,KAAM,OAAQC,OAAQ,IAC/DE,uBAAwB,6BACxBhG,iBAAkB,GAClB+Q,mBAAoB,EAEpBpC,aAAc,EACdxD,SAAS,IAEV6F,SAAQ,SAACC,GAoGR,SAAStY,IACP,OAAOsY,EAAK7P,YAAY,GAE1B,SAASxI,IACP,OAAOqY,EAAK7P,YAAY,GA4C1B,MAAO,CACL1J,cApJF,SAAuBD,GACrBP,QAAQC,IAAI,uCACZD,QAAQC,IAAI,8BAA+BM,GAC3CwZ,EAAKlF,WAAatU,GAkJlBkO,kBAhJF,SAA2BuL,EAAUC,GACnCja,QAAQC,IAAI,uBAAyB+Z,EAAW,MAAQC,GAGxDD,EAAWzP,KAAKE,IAAI,EAAGF,KAAKyL,MAAMgE,IAClCC,EAAS1P,KAAKE,IAAI,EAAGF,KAAKyL,MAAMiE,IAChC,IAmHsB9P,EAAaC,EAnH7BzI,EAAWF,IACXG,EAASF,IACXuY,IAAWrY,IAGbqY,EAASD,GADEpY,EAASD,IAGlBsY,EAASD,IAEXA,EAAWC,EAAS,GAElBD,IAAarY,GAwGKwI,EAvGL6P,EAuGkB5P,EAvGR6P,EAwG3BF,EAAK7P,YAAc,CAACC,EAAaC,GAvG/BpK,QAAQC,IAAI,0BAA4B+Z,EAAW,IAAMC,IAEzDF,EAAK7P,YAAY,GAAK+P,GA4HxB9C,gBAzHF,SAAyB+C,GACnBrQ,OAAOC,SAASoQ,IAAiBrQ,OAAOsQ,cAAcD,KACxDH,EAAKhS,UAAYmS,EAAe,KAwHlCE,sBAjHF,SAA+B1G,GAC7BqG,EAAKpG,gBAAkBD,GAiHvBpM,gBA/GF,SAAyB+S,GACvBN,EAAKH,uBAAyBrP,KAAKE,IACjCsP,EAAKH,uBACLS,IA6GFC,iBA1GF,WACEP,EAAKH,uBAAyB,GA0G9BxU,yBAxGF,SAAkCmV,GAChCR,EAAK5L,mBAAqBhK,OAAOoW,IAwGjCC,uBAzHF,SAAgCvQ,GAC9B,IAAIwQ,EAAYxQ,EAAMmF,OAAOC,MAC7B0K,EAAKxR,iBAAmBgC,KAAKE,IAAI,EAAGZ,OAAO4Q,KAwH3CtJ,6BAvGF,WACE4I,EAAKpS,wBAA0BoS,EAAKpS,wBAuGpC4J,0BArGF,WACEwI,EAAKzR,qBAAuByR,EAAKzR,qBAqGjC+I,mBAnGF,WACE0I,EAAK3R,cAAgB2R,EAAK3R,cAmG1B2I,aAjGF,SAAsB9G,GACpB8P,EAAKzU,aAAeiF,KAAKE,IAAI,EAAGZ,OAAOI,EAAMmF,OAAOC,SAiGpD2B,YA/FF,SAAqB/G,GACnB8P,EAAKtS,gBAAkBoC,OAAOI,EAAMmF,OAAOC,QA+F3CY,YA5FF,SAAqBhG,GAGf5L,EADF8B,iIAA8B8J,EAAMmF,OAAOC,MAAQ,oBAEnDrP,QAAQC,IAAI,4BAA8BgK,EAAMmF,OAAOC,OACvD0K,EAAKpa,SAAWsK,EAAMmF,OAAOC,QAyF/BiH,gBApFF,SAAyBoE,GACvB,OAAKlJ,EAAYkJ,EAAaX,EAAKhY,aACjC/B,QAAQC,IAAI,iCAAmCya,GAC/CX,EAAKhY,UAAY2Y,EACjBX,EAAKlY,gBAAkB,IAEhB,IA+ETwU,qBA3EF,SAA8BqE,GACvBlJ,EAAYkJ,EAAaX,EAAKla,kBACjCG,QAAQC,IAAI,4CAA8Cya,GAC1DX,EAAKla,eAAiB6a,IAyExB/X,kBAtEF,SAA2BgY,GACzB3a,QAAQC,IAAI,sBAAwB0a,GACpCZ,EAAKlY,gBAAgBL,KAAKmZ,IAsE1BlZ,cACAC,YACAiP,iBAxCF,SAA0BhC,EAAMC,GAE5BA,EADEA,EACOK,SAASL,GAET,EAEXmL,EAAKrL,WAAa,CAAEC,KAAMA,EAAMC,OAAQA,IAmCxCzM,gBAjCF,SAAyBD,GACvB6X,EAAKtC,aAAevV,GAiCpBG,iBA/BF,SAA0BH,GACxB6X,EAAK5F,cAAgBjS,GAoCrBiN,YAtEF,WAEE,OAAOtF,OAAOkQ,EAAK7E,yBAqEnBA,qBAnEF,WAEE,IAAIpW,EAAIib,EAAKpK,oBAAoBoK,EAAKrK,wBACtC,OAAO5Q,GAAQ,KAiEf0Q,0BA/DF,SAAmCjN,GACjCwX,EAAKrK,uBAAyBnN,GA+D9ByS,uBA5DF,SAAgCrF,GAC9B,IAAI3J,EAAG,YAAO2J,GAEdoK,EAAKpK,oBAAsB3J,GA2D3B6Q,WAtCF,SAAoB1Q,GAClB4T,EAAK9F,QAAU9N,OAwClByU,OAAM,SAACb,GAAD,MAAW,MAEWc,OAAO,ICrPtCC,IAASpG,OAAO,kBAAC,EAAD,CAAKhV,MAAOA,KAAWuT,SAASC,eAAe,SF0HzD,kBAAmB6H,WACrBA,UAAUC,cAAcC,MAAM5a,MAAK,SAAC6a,GAClCA,EAAaC,iB","file":"static/js/main.500e446f.chunk.js","sourcesContent":["/// a collection of functions to deal with URL requests\n\nexport function urlExists(dataName) {\n  if (dataName === \"\") {\n    return false;\n  } else {\n    //source: https://stackoverflow.com/a/22011478/3067894\n    var http = new XMLHttpRequest();\n    http.open(\"HEAD\", dataName, false);\n    http.send();\n    return http.status !== 404;\n  }\n}\n\nexport async function httpGetAsync(theUrl, callback) {\n  var xmlHttp = new XMLHttpRequest();\n  xmlHttp.onreadystatechange = function () {\n    if (xmlHttp.readyState === 4 && xmlHttp.status === 200)\n      callback(xmlHttp.responseText);\n  };\n  await xmlHttp.open(\"GET\", theUrl, true); // true for asynchronous\n  xmlHttp.send(null);\n}\n","import React from \"react\";\nimport { observe } from \"mobx\";\nimport { urlExists } from \"./URL\";\n\nclass PangenomeSchematic extends React.Component {\n  constructor(props) {\n    /*Only plain objects will be made observable. For non-plain objects it is considered the\n\t\t responsibility of the constructor to initialize the observable properties. Either use\n\t\t the @observable annotation or the extendObservable function.*/\n\n    super(props);\n    this.pathNames = [];\n    this.components = [];\n    this.jsonCache = {}; // URL keys, values are entire JSON file datas\n    // TODO: make jsonCache store React components and save them in mobx\n    // TODO: make FILO queue to remove old jsonCache once we hit max memory usage\n    this.nucleotides = []; // nucleotides attribute and its edges\n\n    this.loadIndexFile(this.props.store.jsonName); //initializes this.chunkIndex\n\n    //STEP #1: whenever jsonName changes, loadIndexFile\n    observe(this.props.store, \"jsonName\", () => {\n      this.loadIndexFile(this.props.store.jsonName);\n    });\n\n    // The FASTA files are read only when there are new chunks to read\n    observe(this.props.store.chunkFastaURLs, () => {\n      this.loadFasta();\n    });\n\n    //STEP #7: JsonCache causes processArray to update chunksProcessed\n    // observe(this.props.store.jsonCache,\n    //     this.processArray.bind(this));\n\n    // console.log(\"public \", process.env.PUBLIC_URL ) //PUBLIC_URL is empty\n  }\n  componentDidUpdate() {\n    // console.log(\"#components: \" + this.components);\n  }\n\n  loadIndexFile(jsonFilename) {\n    console.log(\"STEP #1: whenever jsonName changes, loadIndexFile\");\n\n    let indexPath =\n      process.env.REACT_APP_FETCH + jsonFilename + \"/bin2file.json\";\n    console.log(\"loadIndexFile - START reading\", indexPath);\n    return fetch(indexPath)\n      .then((res) => res.json())\n      .then((json) => {\n        console.log(\"loadIndexFile - END reading\", indexPath);\n\n        //STEP #2: chunkIndex contents loaded\n        this.props.store.setChunkIndex(json);\n      });\n  }\n\n  jsonFetch(filepath) {\n    if (!filepath)\n      throw new Error(\n        \"No filepath given. Ensure chunknames in bin2file.json are correct.\"\n      );\n    console.log(\"Fetching\", filepath);\n    return fetch(filepath).then((res) => res.json());\n  }\n\n  loadJsonCache(url, data) {\n    console.log(\"STEP #6: fetched chunks go into loadJsonCache\");\n\n    if (data.json_version !== 14) {\n      throw MediaError(\n        \"Wrong Data JSON version: was expecting version 14, got \" +\n        data.json_version +\n        \".  \" +\n        \"This version added precaculated X values.  \" + // KEEP THIS UP TO DATE!\n          \"Using a mismatched data file and renderer will cause unpredictable behavior,\" +\n          \" instead generate a new data file using github.com/graph-genome/component_segmentation.\"\n      );\n    }\n    this.jsonCache[url] = data;\n    this.pathNames = data.path_names; //TODO: in later JSON versions path_names gets moved to bin2file.json\n    this.processArray();\n  }\n\n  loadFasta() {\n    console.log(\"loadFasta\");\n\n    // Clear the nucleotides information\n    this.nucleotides = [];\n\n    // This loop will automatically cap out at the fasta file corrisponding to the last loaded chunk\n    for (let path_fasta of this.props.store.chunkFastaURLs) {\n      if (urlExists(path_fasta)) {\n        console.log(\"loadFasta - START: \", path_fasta);\n\n        fetch(path_fasta)\n          .then((response) => {\n            return response.text();\n          })\n          .then((text) => {\n            const sequence = text\n              .replace(/.*/, \"\")\n              .substr(1)\n              .replace(/[\\r\\n]+/gm, \"\");\n\n            //split into array of nucleotides\n            this.nucleotides.push(...sequence);\n\n            console.log(\"loadFasta - END: \", path_fasta);\n          });\n      }\n    }\n  }\n\n  /**Parses beginBin to endBin range, returns false if new file needed.\n   * This calculates the pre-render for all contiguous JSON data.\n   * State information is stored in store.chunksProcessed.\n   * Checks if there's new available data to pre-render in processArray()\n   * run through list of urls in order and see if we have data to load.**/\n  processArray() {\n    //TODO: make processArray parallelized by placing outputs in a Key Map and rendering out of order\n    console.log(\n      \"STEP #7: JsonCache causes processArray to update chunksProcessed\"\n    );\n    let store = this.props.store;\n    let [beginBin, endBin] = [store.getBeginBin(), store.getEndBin()];\n\n    if (\n      store.chunksProcessed.length === 0 ||\n      store.chunksProcessed[0] !== this.props.store.chunkURLs[0]\n    ) {\n      this.components = []; // clear all pre-render data\n    }\n    // may have additional chunks to pre-render\n    console.log(\"processArray - parsing components \", beginBin, \" - \", endBin);\n\n    for (let urlIndex = 0; urlIndex < store.chunkURLs.length; urlIndex++) {\n      //if end of pre-render is earlier than end of contiguous available chunks, process new data\n      if (urlIndex >= store.chunksProcessed.length) {\n        //only process if data is available\n        if (store.chunkURLs[urlIndex] in this.jsonCache) {\n          let url = store.chunkURLs[urlIndex];\n          let jsonChunk = this.jsonCache[url];\n\n          console.log(\n            \"processArray - jsonChunk.components[0].x: \" +\n              jsonChunk.components[0].x\n          );\n          if (urlIndex === 0) {\n            // first component in the render\n            store.setBeginColumnX(jsonChunk.components[0].x);\n            console.log(\n              \"processArray - jsonChunk.first_bin: \" + jsonChunk.first_bin\n            );\n            store.setChunkBeginBin(jsonChunk.first_bin);\n          }\n\n          for (let [index, component] of jsonChunk.components.entries()) {\n            if (component.first_bin > 0) {\n              let componentItem = new Component(component, index);\n              this.components.push(componentItem); //TODO: concurrent modification?\n              //if (component.last_bin >= beginBin) { NOTE: we are now reading in whole chunk, this may place\n              //xOffset further right than it was intended when beginBin > chunk.first_bin\n            }\n          }\n          store.addChunkProcessed(url);\n        } else {\n          //we've run into a contiguous chunk that is not available yet\n          return false;\n        }\n      }\n    }\n\n    console.log(\n      \"processArray\",\n      store.chunksProcessed[0],\n      store.chunksProcessed.slice(-1)[0],\n      \"out of\",\n      this.props.store.chunkURLs.length,\n      \"chunks\"\n    );\n    //console.log(this.props)\n\n    return true; //store.chunksProcessed.length > 0;\n  }\n}\n\nclass Component {\n  //extends React.Component{\n  constructor(component, index) {\n    this.columnX = component.x;\n    this.index = index;\n    this.firstBin = component.first_bin;\n    this.lastBin = component.last_bin;\n    this.arrivals = [];\n    for (let arrival of component.arrivals) {\n      this.arrivals.push(new LinkColumn(arrival));\n    }\n    this.departures = [];\n    for (let departure of component.departures) {\n      //don't slice off adjacent here\n      this.departures.push(new LinkColumn(departure));\n    }\n    // we do not know the x val for this component, yet\n    this.relativePixelX = component.x;\n    // deep copy of occupants\n    this.occupants = Array.from(component.occupants);\n    this.matrix = Array.from(component.matrix);\n    this.num_bin = this.lastBin - this.firstBin + 1;\n  }\n}\n\nclass LinkColumn {\n  constructor(linkColumn) {\n    this.upstream = linkColumn.upstream;\n    this.downstream = linkColumn.downstream;\n    this.participants = linkColumn.participants; //new Set\n    this.key = this.edgeToKey();\n  }\n  edgeToKey() {\n    /**downstream and upstream are always in the same orientation regardless of if it is a\n     * departing LinkColumn or an arriving LinkColumn.**/\n    return (\n      String(this.downstream).padStart(13, \"0\") +\n      String(this.upstream).padStart(13, \"0\")\n    );\n  }\n}\n\nexport default PangenomeSchematic;\n","import React from \"react\";\nimport { Rect, Text } from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nexport class ConnectorRect extends React.Component {\n  state = {\n    color: this.props.color,\n  };\n\n  render() {\n    return (\n      <Rect\n        x={this.props.x}\n        y={this.props.y}\n        width={this.props.width}\n        height={this.props.height || 1}\n        fill={this.state.color}\n      />\n    );\n  }\n}\n\nConnectorRect.propTypes = {\n  x: PropTypes.number,\n  y: PropTypes.number,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  store: PropTypes.node,\n  color: PropTypes.node,\n};\n\nexport class MatrixCell extends React.Component {\n  onHover() {\n    //tooltip: this.props.item.mean_pos\n\n    // An example: Path_name, Coverage: 0.23, Inversion: 0.0, Pos: 2365-27289\n\n    let tooltipContent = '\"';\n    tooltipContent +=\n      this.props.pathName +\n      '\"\\nCoverage: ' +\n      this.props.item[0] +\n      \"\\nInversion: \" +\n      this.props.item[1] +\n      \"\\nPos: \";\n\n    const ranges = this.props.item[2];\n    for (let j = 0; j < ranges.length; j++) {\n      let start = ranges[j][0];\n      let end = ranges[j][1];\n      if (j === 0) {\n        tooltipContent += start + \"-\" + end;\n      } else {\n        tooltipContent += \",\" + start + \"-\" + end;\n      }\n    }\n    this.props.store.updateCellTooltipContent(tooltipContent); //item[2] is array of ranges\n  }\n\n  onLeave() {\n    this.props.store.updateCellTooltipContent(\"\"); // we don't want any tooltip displayed if we leave the cell\n  }\n\n  /**Reduced number of Text elements generated for inversions,\n   * mouse events restored**/\n  inversionText(inverted) {\n    if (this.props.store.pixelsPerRow > 9 && inverted) {\n      return (\n        <Text\n          x={this.props.x}\n          y={this.props.y}\n          width={this.props.width}\n          height={this.props.height || 1}\n          align={\"center\"}\n          verticalAlign={\"center\"}\n          text={inverted ? \"<\" : \" \"}\n          onMouseEnter={this.onHover.bind(this)}\n          onMouseLeave={this.onLeave.bind(this)}\n        />\n      );\n    } else {\n      return null;\n    }\n  }\n  render() {\n    const inverted = this.props.item[1] > 0.5;\n\n    let color = \"#838383\";\n\n    if (inverted) {\n      color = \"#DE4B39\";\n    }\n\n    if (this.props.item[0] > 1) {\n      color = \"#6A6A6A\";\n    }\n\n    // TODO: if possible, use HTML/CSS to write the '<', avoiding the <Text />s rendering, therefore improving the performance\n    return (\n      <>\n        <Rect\n          x={this.props.x}\n          y={this.props.y}\n          width={this.props.width}\n          height={this.props.height || 1}\n          fill={color}\n          onMouseEnter={this.onHover.bind(this)}\n          onMouseLeave={this.onLeave.bind(this)}\n        ></Rect>\n        {this.inversionText(inverted)}\n      </>\n    );\n  }\n}\n\nMatrixCell.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.node,\n  x: PropTypes.number,\n  y: PropTypes.number,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  color: PropTypes.node,\n  pathName: PropTypes.node,\n};\n","/* eslint-disable require-jsdoc */\nimport React from \"react\";\nimport { Rect } from \"react-konva\";\nimport { MatrixCell, ConnectorRect } from \"./ComponentConnectorRect\";\nimport PropTypes from \"prop-types\";\n\nconst zip = (arr, ...arrs) => {\n  /*Credit: https://gist.github.com/renaudtertrais/25fc5a2e64fe5d0e86894094c6989e10*/\n  return arr.map((val, i) => arrs.reduce((a, arr) => [...a, arr[i]], [val]));\n};\n\nexport function compress_visible_rows(components) {\n  /*Returns a Map with key of the original row number and value of the new, compressed row number.\n   * Use this for y values of occupancy and LinkColumn cells.  */\n  let rows_present = find_rows_visible_in_viewport(components);\n  let row_mapping = {};\n  let rows_encountered = 0;\n  for (let i = 0; i < rows_present.length; i++) {\n    if (rows_present[i]) {\n      row_mapping[i] = rows_encountered;\n      rows_encountered++;\n    }\n  }\n  return row_mapping;\n}\n\nfunction find_rows_visible_in_viewport(components) {\n  /*The only components passed to this method are the components on the screen.\n   * This returns a boolean list of which rows are on the screen. */\n  // let rows_present = new Array(components[0].occupants.length).fill(false);\n  if (components.length) {\n    let per_row = zip(...components.map((x) => x.occupants));\n    let rows_present = per_row.map((row) => row.some((x) => x));\n    return rows_present;\n  } else {\n    return [false];\n  }\n}\n\nfunction sum(a, b) {\n  return a + b;\n}\n\nclass ComponentRect extends React.Component {\n  state = {\n    color: \"lightgray\",\n  };\n\n  handleClick = () => {\n    if (this.state.color === \"lightgray\") {\n      this.setState({ color: \"lightblue\" });\n    } else if (this.state.color === \"lightblue\") {\n      this.setState({ color: \"lightgray\" });\n    }\n  };\n\n  renderMatrix() {\n    let count = 0;\n    let parts = this.props.item.matrix.map((row, row_n) => {\n      if (row.length) {\n        count++;\n        return this.renderMatrixRow(row, count, row_n);\n      } else {\n        return null;\n      }\n    });\n    this.props.store.updateMaxHeight(count); //Set max observed occupants in mobx store for render height\n    return <>{parts}</>;\n  }\n\n  renderMatrixRow(row, count, row_n) {\n    const parent = this.props.item;\n    const x_val =\n      parent.relativePixelX +\n      parent.arrivals.length * this.props.store.pixelsPerColumn;\n    const width = 1 * this.props.store.pixelsPerColumn;\n    let this_y = count;\n    if (!this.props.store.useVerticalCompression) {\n      if (!this.props.compressed_row_mapping.hasOwnProperty(row_n)) {\n        return null; // we need compressed_y and we don't have it.  give up\n      }\n      this_y = this.props.compressed_row_mapping[row_n];\n    }\n\n    return row.map((cell, x) => {\n      if (cell.length) {\n        return (\n          <>\n            <MatrixCell\n              key={\"occupant\" + row_n + x}\n              item={cell}\n              store={this.props.store}\n              pathName={this.props.pathNames[row_n]}\n              x={x_val + x * this.props.store.pixelsPerColumn}\n              y={\n                this_y * this.props.store.pixelsPerRow +\n                this.props.store.topOffset\n              }\n              row_number={row_n}\n              width={width}\n              height={this.props.store.pixelsPerRow}\n            />\n          </>\n        );\n      } else {\n        return null;\n      }\n    });\n  }\n\n  renderAllConnectors() {\n    const departures = this.props.item.departures;\n    let connectorsColumn = departures.slice(-1)[0];\n    if (connectorsColumn !== undefined) {\n      //count starts at the sum(sum(departure columns)) so that it's clear\n      // adjacent connectors are alternatives to LinkColumns\n      let count = 0;\n      if (departures.length > 1) {\n        count += departures\n          .slice(0, -1)\n          .map((column) => {\n            return column.participants.reduce(sum);\n          })\n          .reduce(sum); // sum of trues in all columns\n      }\n      return (\n        <>\n          {connectorsColumn.participants.map((useConnector, j) => {\n            if (useConnector) {\n              count++;\n              return this.renderComponentConnector(useConnector, count, j);\n            } else {\n              return null;\n            }\n          })}\n        </>\n      );\n    } else {\n      return null;\n    }\n  }\n  renderComponentConnector(useConnector, count, j) {\n    let component = this.props.item;\n    // x is the (num_bins + num_arrivals + num_departures)*pixelsPerColumn\n    const x_val =\n      component.relativePixelX +\n      (component.arrivals.length +\n        (this.props.store.useWidthCompression\n          ? this.props.store.binScalingFactor\n          : component.num_bin) +\n        component.departures.length -\n        1) *\n        this.props.store.pixelsPerColumn;\n    let this_y = count;\n    if (!this.props.store.useVerticalCompression) {\n      this_y = this.props.compressed_row_mapping[j];\n    }\n    return (\n      <ConnectorRect\n        key={\"connector\" + j}\n        x={x_val}\n        y={this.props.store.topOffset + this_y * this.props.store.pixelsPerRow}\n        width={this.props.store.pixelsPerColumn} //Clarified and corrected adjacent connectors as based on pixelsPerColumn width #9\n        height={this.props.store.pixelsPerRow}\n        color={\"#464646\"}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <>\n        <Rect\n          x={this.props.item.relativePixelX}\n          y={this.props.store.topOffset}\n          key={this.state.key + \"R\"}\n          width={this.props.widthInColumns * this.props.store.pixelsPerColumn}\n          height={this.props.height - 2} //TODO: change to compressed height\n          fill={this.state.color}\n          onClick={this.handleClick}\n        />\n        {!this.props.store.useWidthCompression ? this.renderMatrix() : null}\n        {this.props.store.useConnector ? this.renderAllConnectors() : null}\n      </>\n    );\n  }\n}\n\nComponentRect.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.object,\n  compressed_row_mapping: PropTypes.object,\n  widthInColumns: PropTypes.number,\n  height: PropTypes.number,\n  pathNames: PropTypes.node,\n};\n\nexport default ComponentRect;\n","import React from \"react\";\nimport { Text } from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nclass ComponentNucleotides extends React.Component {\n  renderMatrixRow() {\n    const parent = this.props.item;\n    const x_val =\n      parent.relativePixelX +\n      parent.arrivals.length * this.props.store.pixelsPerColumn;\n\n    //console.log('x_val: ' + x_val)\n\n    var listOfObjects = [];\n    for (var x = 0; x < this.props.item.num_bin; x++) {\n      listOfObjects.push(\n        <Text\n          key={\"nuc_text\" + x}\n          x={x_val + x * this.props.store.pixelsPerColumn}\n          y={this.props.store.topOffset - this.props.store.nucleotideHeight}\n          text={this.props.nucleotides[x]}\n          align=\"center\"\n          height={this.props.store.nucleotideHeight}\n          width={this.props.store.pixelsPerColumn}\n        />\n      );\n    }\n    return listOfObjects;\n  }\n\n  render() {\n    //console.log('ComponentNucleotides - render')\n    return this.renderMatrixRow();\n  }\n}\n\nComponentNucleotides.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.object,\n  width: PropTypes.node,\n  height: PropTypes.node,\n};\n\nexport default ComponentNucleotides;\n","import React from \"react\";\nimport { Rect } from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nclass LinkColumn extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseOut = this.handleMouseOut.bind(this);\n    this.handleMouseOver = this.handleMouseOver.bind(this);\n  }\n  handleMouseOver() {\n    this.props.updateHighlightedNode(this.props.item);\n  }\n  handleMouseOut() {\n    this.props.updateHighlightedNode(null);\n  }\n  linkCells() {\n    let alpha = [];\n    let count = 1; // Link columns appear to be 1 higher than occupants and conncetors\n    for (const [i, isPresent] of this.props.item.participants.entries()) {\n      if (isPresent) {\n        let this_y = count++;\n        if (!this.props.store.useVerticalCompression) {\n          if (!this.props.compressed_row_mapping.hasOwnProperty(i)) {\n            continue; //we're stuck: we need row_mapping but it's not present\n          }\n          this_y = this.props.compressed_row_mapping[i];\n        }\n        let row = this_y * this.props.store.pixelsPerRow;\n        alpha.push(row); //relative compressed Y coordinate\n      }\n    }\n    return alpha;\n  }\n  componentDidMount() {\n    this.setState({\n      color: this.props.color,\n    });\n  }\n  render() {\n    const contents = this.linkCells();\n    return (\n      <>\n        {contents.map((y_coord, d) => {\n          return (\n            <Rect\n              key={\"dot\" + d}\n              x={this.props.x}\n              y={\n                this.props.store.topOffset +\n                y_coord\n              }\n              width={this.props.store.pixelsPerColumn}\n              height={this.props.store.pixelsPerRow}\n              fill={this.props.color}\n              opacity={this.props.opacity}\n              stroke={this.props.stroke}\n              // onClick={this.handleClick}\n              onMouseOver={this.handleMouseOver}\n              onMouseOut={this.handleMouseOut}\n            />\n          );\n        })}\n      </>\n    );\n  }\n}\n\nLinkColumn.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.object,\n  updateHighlightedNode: PropTypes.func,\n  compressed_row_mapping: PropTypes.object,\n  x: PropTypes.node,\n  column: PropTypes.node,\n  color: PropTypes.node,\n};\n\nexport default LinkColumn;\n","import React from \"react\";\nimport { Arrow } from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nfunction isInfinity(n) {\n  return !Number.isFinite(n);\n}\n\nclass LinkArrow extends React.Component {\n  /** Serves as a contract to store visual layout information**/\n  constructor(props) {\n    super(props);\n    this.arrowXCoord = null;\n    this.points = [];\n    this.handleMouseOut = this.handleMouseOut.bind(this);\n    this.handleMouseOver = this.handleMouseOver.bind(this);\n  }\n  componentDidUpdate() {\n    //this.calculatePoints(); // AG: is it necessary?\n  }\n\n  calculatePoints() {\n    /*Translates the LinkRecord coordinates into pixels and defines the curve shape.\n     * I've spent way too long fiddling with these numbers at different pixelsPerColumn\n     * I suggest you don't fiddle with them unless you plan on nesting the React\n     * Components to ensure that everything is relative coordinates.*/\n    let link = this.props.link;\n    this.arrowXCoord = this.props.link.xArrival;\n    let absDepartureX = this.props.link.xDepart;\n    // put in relative coordinates to arriving LinkColumn\n    let departureX =\n      absDepartureX - this.arrowXCoord + this.props.store.pixelsPerColumn / 2;\n    let arrX = this.props.store.pixelsPerColumn / 2;\n    let bottom = -2; //-this.props.store.pixelsPerColumn;\n    let turnDirection = departureX < 0 ? -1 : 1;\n    const departOrigin = [departureX, this.props.store.pixelsPerColumn - 2];\n    const departCorner = [departureX - turnDirection, -link.elevation + 2];\n    let departTop = [departureX - turnDirection * 6, -link.elevation];\n    let arriveTop = [arrX + turnDirection * 6, -link.elevation];\n    let arriveCorner = [arrX + turnDirection, -link.elevation + 2]; // 1.5 in from actual corner\n    const arriveCornerEnd = [arrX, -5];\n    this.points = [\n      departOrigin[0],\n      departOrigin[1],\n      departCorner[0],\n      departCorner[1],\n      departTop[0],\n      departTop[1],\n      arriveTop[0],\n      arriveTop[1],\n      arriveCorner[0],\n      arriveCorner[1],\n      arriveCornerEnd[0],\n      arriveCornerEnd[1],\n      arrX,\n      -1,\n    ];\n    if (Math.abs(departureX) <= this.props.store.pixelsPerColumn) {\n      // FIXME Small distances, usually self loops\n      if (link.isArrival) {\n        this.points = [\n          arrX,\n          -10, //-link.elevation - 4,\n          arrX,\n          bottom,\n        ];\n      } else {\n        this.points = [\n          departOrigin[0],\n          bottom + this.props.store.pixelsPerColumn,\n          departOrigin[0],\n          -5,\n        ]; //-link.elevation-this.props.store.pixelsPerColumn*2,];\n      }\n    }\n    if (this.points.some(isNaN) || this.points.some(isInfinity)) {\n      console.log(\"Some points are NaN: \" + this.points);\n    }\n  }\n\n  render() {\n    // if(this.arrowXCoord === null){\n    this.calculatePoints();\n    // }\n    /*upstream={this.props.upstream}\n        downstream={this.props.downstream}\n        */\n\n    return (\n      <Arrow\n        x={this.arrowXCoord}\n        y={this.props.store.topOffset - 10}\n        width={this.props.store.pixelsPerColumn}\n        points={this.points}\n        bezier={false}\n        strokeWidth={this.props.store.pixelsPerColumn}\n        fill={this.props.color}\n        stroke={this.props.color}\n        opacity={this.props.opacity}\n        stroke-opacity={this.props.opacity}\n        pointerLength={1}\n        pointerWidth={1}\n        tension={1 / 3}\n        onMouseOver={this.handleMouseOver}\n        onMouseOut={this.handleMouseOut}\n        onClick={this.handleClick}\n        // lineCap={'round'}\n      />\n    );\n  }\n\n  handleMouseOver = () => {\n    this.props.updateHighlightedNode(this.props.link.linkColumn);\n  };\n  handleMouseOut = () => {\n    this.props.updateHighlightedNode(null);\n  };\n  handleClick = (event) => {\n    /*Jump on Link click rough draft. Detects which end is closest to the view and\n    jumps to the other side. TODO: Still needs visual highlighting at destination.*/\n    console.log(\"Click\", event, this.props.link);\n\n    let [newBeginBin, newEndBin] = this.props.store.beginEndBin;\n\n    const [beginBin, endBin] = this.props.store.beginEndBin;\n\n    // Find middle position of viewport\n    let width = endBin - beginBin;\n    let mid_bin = beginBin + width / 2;\n\n    // Compare with ends of arrow coordinates\n    let end_closer =\n      Math.abs(this.props.link.linkColumn.upstream - mid_bin) <\n      Math.abs(this.props.link.linkColumn.downstream - mid_bin);\n\n    // Identify more distant end\n    let destination_bin = end_closer\n      ? this.props.link.linkColumn.downstream\n      : this.props.link.linkColumn.upstream;\n\n    if (!(destination_bin >= beginBin && destination_bin <= endBin)) {\n      // Calculate beginBin that will place distant end in middle of viewport\n      // The ~~ operator is a double NOT bitwise operator. It is used as a faster substitute for Math.floor().\n      newBeginBin = Math.max(1, ~~(destination_bin - width / 2));\n      newEndBin = newBeginBin + width;\n      // Called after the bin updating to start the timers after the rendering\n    }\n\n    this.props.updateSelectedLink(\n      this.props.link.linkColumn,\n      newBeginBin,\n      newEndBin\n    );\n  };\n}\n\nLinkArrow.propTypes = {\n  store: PropTypes.object,\n  link: PropTypes.object,\n  color: PropTypes.node,\n  updateHighlightedNode: PropTypes.func,\n  updateSelectedLink: PropTypes.func,\n};\n\nexport default LinkArrow;\n","export class LinkRecord {\n  constructor(linkColumn, xCoordArrival = 0, xCoordDeparture = 0, isArrival) {\n    this.linkColumn = linkColumn;\n    if (linkColumn === undefined) {\n      console.log(linkColumn, xCoordArrival, xCoordDeparture);\n    }\n    this.xArrival = xCoordArrival;\n    this.xDepart = xCoordDeparture;\n    this.elevation = 10;\n    this.isArrival = isArrival;\n  }\n  distance() {\n    return Math.abs(this.xDepart - this.xArrival) || 1;\n  }\n}\n\nexport function calculateLinkCoordinates(\n  schematic,\n  pixelsPerColumn,\n  topOffset,\n  useWidthCompression,\n  binScalingFactor,\n  leftXStart\n) {\n  //leftXStart is necessary as a method at the moment\n  /** calculate the x coordinates of all components\n   * calculate the x coordinates of all arrivals and departures */\n\n  /* In this dictionary the key is the global unique paddedKey created by @edgetoKey.\n    The value is a list of size 2:\n    1. Element: the x-coordinate of the arrival link column\n    2. Element: the x-coordinate of the corresponding departure link column */\n  let linkToXMapping = {}; //(paddedKey): [arrivalX, departureX]\n\n  for (let i = 0; i < schematic.length; i++) {\n    let schematizeComponent = schematic[i];\n    //schematizeComponent.relativePixelX = leftXStart(schematizeComponent, i, 0, 0);\n    //ARRIVALS: Calculate all X\n    for (let j = 0; j < schematizeComponent.arrivals.length; j++) {\n      let arrival = schematizeComponent.arrivals[j];\n      let xCoordArrival = leftXStart(schematizeComponent, i, 0, j);\n      let paddedKey = arrival.key;\n      if (!(paddedKey in linkToXMapping)) {\n        //place holder value, go as far right as possible\n        // TODO place holder value in the same place\n        linkToXMapping[paddedKey] = new LinkRecord(\n          arrival,\n          xCoordArrival,\n          xCoordArrival,\n          true\n        );\n      } else {\n        linkToXMapping[paddedKey].xArrival = xCoordArrival; // set with real value\n      }\n    }\n    //DEPARTURES: Calculate all X\n    for (let k = 0; k < schematizeComponent.departures.length - 1; k++) {\n      let departure = schematizeComponent.departures[k];\n      let xCoordDeparture = leftXStart(\n        schematizeComponent,\n        i,\n        schematizeComponent.arrivals.length +\n          (useWidthCompression\n            ? binScalingFactor\n            : schematizeComponent.num_bin),\n        k\n      );\n      let paddedKey = departure.key;\n      if (!(paddedKey in linkToXMapping)) {\n        //place holder value, go as far left as possible\n        // linkToXMapping[paddedKey] = [this.state.actualWidth + 100, xCoordDeparture]\n        linkToXMapping[paddedKey] = new LinkRecord(\n          departure,\n          xCoordDeparture,\n          xCoordDeparture,\n          false\n        );\n      } else {\n        linkToXMapping[paddedKey].xDepart = xCoordDeparture; // set real value\n      }\n    }\n  }\n  return calculateLinkElevations(linkToXMapping, pixelsPerColumn, topOffset);\n}\n\nfunction calculateLinkElevations(linkToXmapping, pixelsPerColumn, topOffset) {\n  /**Starting with the shortest links, claim a spot of elevation to place the link in.\n   * As the links get bigger, you take the max() of the range of the link and add 1.\n   * This claims the \"air space\" for that link to travel through without colliding with anything.\n   * The longest link should end up on top.  We'll probably need a \"link gutter\" maximum to keep\n   * this from getting unreasonably tall.**/\n  let distanceSortedLinks = Object.values(linkToXmapping).sort(\n    (a, b) => a.distance() - b.distance()\n  );\n  let elevationOccupied = reserveElevationAirSpace(\n    distanceSortedLinks,\n    pixelsPerColumn,\n    topOffset\n  );\n  let top = Math.max(...elevationOccupied) + pixelsPerColumn * 3;\n  return [distanceSortedLinks, top];\n}\n\nfunction reserveElevationAirSpace(\n  distanceSortedLinks,\n  pixelsPerColumn,\n  topOffset\n) {\n  /* Set up an array of zeros, then gradually fill it with height stacking\n   * @Simon this section is largely done, it just needs a sorted distanceSortedLinks as input*/\n  let length = Math.max(\n    0,\n    ...distanceSortedLinks.map((x) => Math.max(x.xDepart, x.xArrival))\n  ); //this.props.endBin - this.props.beginBin;\n  let elevationOccupied = new Array(length).fill(15);\n  for (let record of distanceSortedLinks) {\n    let linkBegin = Math.max(0, Math.min(record.xArrival, record.xDepart));\n    let linkEnd = Math.max(record.xArrival, record.xDepart, linkBegin + 1);\n    let range = elevationOccupied.slice(linkBegin, linkEnd + 1);\n    let elevation = range.length ? Math.max(...range) : 10;\n    if (isNaN(elevation) || !Number.isFinite(elevation)) {\n      console.log(\n        \"Bad elevation\",\n        record,\n        linkBegin,\n        linkEnd,\n        range,\n        elevationOccupied\n      );\n    }\n    const stillSmall = true; //elevation < topOffset / 3;\n    elevation += stillSmall ? pixelsPerColumn : pixelsPerColumn / 4;\n    for (let x = linkBegin; x < linkEnd && x < elevationOccupied.length; x++) {\n      elevationOccupied[x] = elevation;\n    }\n    record.elevation = elevation; //storing final value for render\n  }\n  return elevationOccupied;\n}\n","import React from \"react\";\nimport MouseTooltip from \"react-sticky-mouse-tooltip\";\nimport { Observer } from \"mobx-react\";\nimport PropTypes from \"prop-types\";\n\nexport default class NucleotideTooltip extends React.Component {\n  render() {\n    return (\n      <MouseTooltip\n        visible={true}\n        offsetX={15}\n        offsetY={-20}\n        style={{ background: \"white\", zIndex: 4, \"white-space\": \"pre-line\" }}\n      >\n        <Observer>\n          {() => <span>{this.props.store.cellToolTipContent}</span>}\n        </Observer>\n      </MouseTooltip>\n    );\n  }\n}\n\nNucleotideTooltip.propTypes = {\n  store: PropTypes.object,\n};\n","import React from \"react\";\nimport {Observer} from \"mobx-react\";\nimport {httpGetAsync} from \"./URL\";\nimport PropTypes from \"prop-types\";\n\nclass ControlHeader extends React.Component {\n  shift(percentage) {\n    const beginBin = this.props.store.getBeginBin();\n    const endBin = this.props.store.getEndBin();\n    let size = endBin - beginBin;\n    let diff = Math.floor(size * (percentage / 100));\n    console.log(endBin + \"-\" + beginBin + \"=\" + size + \" --> diff: \" + diff);\n    this.props.store.updateBeginEndBin(beginBin + diff, endBin + diff);\n  }\n\n  handleJump() {\n    console.log(\n      \"JUMP: path name: \" +\n        this.props.store.pathNucPos.path +\n        \" nucleotide position: \" +\n        this.props.store.pathNucPos.nucPos\n    );\n    // I don't know why, but in order for the CORS headers to exchange we need to make a first GET request to \"/hi\" which will not return anything\n\n    const store = this.props.store;\n    const addr = store.pathIndexServerAddress;\n    const path_name = store.pathNucPos.path;\n    const nuc_pos = store.pathNucPos.nucPos;\n\n    function handleOdgiServerResponse(result) {\n      if (result === \"0\") {\n        alert(\n          \"The jump query returned 0. Either your path does not exist or your position in the path is wrong. Please try again.\"\n        );\n      } else {\n        console.log(result);\n        // go from nucleotide position to bin\n        result = parseInt(result);\n        const newBeginBin = Math.ceil(result / this.props.store.getBinWidth());\n        console.log(newBeginBin);\n        store.updateBeginEndBin(newBeginBin, store.getEndBin());\n      }\n    }\n    // httpGetAsync(addr + \"hi\", printResult);\n    // httpGetAsync(addr + \"5/1\", printResult);\n    // httpGetAsync(addr + \"4/3\", printResult);\n    httpGetAsync(addr + path_name + \"/\" + nuc_pos, handleOdgiServerResponse);\n  }\n\n  // AG\n  change_zoom_level(target) {\n    console.log(\n      \"change_zoom_level: \" +\n        target.value +\n        \" ---\" +\n        target.options[target.selectedIndex].text\n    );\n    this.props.store.setIndexSelectedZoomLevel(parseInt(target.value));\n  }\n\n  decIndexSelectedZoomLevel() {\n    let indexSelZoomLevel = this.props.store.indexSelectedZoomLevel;\n    if (indexSelZoomLevel > 0) {\n      this.props.store.setIndexSelectedZoomLevel(indexSelZoomLevel - 1);\n    }\n  }\n\n  incIndexSelectedZoomLevel() {\n    let indexSelZoomLevel = this.props.store.indexSelectedZoomLevel;\n    if (indexSelZoomLevel < this.props.store.availableZoomLevels.length - 1) {\n      this.props.store.setIndexSelectedZoomLevel(indexSelZoomLevel + 1);\n    }\n  }\n\n  render() {\n    return (\n      <div id=\"button-container\">\n        <button className=\"button\" id=\"btn-download\">\n          Save Image\n        </button>\n        <input\n          type=\"text\"\n          defaultValue={this.props.store.jsonName}\n          style={{ width: \"330px\" }}\n          onChange={this.props.store.tryJSONpath}\n          title={\"File:\"}\n        />\n        <span style={{ marginLeft: \"30px\" }}>\n          <Observer>\n            {() => (\n              <>\n                Bin width:\n                <button\n                  className=\"button\"\n                  onClick={() => this.decIndexSelectedZoomLevel()}\n                >\n                  -\n                </button>\n                <select\n                  id=\"select_bin_width\"\n                  onChange={(val) => this.change_zoom_level(val.target)}\n                  value={this.props.store.indexSelectedZoomLevel}\n                >\n                  {this.props.store.availableZoomLevels.map((item, i) => (\n                    <option key={i} value={i}>\n                      {item}\n                    </option>\n                  ))}\n                </select>\n                <button\n                  className=\"button\"\n                  onClick={() => this.incIndexSelectedZoomLevel()}\n                >\n                  +\n                </button>\n              </>\n            )}\n          </Observer>\n        </span>\n\n        <span style={{ marginLeft: \"30px\" }}>\n          <button className=\"button\" onClick={() => this.shift(-100)}>\n            &lt;&lt;\n          </button>\n          <button className=\"button\" onClick={() => this.shift(-50)}>\n            &lt;\n          </button>\n          Pangenome Bin Position:\n          <Observer>\n            {() => (\n              <>\n                <input\n                  type=\"number\"\n                  value={this.props.store.beginEndBin[0]} // TODO Get methods don't work here, but I don't know why. Need to ask Robert Buels.\n                  onChange={(event) =>\n                    this.props.store.updateBeginEndBin(\n                      event.target.value,\n                      this.props.store.getEndBin()\n                    )\n                  }\n                  style={{ width: \"80px\" }}\n                />\n                -\n                <input\n                  type=\"number\"\n                  value={this.props.store.beginEndBin[1]}\n                  readOnly\n                  style={{ width: \"80px\" }}\n                />\n              </>\n            )}\n          </Observer>\n          <button className=\"button\" onClick={() => this.shift(50)}>\n            &gt;\n          </button>\n          <button className=\"button\" onClick={() => this.shift(100)}>\n            &gt;&gt;\n          </button>\n        </span>\n        <div className={\"row\"}>\n          Jump to path at nucleotide position:\n          <input\n            type=\"string\"\n            list=\"path\"\n            placeholder={\"path\"}\n            onChange={(event) =>\n              this.props.store.updatePathNucPos(\n                event.target.value,\n                this.props.store.pathNucPos.nucPos\n              )\n            }\n            style={{ width: \"80px\" }}\n          />\n          <datalist id=\"path\">\n            {this.props.schematic.pathNames.map((item, key) => (\n              <option key={key} value={item} />\n            ))}\n          </datalist>\n          -\n          <input\n            type=\"number\"\n            placeholder={\"position\"}\n            onChange={(event) =>\n              this.props.store.updatePathNucPos(\n                this.props.store.getPath(),\n                event.target.value\n              )\n            }\n            style={{ width: \"80px\" }}\n          />\n          <span style={{ marginLeft: \"2px\" }}>\n            <button className=\"button\" onClick={() => this.handleJump()}>\n              Jump\n            </button>\n          </span>\n        </div>\n        <div className={\"row\"}>\n          <span>\n            {\" \"}\n            Use Vertical Compression:\n            <VerticalCompressedViewSwitch store={this.props.store} />\n          </span>\n          <span>\n            {\" \"}\n              Show Only Rearrangements:\n            <WidthCompressedViewSwitch store={this.props.store} />\n          </span>\n          {this.props.store.useWidthCompression ? (\n            <React.Fragment>\n              <span>\n                {\" \"}\n                Render Connectors:\n                <RenderConnectorSwitch store={this.props.store} />\n              </span>\n\n            </React.Fragment>\n          ) : (\n            <></>\n          )}\n          <span>\n            {\" \"}\n            Row Height:\n            <Observer>\n              {() => (\n                  <input\n                      type=\"number\"\n                      min={1}\n                      value={this.props.store.pixelsPerRow}\n                      onChange={this.props.store.updateHeight}\n                      style={{width: \"30px\"}}\n                  />)}\n            </Observer>\n          </span>\n          <span>\n            {\" \"}\n            Column Width:\n            <input\n              type=\"number\"\n              min={1}\n              value={this.props.store.pixelsPerColumn}\n              onChange={this.props.store.updateWidth}\n              style={{ width: \"30px\" }}\n            />\n          </span>\n        </div>\n      </div>\n    );\n  }\n}\n\nControlHeader.propTypes = {\n  store: PropTypes.object,\n};\n\nclass VerticalCompressedViewSwitch extends React.Component {\n  render() {\n    return (\n      <Observer>\n        {() => (\n          <input\n            type=\"checkbox\"\n            checked={this.props.store.useVerticalCompression}\n            onChange={this.props.store.toggleUseVerticalCompression}\n          />\n        )}\n      </Observer>\n    );\n  }\n}\n\nVerticalCompressedViewSwitch.propTypes = {\n  store: PropTypes.object,\n};\n\nclass RenderConnectorSwitch extends React.Component {\n  render() {\n    return (\n      <Observer>\n        {() => (\n          <input\n            type=\"checkbox\"\n            checked={this.props.store.useConnector}\n            onChange={this.props.store.toggleUseConnector}\n          />\n        )}\n      </Observer>\n    );\n  }\n}\n\nRenderConnectorSwitch.propTypes = {\n  store: PropTypes.object,\n};\n\nclass WidthCompressedViewSwitch extends React.Component {\n  render() {\n    return (\n      <Observer>\n        {() => (\n          <input\n            type=\"checkbox\"\n            checked={this.props.store.useWidthCompression}\n            onChange={this.props.store.toggleUseWidthCompression}\n          />\n        )}\n      </Observer>\n    );\n  }\n}\n\nWidthCompressedViewSwitch.propTypes = {\n  store: PropTypes.object,\n};\n\nexport default ControlHeader;\n","export function arraysEqual(A, B) {\n  return (A.length === 0 && B.length === 0) ||\n      (A.length === B.length &&\n          A.every((e) => B.indexOf(e) > -1));\n}\n\nexport function calculateEndBinFromScreen(beginBin, selZoomLev, store) {\n  let deviceWidth = 1920; // TODO: get width from browser\n  let widthInCells = deviceWidth / store.pixelsPerColumn;\n  let chunkURLarray = [];\n  let fileArrayFasta = [];\n\n  let currEnd = beginBin + 1;\n  let workingWidth = 0;\n  //this loop will automatically cap out at the last bin of the file\n  let level = store.chunkIndex.zoom_levels.get(selZoomLev);\n  for (let ichunk = 0; ichunk < level.files.length; ichunk++) {\n    // The \"x\" info is not here\n    let chunk = level.files[ichunk];\n    if (chunk.last_bin >= beginBin) {\n      let width =\n        chunk[\"last_bin\"] -\n        chunk[\"first_bin\"] +\n        chunk[\"component_count\"] +\n        chunk[\"link_count\"];\n      let columnsLeftToAdd = widthInCells - workingWidth;\n      workingWidth += width;\n      chunkURLarray.push(chunk[\"file\"]);\n      if (chunk.fasta !== null) {\n        fileArrayFasta.push(chunk.fasta);\n      }\n      if (workingWidth > widthInCells) {\n        // fractional chunk to add, could cut a Component in half\n        let density = (chunk[\"last_bin\"] - chunk[\"first_bin\"]) / width;\n        currEnd = Math.round(columnsLeftToAdd * density);\n        // currEnd = chunk[\"last_bin\"];\n        break;\n      }\n    }\n  }\n\n  // store.updateBeginEndBin(b, b + widthInCells);\n  //TODO the logic in let width = could be much more complex by looking at\n  //width of components and whether various settings are on.  The consequence\n  //of overestimating widthInCells is to make the shift buttons step too big\n  return [currEnd, chunkURLarray, fileArrayFasta];\n}\n\nexport function range(start, end) {\n  return [...Array(1 + end - start).keys()].map((v) => start + v);\n}\n\nexport function stringToColorAndOpacity(\n  linkColumn,\n  highlightedLinkColumn,\n  selectedLink\n) {\n  const whichLinkToConsider = selectedLink\n    ? selectedLink\n    : highlightedLinkColumn;\n\n  const colorKey = (linkColumn.downstream + 1) * (linkColumn.upstream + 1);\n  if (whichLinkToConsider) {\n    // When the mouse in on a Link, all the other ones will become gray and fade out\n    let matchColor =\n      (whichLinkToConsider.downstream + 1) * (whichLinkToConsider.upstream + 1);\n    // Check if the mouse in on a Link (highlightedLinkColumn) or if a Link was clicked (selectedLink)\n    if ((!highlightedLinkColumn && !selectedLink) || colorKey === matchColor) {\n      return [\n        stringToColourSave(colorKey),\n        1.0,\n        highlightedLinkColumn || selectedLink ? \"black\" : null,\n      ];\n    } else {\n      return [\"gray\", 0.3, null];\n    }\n  } else {\n    return [stringToColourSave(colorKey), 1.0, null];\n  }\n}\n\nexport function stringToColourSave(colorKey) {\n  colorKey = colorKey.toString();\n  let hash = 0;\n  for (let i = 0; i < colorKey.length; i++) {\n    hash = colorKey.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  let colour = \"#\";\n  for (let j = 0; j < 3; j++) {\n    const value = (hash >> (j * 8)) & 0xff;\n    colour += (\"00\" + value.toString(16)).substr(-2);\n  }\n  return colour;\n}\n","import { Layer, Stage, Text } from \"react-konva\";\nimport React, { Component } from \"react\";\n\nimport \"./App.css\";\nimport PangenomeSchematic from \"./PangenomeSchematic\";\nimport ComponentRect, { compress_visible_rows } from \"./ComponentRect\";\nimport ComponentNucleotides from \"./ComponentNucleotides\";\nimport LinkColumn from \"./LinkColumn\";\nimport LinkArrow from \"./LinkArrow\";\nimport { calculateLinkCoordinates } from \"./LinkRecord\";\nimport NucleotideTooltip from \"./NucleotideTooltip\";\nimport ControlHeader from \"./ControlHeader\";\nimport { observe } from \"mobx\";\nimport {\n  arraysEqual,\n  calculateEndBinFromScreen,\n  stringToColorAndOpacity,\n} from \"./utilities\";\n\nimport makeInspectable from \"mobx-devtools-mst\";\n\nclass App extends Component {\n  layerRef = React.createRef();\n  layerRef2 = React.createRef(null);\n  timerHighlightingLink = null;\n  timerSelectionLink = null;\n\n  constructor(props) {\n    super(props);\n\n    this.updateHighlightedNode = this.updateHighlightedNode.bind(this);\n    this.updateSelectedLink = this.updateSelectedLink.bind(this);\n\n    this.state = {\n      schematize: [],\n      pathNames: [],\n      actualWidth: 1,\n      buttonsHeight: 0,\n    };\n    this.schematic = new PangenomeSchematic({ store: this.props.store }); //Read file, parse nothing\n\n    /* == State control flow --> redundancies here can waste processing time\n    * STEP #1: whenever jsonName changes, loadIndexFile\n    * STEP #2: chunkIndex contents loaded\n    * STEP #3: with new chunkIndex, this.openRelevantChunksFromIndex()\n    * STEP #4: Set switchChunkURLs\n    * STEP #5: once ChunkURLs are listed, go fetchAllChunks\n    * STEP #6: fetched chunks go into loadJsonCache\n    * STEP #7: JsonCache causes processArray to update chunksProcessed\n    * STEP #8: chunksProcessed finishing triggers updateSchematicMetadata with final rendering info for this loaded chunks\n      * STEP #9: reserveAirspace\n      * STEP #10: calcMaxNumRowsAcrossComponents\n    //TODO: separate processArray into its  own observer\n    * STEP #11: Y values calculated, trigger do the render\n    * */\n\n    //Arrays must be observed directly, simple objects are observed by name\n    //STEP #5: once ChunkURLs are listed, go fetchAllChunks\n    observe(this.props.store.chunkURLs, this.fetchAllChunks.bind(this));\n\n    // observe(this.props.store, \"pixelsPerRow\", this.recalcY.bind(this));\n    observe(\n      this.props.store,\n      \"useVerticalCompression\",\n      this.updateSchematicMetadata.bind(this)\n    );\n    observe(\n      this.props.store,\n      \"useWidthCompression\",\n      this.recalcXLayout.bind(this)\n    );\n    observe(this.props.store, \"useConnector\", this.recalcXLayout.bind(this)); //TODO faster rerender\n    observe(this.props.store, \"pixelsPerColumn\", this.recalcXLayout.bind(this)); //TODO faster rerender\n    observe(this.props.store, \"pixelsPerRow\", this.recalcY.bind(this)); //TODO faster rerender\n\n    //STEP #8: chunksProcessed finishing triggers updateSchematicMetadata with final\n    // rendering info for this loaded chunks\n    observe(\n      this.props.store.chunksProcessed,\n      this.updateSchematicMetadata.bind(this)\n    );\n\n    //STEP #11: Y values calculated, trigger do the render\n    observe(this.props.store, \"loading\", this.render.bind(this));\n\n    //STEP #3: with new chunkIndex, openRelevantChunksFromIndex\n    observe(\n      this.props.store,\n      \"chunkIndex\", //TODO: this is currently not triggering on input change. No idea why\n      this.openRelevantChunksFromIndex.bind(this)\n    );\n\n    observe(\n      this.props.store,\n      \"indexSelectedZoomLevel\",\n      this.openRelevantChunksFromIndex.bind(this) // Whenever the selected zoom level changes\n    );\n    observe(\n      this.props.store.beginEndBin, //user moves start position\n      //This following part is important to scroll right and left on browser\n      this.openRelevantChunksFromIndex.bind(this)\n    );\n\n    makeInspectable(this.props.store);\n  }\n\n  /** Compares bin2file @param indexContents with the beginBin and EndBin.\n   * It finds the appropriate chunk URLS from the index and updates\n   * switchChunkURLs which trigger json fetches for the new chunks. **/\n  openRelevantChunksFromIndex() {\n    console.log(\n      \"STEP #3: with new chunkIndex, this.openRelevantChunksFromIndex()\"\n    );\n\n    if (\n      this.props.store.chunkIndex === null ||\n      !this.props.store.chunkIndex.zoom_levels.keys()\n    ) {\n      return; //before the class is fully initialized\n    }\n    const beginBin = this.props.store.getBeginBin();\n\n    // With new chunkIndex, it sets the available zoom levels\n    this.props.store.setAvailableZoomLevels(\n      this.props.store.chunkIndex[\"zoom_levels\"].keys()\n    );\n    const selZoomLev = this.props.store.getSelectedZoomLevel();\n    let [endBin, fileArray, fileArrayFasta] = calculateEndBinFromScreen(\n      beginBin,\n      selZoomLev,\n      this.props.store\n    );\n    //TODO: commented because maybe it creates problems\n    //this.props.store.updateBeginEndBin(beginBin, endBin);\n\n    console.log([selZoomLev, endBin, fileArray, fileArrayFasta]);\n    let URLprefix =\n      process.env.REACT_APP_FETCH +\n      this.props.store.jsonName +\n      \"/\" +\n      selZoomLev +\n      \"/\";\n    fileArray = fileArray.map((filename) => {\n      return URLprefix + filename;\n    });\n    fileArrayFasta = fileArrayFasta.map((filename) => {\n      return URLprefix + filename;\n    });\n\n    this.props.store.switchChunkFastaURLs(fileArrayFasta);\n\n    // If there are no new chunck, it has only to recalcualte the X layout\n    if (!this.props.store.switchChunkURLs(fileArray)) {\n      this.recalcXLayout();\n    }\n  }\n\n  fetchAllChunks() {\n    /*Dispatches fetches for all chunk files\n     * Read https://github.com/graph-genome/Schematize/issues/22 for details\n     */\n    console.log(\"STEP #5: once ChunkURLs are listed, go fetchAllChunks\");\n    console.log(\"fetchAllChunks\", this.props.store.chunkURLs);\n    if (!this.props.store.chunkURLs.get(0)) {\n      console.warn(\"No chunk URL defined.\");\n      return;\n    }\n    for (let chunkPath of this.props.store.chunkURLs) {\n      //TODO: conditional on jsonCache not already having chunk\n      console.log(\"fetchAllChunks - START reading: \" + chunkPath);\n      this.schematic.jsonFetch(chunkPath).then((data) => {\n        console.log(\"fetchAllChunks - END reading: \" + chunkPath);\n        this.schematic.loadJsonCache(chunkPath, data);\n      });\n    }\n  }\n\n  updateSchematicMetadata() {\n    if (\n      arraysEqual(this.props.store.chunkURLs, this.props.store.chunksProcessed)\n    ) {\n      console.log(\n        \"updateSchematicMetadata #components: \" +\n          this.schematic.components.length\n      );\n      console.log(\n        \"STEP #8: chunksProcessed finishing triggers updateSchematicMetadata with final rendering info for this loaded chunks\"\n      );\n\n      // console.log(this.schematic.components);\n      this.setState(\n        {\n          schematize: this.schematic.components,\n          pathNames: this.schematic.pathNames,\n        },\n        () => {\n          this.recalcXLayout();\n\n          this.compressed_row_mapping = compress_visible_rows(\n            this.schematic.components\n          );\n          this.maxNumRowsAcrossComponents = this.calcMaxNumRowsAcrossComponents(\n            this.schematic.components\n          ); // TODO add this to mobx-state-tree\n          this.props.store.setLoading(false);\n        }\n      );\n    }\n  }\n\n  recalcXLayout() {\n    console.log(\"recalcXLayout\");\n\n    // In this way the updated relativePixelX information is available everywhere for the rendering\n    for (const [\n      i,\n      schematizeComponent,\n    ] of this.schematic.components.entries()) {\n      schematizeComponent.relativePixelX = this.leftXStart(\n        schematizeComponent,\n        i,\n        0,\n        0\n      );\n    }\n\n    const sum = (accumulator, currentValue) => accumulator + currentValue;\n    const columnsInComponents = this.schematic.components\n      .map(\n        (component) =>\n          component.arrivals.length +\n          (component.departures.length - 1) +\n          (this.props.store.useWidthCompression\n            ? this.props.store.binScalingFactor\n            : component.lastBin - component.firstBin) +\n          1\n      )\n      .reduce(sum, 0);\n    const paddingBetweenComponents =\n      this.props.store.pixelsPerColumn * this.schematic.components.length;\n    const actualWidth =\n      columnsInComponents * this.props.store.pixelsPerColumn +\n      paddingBetweenComponents;\n    this.setState({\n      actualWidth: actualWidth,\n    });\n    const [links, top] = calculateLinkCoordinates(\n      this.schematic.components,\n      this.props.store.pixelsPerColumn,\n      this.props.store.topOffset,\n      this.props.store.useWidthCompression,\n      this.props.store.binScalingFactor,\n      this.leftXStart.bind(this)\n    );\n    this.distanceSortedLinks = links;\n    this.props.store.updateTopOffset(parseInt(top));\n  }\n\n  recalcY() {\n    // forceUpdate() doesn't work with callback function\n    this.setState({ highlightedLink: null }); // nothing code to force update.\n  }\n\n  calcMaxNumRowsAcrossComponents(components) {\n    let maxNumberRowsInOneComponent = 0;\n    for (let i = 0; i < components.length; i++) {\n      const component = components[i];\n      const occupants = component.occupants;\n      const numberOccupants = occupants.filter(Boolean).length;\n      maxNumberRowsInOneComponent = Math.max(\n        numberOccupants,\n        maxNumberRowsInOneComponent\n      );\n    }\n\n    return maxNumberRowsInOneComponent;\n  }\n\n  visibleHeightPixels() {\n    if (\n      this.props.store.useVerticalCompression ||\n      !this.compressed_row_mapping\n    ) {\n      // this.state.schematize.forEach(value => Math.max(value.occupants.filter(Boolean).length, maxNumberRowsInOneComponent));\n      if (this.maxNumRowsAcrossComponents === undefined) {\n        this.maxNumRowsAcrossComponents = this.calcMaxNumRowsAcrossComponents(\n          this.schematic.components\n        );\n      }\n      console.log(\n        \"maxNumRowsAcrossComponents\",\n        this.maxNumRowsAcrossComponents\n      );\n\n      return (\n        (this.maxNumRowsAcrossComponents + 2.5) * this.props.store.pixelsPerRow\n      );\n    } else {\n      return (\n        //TODO: NOTE that Object.keys is wrong if you change compressed_row_mapping to a mobx object\n        (Object.keys(this.compressed_row_mapping).length + 0.25) *\n        this.props.store.pixelsPerRow\n      );\n    }\n  }\n\n  componentDidMount = () => {\n    let buttonContainerDiv = document.getElementById(\"button-container\");\n    let clientHeight = buttonContainerDiv.clientHeight;\n\n    const arrowsDiv = document.getElementsByClassName(\"konvajs-content\")[0];\n    arrowsDiv.style.position = \"relative\";\n\n    this.setState({ buttonsHeight: clientHeight });\n\n    this.layerRef.current.getCanvas()._canvas.id = \"cnvs\";\n    this.layerRef.current.getCanvas()._canvas.position = \"relative\";\n\n    this.layerRef2.current.getCanvas()._canvas.id = \"arrow\";\n    this.layerRef2.current.getCanvas()._canvas.position = \"relative\";\n    //this.layerRef2.current.getCanvas()._canvas.style.top = \"95px\";\n    /*if(this.props.store.useVerticalCompression) {\n      this.props.store.resetRenderStats(); //FIXME: should not require two renders to get the correct number\n    }*/\n  };\n\n  // Now it is wrapped in the updateHighlightedNode() function\n  _updateHighlightedNode = (linkRect) => {\n    this.setState({ highlightedLink: linkRect });\n    this.recalcXLayout();\n  };\n\n  // Wrapper function to wrap the logic (no link selected and time delay)\n  updateHighlightedNode = (linkRect) => {\n    // The highlighting has to work only if there isn't any selected link\n    if (!this.state.selectedLink) {\n      if (linkRect != null) {\n        // It comes from an handleMouseOver event\n\n        clearTimeout(this.timerHighlightingLink);\n\n        // To avoid unnecessary rendering when linkRect is still the this.state.highlightedLink link.\n        if (this.state.highlightedLink !== linkRect) {\n          // This ES6 syntaxt avoid to pass the result of the callback to setTimeoutwork.\n          // It works because the ES6 arrow function does not change the context of this.\n          this.timerHighlightingLink = setTimeout(\n            () => {\n              this._updateHighlightedNode(linkRect);\n            },\n            600 // TODO: value to tune. Create a config file where all these hard-coded settings will be\n          );\n        }\n      } else {\n        // It comes from an handleMouseOut event\n\n        clearTimeout(this.timerHighlightingLink);\n\n        // To avoid unnecessary rendering when linkRect == null and this.state.highlightedLink is already null for any reason.\n        if (this.state.highlightedLink != null) {\n          this.timerHighlightingLink = setTimeout(\n            () => {\n              this._updateHighlightedNode(linkRect);\n            },\n            600 // TODO: value to tune. Create a config file where all these hard-coded settings will be\n          );\n        }\n      }\n    }\n  };\n\n  updateSelectedLink = (linkRect, newBeginBin, newEndBin) => {\n    console.log(\"updateSelectedLink\");\n\n    const [beginBin, endBin] = this.props.store.beginEndBin;\n\n    // if (linkRect !== this.state.selectedLink) //else it is a re-clik on the same link, so do nothing here\n    // TODO: simplify this part, avoiding operations if the arrow is already visibile in the screen\n    let update_state = false;\n    if (!(beginBin <= newBeginBin && newEndBin <= endBin)) {\n      console.log(\"updateSelectedLink - NewBeginEndBin\");\n\n      this.props.store.updateBeginEndBin(newBeginBin, newEndBin);\n      update_state = true;\n    }\n\n    clearTimeout(this.timerHighlightingLink);\n\n    // Update the rendering if it is selected a new arrow (or deselected the last one) or\n    // if the range in changed (clicking on a new arrow or recliking on the same one)\n    if (linkRect !== this.selectedLink || update_state) {\n      console.log(\"updateSelectedLink - NewSelection\");\n\n      this.setState({\n        highlightedLink: linkRect,\n        selectedLink: linkRect,\n      });\n    }\n\n    // Auto de-selection after a delay\n    if (linkRect) {\n      console.log(\"Timer deselection\");\n\n      // Eventually restart the timer if it was already ongoing\n      clearTimeout(this.timerSelectionLink);\n\n      this.timerSelectionLink = setTimeout(\n        () => {\n          const [beginBin, endBin] = this.props.store.beginEndBin;\n          this.updateSelectedLink(null, beginBin, endBin);\n        },\n        5000 // TODO: to tune. Create a config file where all these hard-coded settings will be\n      );\n    }\n  };\n\n  leftXStart(schematizeComponent, i, firstDepartureColumn, j) {\n    /*\n    Return the x coordinate pixel that starts the LinkColumn at i, j\n    \n    If this.props.store.useWidthCompression is false:\n    - \"schematizeComponent.columnX - this.props.store.beginColumnX\" calculates the offset of the current chunk respect to the first chunk loaded\n    - \"this.props.store.getBeginBin() - this.props.store.chunkBeginBin\":\" calculates the offset of the current visualized window respect to the starting bin coordinate\n    */\n\n    let previousColumns = !this.props.store.useWidthCompression\n      ? schematizeComponent.columnX -\n        this.props.store.beginColumnX -\n        (this.props.store.getBeginBin() - this.props.store.chunkBeginBin - 1)\n      : schematizeComponent.columnX +\n        (schematizeComponent.index - this.schematic.components[0].index) *\n          this.props.store.binScalingFactor;\n\n    let pixelsFromColumns =\n      (previousColumns + firstDepartureColumn + j) *\n      this.props.store.pixelsPerColumn;\n\n    /*console.log(i, firstDepartureColumn, j)\n    console.log('previousColumns (' + previousColumns + ') = columnX (\n    ' + schematizeComponent.columnX + ') - beginColumnX (' + this.props.store.beginColumnX + ')\n     - (getBeginBin (' + this.props.store.getBeginBin() + ') -\n     chunkBeginBin (' + this.props.store.chunkBeginBin + ') - 1)')\n    console.log('pixelsFromColumns: ' + pixelsFromColumns)*/\n\n    return pixelsFromColumns + i * this.props.store.pixelsPerColumn;\n  }\n\n  renderComponent(schematizeComponent, i, pathNames) {\n    return (\n      <>\n        <ComponentRect\n          store={this.props.store}\n          item={schematizeComponent}\n          key={\"r\" + i}\n          height={this.visibleHeightPixels()}\n          widthInColumns={\n            schematizeComponent.arrivals.length +\n            (this.props.store.useWidthCompression\n              ? this.props.store.binScalingFactor\n              : schematizeComponent.num_bin) +\n            (schematizeComponent.departures.length - 1)\n          }\n          compressed_row_mapping={this.compressed_row_mapping}\n          pathNames={pathNames}\n        />\n\n        {schematizeComponent.arrivals.map((linkColumn, j) => {\n          return this.renderLinkColumn(\n            schematizeComponent,\n            i,\n            0,\n            j,\n            linkColumn\n          );\n        })}\n        {schematizeComponent.departures.slice(0, -1).map((linkColumn, j) => {\n          let leftPad =\n            schematizeComponent.arrivals.length +\n            (this.props.store.useWidthCompression\n              ? this.props.store.binScalingFactor\n              : schematizeComponent.num_bin);\n          return this.renderLinkColumn(\n            schematizeComponent,\n            i,\n            leftPad,\n            j,\n            linkColumn\n          );\n        })}\n      </>\n    );\n  }\n\n  renderLinkColumn(\n    schematizeComponent,\n    i,\n    firstDepartureColumn,\n    j,\n    linkColumn\n  ) {\n    const xCoordArrival = this.leftXStart(\n      schematizeComponent,\n      i,\n      firstDepartureColumn,\n      j\n    );\n    const [localColor, localOpacity, localStroke] = stringToColorAndOpacity(\n      linkColumn,\n      this.state.highlightedLink,\n      this.state.selectedLink\n    );\n    return (\n      <LinkColumn\n        store={this.props.store}\n        key={\"departure\" + i + j}\n        item={linkColumn}\n        pathNames={this.state.pathNames}\n        x={xCoordArrival}\n        pixelsPerRow={this.props.store.pixelsPerRow}\n        width={this.props.store.pixelsPerColumn}\n        color={localColor}\n        opacity={localOpacity}\n        stroke={localStroke}\n        updateHighlightedNode={this.updateHighlightedNode}\n        compressed_row_mapping={this.compressed_row_mapping}\n      />\n    );\n  }\n\n  renderLink(link) {\n    const [localColor, localOpacity] = stringToColorAndOpacity(\n      link.linkColumn,\n      this.state.highlightedLink,\n      this.state.selectedLink\n    );\n\n    return (\n      <LinkArrow\n        store={this.props.store}\n        key={\"arrow\" + link.linkColumn.key}\n        link={link}\n        color={localColor}\n        opacity={localOpacity}\n        updateHighlightedNode={this.updateHighlightedNode}\n        updateSelectedLink={this.updateSelectedLink}\n      />\n    );\n  }\n\n  renderNucleotidesSchematic = () => {\n    if (\n      !this.props.store.loading &&\n      // The conditions on bitWidht and useWidthCompression are lifted here,\n      // avoiding any computation if nucleotides have not to be visualized.\n      this.props.store.getBinWidth() === 1 &&\n      !this.props.store.useWidthCompression &&\n      this.props.store.pixelsPerColumn >= 10 &&\n      this.schematic.nucleotides.length > 0\n    ) {\n      //console.log('renderNucleotidesSchematic - START')\n      return this.schematic.components.map((schematizeComponent, i) => {\n        //TODO: maybe it is not necessary, to confirm its elimination\n        // Check if there are nucleotides (which cover the range [this.schematic.first_bin, this.schematic.last_bin])\n        // associated to the component to visualize (which cover the range [schematizeComponent.firstBin, schematizeComponent.lastBin])\n        /*if (\n          !(\n            this.schematic.first_bin <= schematizeComponent.firstBin &&\n            schematizeComponent.firstBin <= schematizeComponent.lastBin &&\n            schematizeComponent.lastBin <= this.schematic.last_bin\n          )\n        ) {\n          return null;\n        }*/\n\n        /*if (\n          schematizeComponent.firstBin === schematizeComponent.lastBin &&\n          schematizeComponent.firstBin === 0\n        ) {\n          return null; // Dummy component\n        }*/\n\n        //TODO: question if this.props.store.chunkBeginBin is necessary\n        const nucleotides_slice = this.schematic.nucleotides.slice(\n          schematizeComponent.firstBin - this.props.store.chunkBeginBin,\n          schematizeComponent.lastBin - this.props.store.chunkBeginBin + 1\n        );\n\n        //console.log(\"nucleotides_slice: \" + nucleotides_slice);\n\n        return (\n          <React.Fragment key={\"nt\" + i}>\n            <ComponentNucleotides\n              store={this.props.store}\n              item={schematizeComponent}\n              key={i}\n              height={this.visibleHeightPixels()}\n              width={\n                schematizeComponent.arrivals.length +\n                (this.props.store.useWidthCompression\n                  ? this.props.store.binScalingFactor\n                  : schematizeComponent.num_bin) +\n                (schematizeComponent.departures.length - 1)\n              }\n              // They are passed only the nucleotides associated to the current component\n              nucleotides={nucleotides_slice}\n            />\n          </React.Fragment>\n        );\n      });\n    }\n  };\n\n  renderSchematic() {\n    console.log(\"renderSchematic\");\n\n    if (this.props.store.loading) {\n      return;\n    }\n\n    return this.schematic.components.map((schematizeComponent, i) => {\n      return (\n        <React.Fragment key={\"f\" + i}>\n          {this.renderComponent(schematizeComponent, i, this.state.pathNames)}\n        </React.Fragment>\n      );\n    });\n  }\n\n  renderSortedLinks() {\n    if (this.props.store.loading) {\n      return;\n    }\n\n    return this.distanceSortedLinks.map((record, i) => {\n      return this.renderLink(record);\n    });\n  }\n\n  loadingMessage() {\n    if (this.props.store.loading) {\n      return (\n        <Text\n          y={100}\n          fontSize={60}\n          width={300}\n          align=\"center\"\n          text=\"Loading...\"\n        />\n      );\n    }\n  }\n\n  render() {\n    console.log(\"Start render\");\n\n    return (\n      <>\n        <div\n          style={{\n            position: \"sticky\",\n            top: 0,\n            zIndex: \"2\",\n            background: \"white\",\n\n            // To keep the matrix under the container with the vertical scrolling\n            // when the matrix is larger than the page\n            width: this.state.actualWidth + 60,\n\n            // To avoid width too low with large bin_width\n            minWidth: \"100%\",\n          }}\n        >\n          <ControlHeader store={this.props.store} schematic={this.schematic} />\n\n          <Stage\n            x={this.props.store.leftOffset}\n            y={this.props.topOffset}\n            width={this.state.actualWidth + 60}\n            height={this.props.store.topOffset}\n          >\n            <Layer ref={this.layerRef2}>\n              {this.renderSortedLinks()}\n              {this.renderNucleotidesSchematic()}\n            </Layer>\n          </Stage>\n        </div>\n\n        <Stage\n          x={this.props.store.leftOffset} // removed leftOffset to simplify code. Relative coordinates are always better.\n          y={-this.props.store.topOffset} // For some reason, I have to put this, but I'd like to put 0\n          width={this.state.actualWidth + 60}\n          height={\n            this.visibleHeightPixels() + this.props.store.nucleotideHeight\n          }\n        >\n          <Layer ref={this.layerRef}>\n            {this.loadingMessage()}\n            {this.renderSchematic()}\n          </Layer>\n        </Stage>\n\n        <NucleotideTooltip store={this.props.store} />\n      </>\n    );\n  }\n}\n\n// render(<App />, document.getElementById('root'));\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import { types } from \"mobx-state-tree\";\nimport { urlExists } from \"./URL\";\nimport { arraysEqual } from \"./utilities\";\n\nconst Chunk = types.model({\n  file: types.string,\n  fasta: types.maybeNull(types.string),\n  first_bin: types.integer,\n  last_bin: types.integer,\n  component_count: types.integer,\n  link_count: types.integer,\n});\nconst ZoomLevel = types.model({\n  bin_width: types.integer,\n  last_bin: types.integer,\n  files: types.array(Chunk),\n});\nconst ChunkIndex = types.maybeNull(\n  types.model({\n    json_version: 14,\n    pangenome_length: types.integer,\n    zoom_levels: types.map(ZoomLevel),\n  })\n);\nconst PathNucPos = types.model(\"PathNucPos\", {\n  path: types.string,\n  nucPos: types.integer,\n});\n\nlet RootStore;\nRootStore = types\n  .model({\n    chunkIndex: ChunkIndex,\n    beginEndBin: types.optional(types.array(types.integer), [1, 100]),\n    useVerticalCompression: false,\n    useWidthCompression: false,\n    binScalingFactor: 3,\n    useConnector: true,\n    pixelsPerColumn: 10,\n    pixelsPerRow: 10,\n    leftOffset: 0,\n    topOffset: 400,\n    highlightedLink: 0, // we will compare linkColumns\n    maximumHeightThisFrame: 150,\n    cellToolTipContent: \"\",\n    // TODO: to change 'jsonName' in 'jsonNameDir'?\n    jsonName: \"SARS-CoV-2\",\n    // Added attributes for the zoom level management\n    availableZoomLevels: types.optional(types.array(types.string), [\"1\"]),\n    indexSelectedZoomLevel: 0,\n    chunkURLs: types.optional(types.array(types.string), []),\n    chunkFastaURLs: types.optional(types.array(types.string), []),\n    //to be compared against chunkURLs\n    chunksProcessed: types.optional(types.array(types.string), []),\n    chunkBeginBin: -1,\n\n    pathNucPos: types.optional(PathNucPos, { path: \"path\", nucPos: 0 }), // OR: types.maybe(PathNucPos)\n    pathIndexServerAddress: \"http://193.196.29.24:3010/\",\n    nucleotideHeight: 10,\n    pangenomelast_bin: -1, //TODO: don't add values unless they're needed\n    // TODO: Set when bin2file is read\n    beginColumnX: 0, //TODO: copied and stored from bin2file.json in calculateEndBinFromScreen()\n    loading: true,\n  })\n  .actions((self) => {\n    function setChunkIndex(json) {\n      console.log(\"STEP #2: chunkIndex contents loaded\");\n      console.log(\"Index updated with content:\", json);\n      self.chunkIndex = json;\n    }\n    function updateBeginEndBin(newBegin, newEnd) {\n      console.log(\"updateBeginEndBin - \" + newBegin + \" - \" + newEnd);\n\n      /*This method needs to be atomic to avoid spurious updates and out of date validation.*/\n      newBegin = Math.max(1, Math.round(newBegin));\n      newEnd = Math.max(1, Math.round(newEnd));\n      const beginBin = getBeginBin();\n      const endBin = getEndBin();\n      if (newEnd === endBin) {\n        //end has not changed\n        let diff = endBin - beginBin;\n        newEnd = newBegin + diff; //Allows start to push End to new chunks\n      }\n      if (newEnd < newBegin) {\n        //crush newStart\n        newBegin = newEnd - 1;\n      }\n      if (newBegin !== beginBin) {\n        setBeginEndBin(newBegin, newEnd);\n        console.log(\"updated begin and end: \" + newBegin + \" \" + newEnd);\n      } else {\n        self.beginEndBin[1] = newEnd; // quietly update without refresh\n      }\n    }\n    function updateTopOffset(newTopOffset) {\n      if (Number.isFinite(newTopOffset) && Number.isSafeInteger(newTopOffset)) {\n        self.topOffset = newTopOffset + 10;\n      }\n    }\n    function updateBinScalingFactor(event) {\n      let newFactor = event.target.value;\n      self.binScalingFactor = Math.max(1, Number(newFactor));\n    }\n    function updateHighlightedLink(linkRect) {\n      self.highlightedLink = linkRect;\n    }\n    function updateMaxHeight(latestHeight) {\n      self.maximumHeightThisFrame = Math.max(\n        self.maximumHeightThisFrame,\n        latestHeight\n      );\n    }\n    function resetRenderStats() {\n      self.maximumHeightThisFrame = 1;\n    }\n    function updateCellTooltipContent(newContents) {\n      self.cellToolTipContent = String(newContents);\n    }\n    function toggleUseVerticalCompression() {\n      self.useVerticalCompression = !self.useVerticalCompression;\n    }\n    function toggleUseWidthCompression() {\n      self.useWidthCompression = !self.useWidthCompression;\n    }\n    function toggleUseConnector() {\n      self.useConnector = !self.useConnector;\n    }\n    function updateHeight(event) {\n      self.pixelsPerRow = Math.max(1, Number(event.target.value));\n    }\n    function updateWidth(event) {\n      self.pixelsPerColumn = Number(event.target.value);\n    }\n\n    function tryJSONpath(event) {\n      const url =\n        process.env.REACT_APP_FETCH + event.target.value + \"/bin2file.json\";\n      if (urlExists(url)) {\n        console.log(\"STEP#1: New Data Source: \" + event.target.value);\n        self.jsonName = event.target.value;\n      }\n    }\n\n    // Lifted down the control of the emptyness of the arrays\n    function switchChunkURLs(arrayOfFile) {\n      if (!arraysEqual(arrayOfFile, self.chunkURLs)) {\n        console.log(\"STEP #4: Set switchChunkURLs: \" + arrayOfFile);\n        self.chunkURLs = arrayOfFile;\n        self.chunksProcessed = []; //clear\n\n        return true;\n      }\n      return false;\n    }\n    function switchChunkFastaURLs(arrayOfFile) {\n      if (!arraysEqual(arrayOfFile, self.chunkFastaURLs)) {\n        console.log(\"STEP #4.fasta: Set switchChunkFastaURLs: \" + arrayOfFile);\n        self.chunkFastaURLs = arrayOfFile;\n      }\n    }\n    function addChunkProcessed(singleChunk) {\n      console.log(\"STEP #7: processed \" + singleChunk);\n      self.chunksProcessed.push(singleChunk);\n    }\n    function getBeginBin() {\n      return self.beginEndBin[0];\n    }\n    function getEndBin() {\n      return self.beginEndBin[1];\n    }\n\n    // Getter and setter for zoom info management\n    function getBinWidth() {\n      //Zoom level and BinWidth are actually the same thing\n      return Number(self.getSelectedZoomLevel());\n    }\n    function getSelectedZoomLevel() {\n      //This is a genuinely useful getter\n      let a = self.availableZoomLevels[self.indexSelectedZoomLevel];\n      return a ? a : \"1\";\n    }\n    function setIndexSelectedZoomLevel(index) {\n      self.indexSelectedZoomLevel = index;\n    }\n\n    function setAvailableZoomLevels(availableZoomLevels) {\n      let arr = [...availableZoomLevels];\n\n      self.availableZoomLevels = arr;\n    }\n\n    function setBeginEndBin(newBeginBin, newEndBin) {\n      self.beginEndBin = [newBeginBin, newEndBin];\n    }\n    function updatePathNucPos(path, nucPos) {\n      if (nucPos) {\n        nucPos = parseInt(nucPos);\n      } else {\n        nucPos = 0;\n      }\n      self.pathNucPos = { path: path, nucPos: nucPos };\n    }\n    function setBeginColumnX(x) {\n      self.beginColumnX = x;\n    }\n    function setChunkBeginBin(x) {\n      self.chunkBeginBin = x;\n    }\n\n    function setLoading(val) {\n      self.loading = val;\n    }\n    return {\n      setChunkIndex,\n      updateBeginEndBin,\n      updateTopOffset,\n      updateHighlightedLink,\n      updateMaxHeight,\n      resetRenderStats,\n      updateCellTooltipContent,\n      updateBinScalingFactor,\n      toggleUseVerticalCompression,\n      toggleUseWidthCompression,\n      toggleUseConnector,\n      updateHeight,\n      updateWidth,\n      tryJSONpath,\n\n      switchChunkURLs,\n      switchChunkFastaURLs,\n      addChunkProcessed,\n\n      getBeginBin,\n      getEndBin,\n      updatePathNucPos,\n      setBeginColumnX,\n      setChunkBeginBin,\n      //NOTE: DO NOT ADD GETTERS here.  They are not necessary in mobx.\n      // You can reference store.val directly without store.getVal()\n      //Only write getters to encapsulate useful logic for derived values\n\n      // Added zoom actions\n      getBinWidth,\n      getSelectedZoomLevel,\n      setIndexSelectedZoomLevel,\n      setAvailableZoomLevels,\n\n      setLoading,\n    };\n  })\n  .views((self) => ({}));\n\nexport const store = RootStore.create({});\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { store } from \"./ViewportInputsStore\";\n\nReactDOM.render(<App store={store} />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}