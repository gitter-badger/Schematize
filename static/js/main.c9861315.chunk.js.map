{"version":3,"sources":["URL.js","PangenomeSchematic.js","ComponentConnectorRect.js","SpanCell.js","utilities.js","ComponentRect.js","ComponentNucleotides.js","LinkColumn.js","LinkArrow.js","LinkRecord.js","App.js","NucleotideTooltip.js","ControlHeader.js","serviceWorker.js","ViewportInputsStore.js","index.js"],"names":["urlExists","dataName","http","XMLHttpRequest","open","send","status","theUrl","callback","a","xmlHttp","onreadystatechange","readyState","responseText","PangenomeSchematic","props","pathNames","components","jsonCache","nucleotides","loadIndexFile","store","jsonName","observe","chunkFastaURLs","loadFasta","jsonFilename","console","log","indexPath","process","fetch","then","res","json","setChunkIndex","filepath","Error","url","data","json_version","MediaError","this","path_names","length","processArray","path_fasta","response","text","sequence","replace","substr","push","getBeginBin","getEndBin","beginBin","endBin","chunksProcessed","chunkURLs","urlIndex","jsonChunk","num_components_already_loaded","index","entries","component","first_bin","componentItem","Component","addChunkProcessed","slice","React","columnX","x","compressedColumnX","compressedX","firstBin","lastBin","last_bin","arrivals","arrival","LinkColumn","departures","departure","relativePixelX","occupants","matrix","num_bin","useWidthCompression","linkColumn","upstream","downstream","participants","key","edgeToKey","String","padStart","ConnectorRect","state","color","y","width","height","fill","MatrixCell","event","relColumnX","Math","floor","max","evt","layerX","pixelsPerColumn","item","range","min","tooltipContent","pathName","ranges","j","start","end","updateCellTooltipContent","inverted","pixelsPerRow","align","verticalAlign","onMouseMove","onHover","bind","onMouseLeave","onLeave","undefined","copyNumber","copyNumberColorArray","invertedColorArray","inversionText","SpanCell","row","iColumns","prev","spans","newSpan","i","column","map","span","rowNumber","sum","b","arraysEqual","A","B","every","e","indexOf","areOverlapping","startA","endA","startB","endB","calculateEndBinFromScreen","selZoomLev","chunkURLarray","fileArrayFasta","level","chunkIndex","zoom_levels","get","ichunk","files","chunk","fasta","stringToColorAndOpacity","highlightedLinkColumn","selectedLink","whichLinkToConsider","colorKey","matchColor","stringToColourSave","toString","hash","charCodeAt","colour","ComponentRect","handleClick","setState","parts","entry","vertical_rank","row_n","renderMatrixRow","updateMaxHeight","verticalRank","uncompressed_y","this_y","useVerticalCompression","compressed_row_mapping","hasOwnProperty","parent","topOffset","connectorsColumn","yOffset","reduce","uncompressed_row","renderComponentConnector","uncompressedRow","x_val","binScalingFactor","widthInColumns","onClick","renderMatrix","useConnector","renderAllConnectors","ComponentNucleotides","listOfObjects","nucleotideHeight","handleMouseOut","handleMouseOver","updateHighlightedNode","Array","keys","v","pathIndex","contents","linkCells","y_coord","d","opacity","stroke","onMouseOver","onMouseOut","isInfinity","n","Number","isFinite","LinkArrow","link","updateSelectedLink","arrowXCoord","points","xArrival","departureX","xDepart","arrX","turnDirection","departOrigin","departCorner","elevation","departTop","arriveTop","arriveCorner","arriveCornerEnd","abs","isArrival","some","isNaN","calculatePoints","bezier","strokeWidth","stroke-opacity","pointerLength","pointerWidth","tension","LinkRecord","xCoordArrival","xCoordDeparture","calculateLinkCoordinates","schematic","leftXStart","index_to_component_to_visualize_dict","linkToXMapping","schematizeComponent","paddedKey","k","linkToXmapping","distanceSortedLinks","Object","values","sort","distance","elevationOccupied","record","linkBegin","linkEnd","reserveElevationAirSpace","top","calculateLinkElevations","NucleotideTooltip","MouseTooltip","visible","offsetX","offsetY","style","background","zIndex","cellToolTipContent","ControlHeader","percentage","size","diff","updateBeginEndBin","pathNucPos","path","nucPos","httpGetAsync","pathIndexServerAddress","result","alert","parseInt","newBeginBin","ceil","getBinWidth","newIndexSelectedZoomLevel","lastIndexSelectedZoomLevel","indexSelectedZoomLevel","setIndexSelectedZoomLevel","openRelevantChunksFromIndex","target","value","options","selectedIndex","_change_zoom_level","indexSelZoomLevel","availableZoomLevels","id","className","type","defaultValue","onChange","tryJSONpath","title","marginLeft","decIndexSelectedZoomLevel","val","change_zoom_level","incIndexSelectedZoomLevel","shift","beginEndBin","readOnly","list","placeholder","updatePathNucPos","getPath","handleJump","Fragment","updateHeight","updateWidth","VerticalCompressedViewSwitch","checked","toggleUseVerticalCompression","RenderConnectorSwitch","toggleUseConnector","WidthCompressedViewSwitch","toggleUseWidthCompression","Legend","src","alt","position","bottom","left","App","layerRef","createRef","layerRef2","timerHighlightingLink","timerSelectionLink","componentDidMount","_updateHighlightedNode","linkRect","highlightedLink","clearTimeout","setTimeout","update_state","binLeft","binRight","last_bin_last_visualized_component","end_closer","newEndBin","screenWidth","half","renderNucleotidesSchematic","loading","nt_shift","nucleotides_slice","schematize","actualWidth","buttonsHeight","fetchAllChunks","updateSchematicMetadata","recalcXLayout","recalcY","render","setAvailableZoomLevels","getSelectedZoomLevel","fileArray","setLastBinPangenome","bin_range_changed","scaling_factor","round","prepareWhichComponentsToVisualize","URLprefix","filename","switchChunkFastaURLs","switchChunkURLs","chunkPath","jsonFetch","loadJsonCache","warn","all_visible","Set","c","add","sorted","from","row_mapping","count","compress_visible_rows","maxNumRowsAcrossComponents","calcMaxNumRowsAcrossComponents","setLoading","first_visualized_component","last_visualized_component","getColumnX","_column_shift","links","updateTopOffset","lengths","firstDepartureColumn","visibleHeightPixels","renderLinkColumn","leftPad","localColor","localOpacity","localStroke","renderComponent","renderLink","fontSize","minWidth","leftOffset","ref","renderSortedLinks","loadingMessage","renderSchematic","Boolean","window","location","hostname","match","Chunk","types","model","file","string","maybeNull","integer","component_count","link_count","ZoomLevel","bin_width","array","ChunkIndex","pangenome_length","PathNucPos","optional","maxWidthBinRange","maximumHeightThisFrame","last_bin_pangenome","actions","self","newBegin","newEnd","excess_bins","newTopOffset","isSafeInteger","updateHighlightedLink","latestHeight","resetRenderStats","newContents","updateBinScalingFactor","newFactor","arrayOfFile","singleChunk","arr","views","create","ReactDOM","document","getElementById","navigator","serviceWorker","ready","registration","unregister"],"mappings":"2QAEO,SAASA,EAAUC,GACxB,GAAiB,KAAbA,EACF,OAAO,EAGP,IAAIC,EAAO,IAAIC,eAGf,OAFED,EAAKE,KAAK,OAAQH,GAAU,GAC9BC,EAAKG,OACkB,MAAhBH,EAAKI,O,4CAIT,WAA4BC,EAAQC,GAApC,eAAAC,EAAA,6DACDC,EAAU,IAAIP,gBACVQ,mBAAqB,WACA,IAAvBD,EAAQE,YAAuC,MAAnBF,EAAQJ,QACtCE,EAASE,EAAQG,eAJhB,SAMCH,EAAQN,KAAK,MAAOG,GAAQ,GAN7B,OAOLG,EAAQL,KAAK,MAPR,4C,0BCVDS,E,YACJ,WAAYC,GAAQ,IAAD,8BAKjB,4CAAMA,KACDC,UAAY,GACjB,EAAKC,WAAa,GAClB,EAAKC,UAAY,GAGjB,EAAKC,YAAc,GAEnB,EAAKC,cAAc,EAAKL,MAAMM,MAAMC,UAGpCC,YAAQ,EAAKR,MAAMM,MAAO,YAAY,WACpC,EAAKD,cAAc,EAAKL,MAAMM,MAAMC,aAItCC,YAAQ,EAAKR,MAAMM,MAAMG,gBAAgB,WACvC,EAAKC,eAtBU,E,yHAmCLC,GAAe,IAAD,OAC1BC,QAAQC,IAAI,qDAEZ,IAAIC,EACFC,iIAA8BJ,EAAe,iBAE/C,OADAC,QAAQC,IAAI,gCAAiCC,GACtCE,MAAMF,GACVG,MAAK,SAACC,GAAD,OAASA,EAAIC,UAClBF,MAAK,SAACE,GACLP,QAAQC,IAAI,8BAA+BC,GAG3C,EAAKd,MAAMM,MAAMc,cAAcD,Q,gCAI3BE,GACR,IAAKA,EACH,MAAM,IAAIC,MACR,sEAGJ,OADAV,QAAQC,IAAI,WAAYQ,GACjBL,MAAMK,GAAUJ,MAAK,SAACC,GAAD,OAASA,EAAIC,Y,oCAG7BI,EAAKC,GAGjB,GAFAZ,QAAQC,IAAI,iDAEc,KAAtBW,EAAKC,aACP,MAAMC,WACJ,0DACAF,EAAKC,aACL,2MAMJE,KAAKxB,UAAUoB,GAAOC,EACtBG,KAAK1B,UAAYuB,EAAKI,WACpBhB,QAAQC,IAAIc,KAAK1B,UAAU4B,OAAQ,sBACrCF,KAAKG,iB,kCAGM,IAAD,OACVlB,QAAQC,IAAI,aAGZc,KAAKvB,YAAc,GAJT,2BAOV,IAPU,IAOV,EAPU,iBAOD2B,EAPC,QAQJ9C,EAAU8C,IAGZf,MAAMe,GACHd,MAAK,SAACe,GACL,OAAOA,EAASC,UAEjBhB,MAAK,SAACgB,GAAU,IAAD,EACRC,EAAWD,EACdE,QAAQ,KAAM,IACdC,OAAO,GACPD,QAAQ,YAAa,KAGxB,IAAK/B,aAAYiC,KAAjB,oBAAyBH,IAEzBtB,QAAQC,IAAI,oBAAqBkB,OAjBzC,EAAuBJ,KAAK3B,MAAMM,MAAMG,eAAxC,+CAAyD,IAP/C,qF,qCAqCVG,QAAQC,IACN,oEAEF,IAAIP,EAAQqB,KAAK3B,MAAMM,MALV,EAMY,CAACA,EAAMgC,cAAehC,EAAMiC,aAAhDC,EANQ,KAMEC,EANF,KASsB,IAAjCnC,EAAMoC,gBAAgBb,QACtBvB,EAAMoC,gBAAgB,KAAOf,KAAK3B,MAAMM,MAAMqC,UAAU,KAExDhB,KAAKzB,WAAa,IAGpBU,QAAQC,IAAI,qCAAsC2B,EAAU,MAAOC,GAEnE,IAAK,IAAIG,EAAW,EAAGA,EAAWtC,EAAMqC,UAAUd,OAAQe,IAExD,GAAIA,GAAYtC,EAAMoC,gBAAgBb,OAAQ,CAE5C,KAAIvB,EAAMqC,UAAUC,KAAajB,KAAKxB,WA4BpC,OAAO,EA3BP,IAAIoB,EAAMjB,EAAMqC,UAAUC,GACtBC,EAAYlB,KAAKxB,UAAUoB,GAQzBuB,EACFnB,KAAKzB,WAAW2B,OAAS,EACnBF,KAAKzB,WAAWyB,KAAKzB,WAAW2B,OAAS,GAAGkB,MAAQ,EACpD,EAbqC,uBAc/C,YAA+BF,EAAU3C,WAAW8C,UAApD,+CAA+D,CAAC,IAAD,6BAArDD,EAAqD,KAA9CE,EAA8C,KAC7D,GAAIA,EAAUC,UAAY,EAAG,CAC3B,IAAIC,EAAgB,IAAIC,EACtBH,EACAH,EAAgCC,GAElCpB,KAAKzB,WAAWmC,KAAKc,KApBsB,kFAyB/C7C,EAAM+C,kBAAkB9B,GAkB9B,OAVAX,QAAQC,IACN,eACAP,EAAMoC,gBAAgB,GACtBpC,EAAMoC,gBAAgBY,OAAO,GAAG,GAChC,SACA3B,KAAK3B,MAAMM,MAAMqC,UAAUd,OAC3B,WAIK,M,GAnLsB0B,IAAMH,WAuLjCA,E,WAEJ,WAAYH,EAAWF,GAAQ,oBAC7BpB,KAAK6B,QAAUP,EAAUQ,EACzB9B,KAAK+B,kBAAoBT,EAAUU,YAEnChC,KAAKoB,MAAQA,EACbpB,KAAKiC,SAAWX,EAAUC,UAC1BvB,KAAKkC,QAAUZ,EAAUa,SAEzBnC,KAAKoC,SAAW,GARY,2BAS5B,YAAoBd,EAAUc,SAA9B,+CAAwC,CAAC,IAAhCC,EAA+B,QACtCrC,KAAKoC,SAAS1B,KAAK,IAAI4B,EAAWD,KAVR,kFAY5BrC,KAAKuC,WAAa,GAZU,2BAa5B,YAAsBjB,EAAUiB,WAAhC,+CAA4C,CAAC,IAApCC,EAAmC,QAE1CxC,KAAKuC,WAAW7B,KAAK,IAAI4B,EAAWE,KAfV,kFAkB5BxC,KAAKyC,gBAAkB,EAGvBzC,KAAK0C,UAAYpB,EAAUoB,UAC3B1C,KAAK2C,OAASrB,EAAUqB,OACxB3C,KAAK4C,QAAU5C,KAAKkC,QAAUlC,KAAKiC,SAAW,E,uDAGrCY,GACT,OAAOA,EAAsB7C,KAAK+B,kBAAoB/B,KAAK6B,Y,KAIzDS,E,WACJ,WAAYQ,GAAa,oBACvB9C,KAAK+C,SAAWD,EAAWC,SAC3B/C,KAAKgD,WAAaF,EAAWE,WAC7BhD,KAAKiD,aAAeH,EAAWG,aAC/BjD,KAAKkD,IAAMlD,KAAKmD,Y,wDAKhB,OACEC,OAAOpD,KAAKgD,YAAYK,SAAS,GAAI,KACrCD,OAAOpD,KAAK+C,UAAUM,SAAS,GAAI,S,KAK1BjF,ICzOFkF,EAAb,2MACEC,MAAQ,CACNC,MAAO,EAAKnF,MAAMmF,OAFtB,wEAMI,OACE,kBAAC,OAAD,CACE1B,EAAG9B,KAAK3B,MAAMyD,EACd2B,EAAGzD,KAAK3B,MAAMoF,EACdC,MAAO1D,KAAK3B,MAAMqF,MAClBC,OAAQ3D,KAAK3B,MAAMsF,QAAU,EAC7BC,KAAM5D,KAAKuD,MAAMC,YAZzB,GAAmC5B,IAAMH,WCA5BoC,EAAb,gLACYC,GAMJ,IAAIC,EAAaC,KAAKC,MAAMD,KAAKE,IAAI,EAAGJ,EAAMK,IAAIC,OAASpE,KAAK3B,MAAMyD,GAAK9B,KAAK3B,MAAMM,MAAM0F,iBAIxFC,EAAOtE,KAAK3B,MAAMkG,MAAMP,KAAKQ,IAAIxE,KAAK3B,MAAMkG,MAAMrE,OAAS,EAAG6D,IAC9DU,EAAiB,IACrBA,GACIzE,KAAK3B,MAAMqG,SACX,gBACAJ,EAAK,GACL,gBACAA,EAAK,GACL,UAGJ,IADA,IAAMK,EAASL,EAAK,GACXM,EAAI,EAAGA,EAAID,EAAOzE,OAAQ0E,IAAK,CACpC,IAAIC,EAAQF,EAAOC,GAAG,GAClBE,EAAMH,EAAOC,GAAG,GAEhBH,GADM,IAANG,EACkBC,EAAQ,IAAMC,EAEd,IAAMD,EAAQ,IAAMC,EAG9C9E,KAAK3B,MAAMM,MAAMoG,yBAAyBN,KA/BlD,gCAmCQzE,KAAK3B,MAAMM,MAAMoG,yBAAyB,MAnClD,oCAwCkBC,GACV,OAAIhF,KAAK3B,MAAMM,MAAMsG,aAAe,GAAKD,EAEjC,kBAAC,OAAD,CACIlD,EAAG9B,KAAK3B,MAAMyD,EACd2B,EAAGzD,KAAK3B,MAAMoF,EACdC,MAAO1D,KAAK3B,MAAMqF,MAClBC,OAAQ3D,KAAK3B,MAAMsF,QAAU,EAC7BuB,MAAO,SACPC,cAAe,SACf7E,KAAM0E,EAAW,IAAM,IACvBI,YAAapF,KAAKqF,QAAQC,KAAKtF,MAC/BuF,aAAcvF,KAAKwF,QAAQF,KAAKtF,QAIjC,OAxDnB,+BA6DQ,QAAyByF,IAArBzF,KAAK3B,MAAMkG,OAAmD,IAA5BvE,KAAK3B,MAAMkG,MAAMrE,OACnD,OAAO,KAEX,IAAM8E,EAAWhF,KAAK3B,MAAMkG,MAAM,GAAG,GAAK,GACpCmB,EAAa1F,KAAK3B,MAAMkG,MAAM,GAAG,GAEnCf,EAAQ,UAqBZ,OAnBIkC,EAAa,IAAMV,IAGfxB,EADAkC,EAAa,GACL1F,KAAK3B,MAAMM,MAAMgH,qBAAqBD,GAEtC1F,KAAK3B,MAAMM,MAAMgH,qBAAqB,KAIlDX,IAGIxB,EADAkC,EAAa,GACL1F,KAAK3B,MAAMM,MAAMiH,mBAAmBF,GAEpC1F,KAAK3B,MAAMM,MAAMiH,mBAAmB,KAMhD,oCACI,kBAAC,OAAD,CACI9D,EAAG9B,KAAK3B,MAAMyD,EACd2B,EAAGzD,KAAK3B,MAAMoF,EACdC,MAAO1D,KAAK3B,MAAMqF,MAClBC,OAAQ3D,KAAK3B,MAAMsF,QAAU,EAC7BC,KAAMJ,EACN4B,YAAapF,KAAKqF,QAAQC,KAAKtF,MAC/BuF,aAAcvF,KAAKwF,QAAQF,KAAKtF,QAEnCA,KAAK6F,cAAcb,QAnGpC,GAAgCpD,IAAMH,WAoHzBqE,EAAb,YACI,WAAYzH,GAAQ,IAAD,8BACf,4CAAMA,KACDqF,MAAQrF,EAAM0H,IAAI7F,OAFR,EADvB,sEASc,IAAD,OACL,IAAKF,KAAK3B,MAAM0H,IAAI7F,SAAWF,KAAK3B,MAAM2H,SAAS9F,OAC/C,OAAO,KAKX,IAHA,IAAI+F,EAAOjG,KAAK3B,MAAM2H,SAAS,GAAK,EAChCE,EAAQ,GACRC,EAAU,CAACzC,MAAO,EAAG5B,EAAG9B,KAAK3B,MAAM2H,SAAS,GAAIzB,MAAO,IAClD6B,EAAI,EAAGA,EAAIpG,KAAK3B,MAAM2H,SAAS9F,OAAQkG,IAAK,CACjD,IAAIC,EAASrG,KAAK3B,MAAM2H,SAASI,GAC7BC,IAAWJ,EAAO,GAClBE,EAAQzC,OAAS,EACjByC,EAAQ5B,MAAM7D,KAAKV,KAAK3B,MAAM0H,IAAIK,MAElCF,EAAMxF,KAAKyF,GAEXA,EAAU,CAACzC,MAAO,EAAG5B,EAAGuE,EAAQ9B,MAAO,CAACvE,KAAK3B,MAAM0H,IAAIK,MAE3DH,EAAOI,EAGX,OADAH,EAAMxF,KAAKyF,GACJ,oCACFD,EAAMI,KAAI,SAACC,GAAD,OACX,kBAAC,EAAD,CACIrD,IAAK,OAAS,EAAK7E,MAAMmI,UAAY,IAAMD,EAAKzE,EAChDyC,MAAOgC,EAAKhC,MACZ5F,MAAO,EAAKN,MAAMM,MAClB+F,SAAU,EAAKrG,MAAMqG,SACrB5C,EAAG,EAAKzD,MAAMyD,EAAIyE,EAAKzE,EAAI,EAAKzD,MAAMM,MAAM0F,gBAC5CZ,EAAG,EAAKpF,MAAMoF,EACd+C,UAAW,EAAKnI,MAAMmI,UACtB9C,MAAO6C,EAAK7C,MAAQ,EAAKrF,MAAMM,MAAM0F,gBACrCV,OAAQ,EAAKtF,MAAMM,MAAMsG,uBAxCzC,GAA8BrD,IAAMH,WCnH7B,SAASgF,EAAI1I,EAAG2I,GACrB,OAAO3I,EAAI2I,EAGN,SAASC,EAAYC,EAAGC,GAC7B,OACgB,IAAbD,EAAE1G,QAA6B,IAAb2G,EAAE3G,QACpB0G,EAAE1G,SAAW2G,EAAE3G,QAAU0G,EAAEE,OAAM,SAACC,GAAD,OAAOF,EAAEG,QAAQD,IAAM,KAItD,SAASE,EAAeC,EAAQC,EAAMC,EAAQC,GACnD,OAAID,EAASF,EACJG,GAAQH,IACNE,EAASF,IACXE,GAAUD,EAMd,SAASG,EAA0BzG,EAAUC,EAAQyG,EAAY5I,GAMtE,IALA,IAAI6I,EAAgB,GAChBC,EAAiB,GAEjBC,EAAQ/I,EAAMgJ,WAAWC,YAAYC,IAAIN,GAEpCO,EAAS,EAAGA,EAASJ,EAAMK,MAAM7H,OAAQ4H,IAAU,CAE1D,IAAIE,EAAQN,EAAMK,MAAMD,GACpBb,EAAepG,EAAUC,EAAQkH,EAAMzG,UAAWyG,EAAM7F,YAC1DqF,EAAc9G,KAAKsH,EAAK,MACJ,OAAhBA,EAAMC,OACRR,EAAe/G,KAAKsH,EAAMC,QAShC,MAAO,CAACT,EAAeC,GAOlB,SAASS,EACdpF,EACAqF,EACAC,GAEA,IAAMC,EAAsBD,GAExBD,EAEEG,GAAYxF,EAAWE,WAAa,IAAMF,EAAWC,SAAW,GACtE,GAAIsF,EAAqB,CAEvB,IAAIE,GACDF,EAAoBrF,WAAa,IAAMqF,EAAoBtF,SAAW,GAEzE,OAAMoF,IAA0BC,GAAiBE,IAAaC,EACrD,CACLC,EAAmBF,GACnB,EACAH,GAAyBC,EAAe,QAAU,MAG7C,CAAC,OAAQ,GAAK,MAGvB,MAAO,CAACI,EAAmBF,GAAW,EAAK,MAIxC,SAASE,EAAmBF,GACjCA,EAAWA,EAASG,WAEpB,IADA,IAAIC,EAAO,EACFtC,EAAI,EAAGA,EAAIkC,EAASpI,OAAQkG,IACnCsC,EAAOJ,EAASK,WAAWvC,KAAOsC,GAAQ,GAAKA,GAGjD,IADA,IAAIE,EAAS,IACJhE,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAE1BgE,IAAW,MADIF,GAAa,EAAJ9D,EAAU,KACV6D,SAAS,KAAKhI,QAAQ,GAEhD,OAAOmI,E,IC2DMC,E,2MA9HbtF,MAAQ,CACNC,MAAO,a,EAGTsF,YAAc,WACa,cAArB,EAAKvF,MAAMC,MACb,EAAKuF,SAAS,CAAEvF,MAAO,cACO,cAArB,EAAKD,MAAMC,OACpB,EAAKuF,SAAS,CAAEvF,MAAO,e,8EAIX,IAAD,OACTwF,EAAQhJ,KAAK3B,MAAMiG,KAAK3B,OAAO2D,KAAI,SAAC2C,EAAOC,GAC7C,IAAIC,EAAQF,EAAM,GAChB,OAAO,EAAKG,gBAAgBH,EAAM,GAAIC,EAAeC,MAGzD,OADEnJ,KAAK3B,MAAMM,MAAM0K,gBAAgBrJ,KAAK3B,MAAMiG,KAAK5B,UAAUxC,QACtD,oCAAG8I,K,sCAGMC,EAAOK,EAAcC,GACjC,IAAIC,EAASF,EACb,IAAKtJ,KAAK3B,MAAMM,MAAM8K,uBAAwB,CAC1C,IAAKzJ,KAAK3B,MAAMqL,uBAAuBC,eAAeJ,GAClD,OAAO,KAEXC,EAASxJ,KAAK3B,MAAMqL,uBAAuBH,GAE/C,OAAO,kBAAC,EAAD,CACHrG,IAAK,WAAaqG,EAClBxD,IAAKkD,EAAM,GACXjD,SAAUiD,EAAM,GAChBW,OAAQ5J,KAAK3B,MAAMiG,KACnB3F,MAAOqB,KAAK3B,MAAMM,MAClB+F,SAAU1E,KAAK3B,MAAMC,UAAUiL,GAC/BzH,EAAG9B,KAAK3B,MAAMiG,KAAK7B,eACnBzC,KAAK3B,MAAMiG,KAAKlC,SAASlC,OAASF,KAAK3B,MAAMM,MAAM0F,gBACnDZ,EAAG+F,EAASxJ,KAAK3B,MAAMM,MAAMsG,aAC7BjF,KAAK3B,MAAMM,MAAMkL,UACjBrD,UAAW+C,EACXD,aAAcA,M,4CAID,IAAD,OACd/G,EAAavC,KAAK3B,MAAMiG,KAAK/B,WAC/BuH,EAAmBvH,EAAWZ,OAAO,GAAG,GAC5C,QAAyB8D,IAArBqE,EAAgC,CAIlC,IAAIC,EAAUxH,EAAWZ,MAAM,GAAI,GAC9B2E,KAAI,SAACD,GACJ,OAAOA,EAAOpD,aAAa/C,UAE5B8J,OAAOvD,EAAK,GACjB,OACE,oCACGqD,EAAiB7G,aAAaqD,KAAI,SAAC2D,GAElC,OADAF,IACO,EAAKG,yBAAyBH,EAASE,OAKpD,OAAO,O,+CAIcX,EAAca,GACrC,IAAI7I,EAAYtB,KAAK3B,MAAMiG,KAErB8F,EACJ9I,EAAUmB,gBACTnB,EAAUc,SAASlC,QACjBF,KAAK3B,MAAMM,MAAMkE,oBACd7C,KAAK3B,MAAMM,MAAM0L,iBACjB/I,EAAUsB,SACdtB,EAAUiB,WAAWrC,OACrB,GACAF,KAAK3B,MAAMM,MAAM0F,gBACjBmF,EAASF,EAIb,OAHKtJ,KAAK3B,MAAMM,MAAM8K,yBACpBD,EAASxJ,KAAK3B,MAAMqL,uBAAuBS,IAG3C,kBAAC,EAAD,CACIjH,IAAK,YAAciH,EACnBrI,EAAGsI,EACH3G,EAAGzD,KAAK3B,MAAMM,MAAMkL,UAAYL,EAASxJ,KAAK3B,MAAMM,MAAMsG,aAC1DvB,MAAO1D,KAAK3B,MAAMM,MAAM0F,gBACxBV,OAAQ3D,KAAK3B,MAAMM,MAAMsG,aACzBzB,MAAO,c,+BAMb,OACE,oCACE,kBAAC,OAAD,CACE1B,EAAG9B,KAAK3B,MAAMiG,KAAK7B,eACnBgB,EAAGzD,KAAK3B,MAAMM,MAAMkL,UACpB3G,IAAKlD,KAAKuD,MAAML,IAAM,IACtBQ,MAAO1D,KAAK3B,MAAMiM,eAAiBtK,KAAK3B,MAAMM,MAAM0F,gBACpDV,OAAQ3D,KAAK3B,MAAMsF,OAAS,EAC5BC,KAAM5D,KAAKuD,MAAMC,MACjB+G,QAASvK,KAAK8I,cAEd9I,KAAK3B,MAAMM,MAAMkE,oBAA4C,KAAtB7C,KAAKwK,eAC7CxK,KAAK3B,MAAMM,MAAM8L,aAAezK,KAAK0K,sBAAwB,U,GAhH1C9I,IAAMH,WCenBkJ,E,0LA3BX,IARA,IAAMf,EAAS5J,KAAK3B,MAAMiG,KACpB8F,EACJR,EAAOnH,eACPmH,EAAOxH,SAASlC,OAASF,KAAK3B,MAAMM,MAAM0F,gBAIxCuG,EAAgB,GACX9I,EAAI,EAAGA,EAAI9B,KAAK3B,MAAMiG,KAAK1B,QAASd,IAC3C8I,EAAclK,KACZ,kBAAC,OAAD,CACEwC,IAAK,WAAapB,EAClBA,EAAGsI,EAAQtI,EAAI9B,KAAK3B,MAAMM,MAAM0F,gBAChCZ,EAAGzD,KAAK3B,MAAMM,MAAMkL,UAAY7J,KAAK3B,MAAMM,MAAMkM,iBACjDvK,KAAMN,KAAK3B,MAAMI,YAAYqD,GAC7BoD,MAAM,SACNvB,OAAQ3D,KAAK3B,MAAMM,MAAMkM,iBACzBnH,MAAO1D,KAAK3B,MAAMM,MAAM0F,mBAI9B,OAAOuG,I,+BAKP,OAAO5K,KAAKoJ,sB,GA5BmBxH,IAAMH,WCkE1Ba,E,YAhEb,WAAYjE,GAAQ,IAAD,8BACjB,4CAAMA,KACDyM,eAAiB,EAAKA,eAAexF,KAApB,gBACtB,EAAKyF,gBAAkB,EAAKA,gBAAgBzF,KAArB,gBAHN,E,+EAMjBtF,KAAK3B,MAAM2M,sBAAsBhL,KAAK3B,MAAMiG,Q,uCAG5CtE,KAAK3B,MAAM2M,sBAAsB,Q,kCAEtB,IHiCOnG,EAAOC,EGjCf,OACR,OAAK9E,KAAK3B,MAAMM,MAAM8K,wBHgCN5E,EG3BH,EH2BUC,EG3BP9E,KAAK3B,MAAMiG,KAAKrB,aAAa/C,OH4B1C,YAAI+K,MAAM,EAAInG,EAAMD,GAAOqG,QAAQ5E,KAAI,SAAC6E,GAAD,OAAOtG,EAAQsG,MG5BJ7E,KACjD,SAAC7C,GAAD,OAAOA,EAAI,EAAKpF,MAAMM,MAAMsG,gBALrBjF,KAAK3B,MAAMiG,KAAKrB,aAAaqD,KAAI,SAAC8E,GAAD,OACpC,EAAK/M,MAAMqL,uBAAuB0B,GAAa,EAAK/M,MAAMM,MAAMsG,kB,0CAO1EjF,KAAK+I,SAAS,CACZvF,MAAOxD,KAAK3B,MAAMmF,U,+BAGZ,IAAD,OACD6H,EAAWrL,KAAKsL,YACtB,OACE,oCACGD,EAAS/E,KAAI,SAACiF,EAASC,GACtB,OACE,kBAAC,OAAD,CACEtI,IAAK,MAAQsI,EACb1J,EAAG,EAAKzD,MAAMyD,EACd2B,EACE,EAAKpF,MAAMM,MAAMkL,UACjB0B,EAEF7H,MAAO,EAAKrF,MAAMM,MAAM0F,gBACxBV,OAAQ,EAAKtF,MAAMM,MAAMsG,aACzBrB,KAAM,EAAKvF,MAAMmF,MACjBiI,QAAS,EAAKpN,MAAMoN,QACpBC,OAAQ,EAAKrN,MAAMqN,OAEnBC,YAAa,EAAKZ,gBAClBa,WAAY,EAAKd,yB,GA9CNlJ,IAAMH,WCD/B,SAASoK,EAAWC,GAClB,OAAQC,OAAOC,SAASF,G,IA6HXG,E,YAxHb,WAAY5N,GAAQ,IAAD,8BACjB,4CAAMA,KAoGR0M,gBAAkB,WAChB,EAAK1M,MAAM2M,sBAAsB,EAAK3M,MAAM6N,KAAKpJ,aAtGhC,EAwGnBgI,eAAiB,WACf,EAAKzM,MAAM2M,sBAAsB,OAzGhB,EA2GnBlC,YAAc,SAAChF,GACb7E,QAAQC,IAAI,QAAS4E,EAAO,EAAKzF,MAAM6N,MAEvC,EAAK7N,MAAM8N,mBAAmB,EAAK9N,MAAM6N,KAAKpJ,aA5G9C,EAAKsJ,YAAc,KACnB,EAAKC,OAAS,GACd,EAAKvB,eAAiB,EAAKA,eAAexF,KAApB,gBACtB,EAAKyF,gBAAkB,EAAKA,gBAAgBzF,KAArB,gBALN,E,6HAgBjB,IAAI4G,EAAOlM,KAAK3B,MAAM6N,KACtBlM,KAAKoM,YAAcpM,KAAK3B,MAAM6N,KAAKI,SACnC,IAEIC,EAFgBvM,KAAK3B,MAAM6N,KAAKM,QAGlBxM,KAAKoM,YAAcpM,KAAK3B,MAAMM,MAAM0F,gBAAkB,EACpEoI,EAAOzM,KAAK3B,MAAMM,MAAM0F,gBAAkB,EAE1CqI,EAAgBH,EAAa,GAAK,EAAI,EACpCI,EAAe,CAACJ,EAAYvM,KAAK3B,MAAMM,MAAM0F,gBAAkB,GAC/DuI,EAAe,CAACL,EAAaG,EAAiC,EAAjBR,EAAKW,WACpDC,EAAY,CAACP,EAA6B,EAAhBG,GAAoBR,EAAKW,WACnDE,EAAY,CAACN,EAAuB,EAAhBC,GAAoBR,EAAKW,WAC7CG,EAAe,CAACP,EAAOC,EAAiC,EAAjBR,EAAKW,WAC1CI,EAAkB,CAACR,GAAO,GAChCzM,KAAKqM,OAAS,CACZM,EAAa,GACbA,EAAa,GACbC,EAAa,GACbA,EAAa,GACbE,EAAU,GACVA,EAAU,GACVC,EAAU,GACVA,EAAU,GACVC,EAAa,GACbA,EAAa,GACbC,EAAgB,GAChBA,EAAgB,GAChBR,GACC,GAECzI,KAAKkJ,IAAIX,IAAevM,KAAK3B,MAAMM,MAAM0F,kBAEvC6H,EAAKiB,UACPnN,KAAKqM,OAAS,CACZI,GACC,GACDA,GA9BO,GAkCTzM,KAAKqM,OAAS,CACZM,EAAa,IAnCN,EAoCE3M,KAAK3B,MAAMM,MAAM0F,gBAC1BsI,EAAa,IACZ,KAIH3M,KAAKqM,OAAOe,KAAKC,QAAUrN,KAAKqM,OAAOe,KAAKvB,KAC9C5M,QAAQC,IAAI,wBAA0Bc,KAAKqM,U,+BAY7C,OANArM,KAAKsN,kBAOH,kBAAC,QAAD,CACExL,EAAG9B,KAAKoM,YACR3I,EAAGzD,KAAK3B,MAAMM,MAAMkL,UAAY,GAChCnG,MAAO1D,KAAK3B,MAAMM,MAAM0F,gBACxBgI,OAAQrM,KAAKqM,OACbkB,QAAQ,EACRC,YAAaxN,KAAK3B,MAAMM,MAAM0F,gBAC9BT,KAAM5D,KAAK3B,MAAMmF,MACjBkI,OAAQ1L,KAAK3B,MAAMmF,MACnBiI,QAASzL,KAAK3B,MAAMoN,QACpBgC,iBAAgBzN,KAAK3B,MAAMoN,QAC3BiC,cAAe,EACfC,aAAc,EACdC,QAAS,EAAI,EACbjC,YAAa3L,KAAK+K,gBAClBa,WAAY5L,KAAK8K,eACjBP,QAASvK,KAAK8I,kB,GAjGElH,IAAMH,WCRjBoM,EAAb,WACE,WAAY/K,GAAgE,IAApDgL,EAAmD,uDAAnC,EAAGC,EAAgC,uDAAd,EAAGZ,EAAW,2DACzEnN,KAAK8C,WAAaA,OACC2C,IAAf3C,GACF7D,QAAQC,IAAI4D,EAAYgL,EAAeC,GAEzC/N,KAAKsM,SAAWwB,EAChB9N,KAAKwM,QAAUuB,EACf/N,KAAK6M,UAAY,GACjB7M,KAAKmN,UAAYA,EATrB,uDAYI,OAAOnJ,KAAKkJ,IAAIlN,KAAKwM,QAAUxM,KAAKsM,WAAa,MAZrD,KAgBO,SAAS0B,EACdC,EACA5J,EACAwF,EACAhH,EACAwH,EACA6D,EACAC,GAYA,IAFA,IAAIC,EAAiB,GAEZhI,EAAI,EAAGA,EAAI6H,EAAU/N,OAAQkG,IAAK,CACzC,IAAIiI,EAAsBJ,EAAU7H,GAEpC,GAAIiI,EAAoBjN,SAAS+M,EAAsC,CAGrE,IAAK,IAAIvJ,EAAI,EAAGA,EAAIyJ,EAAoBjM,SAASlC,OAAQ0E,IAAK,CAC5D,IAAIvC,EAAUgM,EAAoBjM,SAASwC,GACvCkJ,EAAgBI,EAAWG,EAAqBjI,EAAG,EAAGxB,GACtD0J,EAAYjM,EAAQa,IAClBoL,KAAaF,EAUjBA,EAAeE,GAAWhC,SAAWwB,EAPrCM,EAAeE,GAAa,IAAIT,EAC9BxL,EACAyL,EACAA,GACA,GAON,IAAK,IAAIS,EAAI,EAAGA,EAAIF,EAAoB9L,WAAWrC,OAAS,EAAGqO,IAAK,CAClE,IAAI/L,EAAY6L,EAAoB9L,WAAWgM,GAC3CR,EAAkBG,EACpBG,EACAjI,EACAiI,EAAoBjM,SAASlC,QAC1B2C,EACGwH,EACAgE,EAAoBzL,SAC1B2L,GAEED,EAAY9L,EAAUU,IACpBoL,KAAaF,EAUjBA,EAAeE,GAAW9B,QAAUuB,EAPpCK,EAAeE,GAAa,IAAIT,EAC9BrL,EACAuL,EACAA,GACA,KAQV,OAGF,SAAiCS,EAAgBnK,EAAiBwF,GAMhE,IAAI4E,EAAsBC,OAAOC,OAAOH,GAAgBI,MACtD,SAAC7Q,EAAG2I,GAAJ,OAAU3I,EAAE8Q,WAAanI,EAAEmI,cAEzBC,EASN,SACEL,EACApK,EACAwF,GAIA,IAAI3J,EAAS8D,KAAKE,IAAL,MAAAF,KAAI,CACf,GADe,mBAEZyK,EAAoBnI,KAAI,SAACxE,GAAD,OAAOkC,KAAKE,IAAIpC,EAAE0K,QAAS1K,EAAEwK,gBAEtDwC,EAAoB,IAAI7D,MAAM/K,GAAQ0D,KAAK,IAP/C,uBAQA,YAAmB6K,EAAnB,+CAAwC,CAAC,IAAhCM,EAA+B,QAClCC,EAAYhL,KAAKE,IAAI,EAAGF,KAAKQ,IAAIuK,EAAOzC,SAAUyC,EAAOvC,UACzDyC,EAAUjL,KAAKE,IAAI6K,EAAOzC,SAAUyC,EAAOvC,QAASwC,EAAY,GAChEzK,EAAQuK,EAAkBnN,MAAMqN,EAAWC,EAAU,GACrDpC,EAAYtI,EAAMrE,OAAS8D,KAAKE,IAAL,MAAAF,KAAI,YAAQO,IAAS,IAChD8I,MAAMR,IAAed,OAAOC,SAASa,IACvC5N,QAAQC,IACN,gBACA6P,EACAC,EACAC,EACA1K,EACAuK,GAIJjC,GAA0BxI,EAC1B,IAAK,IAAIvC,EAAIkN,EAAWlN,EAAImN,GAAWnN,EAAIgN,EAAkB5O,OAAQ4B,IACnEgN,EAAkBhN,GAAK+K,EAEzBkC,EAAOlC,UAAYA,GA5BrB,kFA8BA,OAAOiC,EA3CiBI,CACtBT,EACApK,GAGE8K,EAAMnL,KAAKE,IAAL,MAAAF,KAAI,YAAQ8K,IAAuC,EAAlBzK,EAC3C,MAAO,CAACoK,EAAqBU,GAlBtBC,CAAwBhB,EAAgB/J,G,IChE7C8J,E,gBCjBiBkB,E,iLACT,IAAD,OACP,OACE,kBAACC,EAAA,EAAD,CACIC,SAAS,EACTC,QAAS,GACTC,SAAU,GACVC,MAAO,CAACC,WAAY,QAASC,OAAQ,EAAG,WAAc,aAExD,kBAAC,IAAD,MACG,kBAAM,8BAAO,EAAKvR,MAAMM,MAAMkR,4B,GAVMjO,IAAMH,WCA/CqO,E,8KACEC,GACJ,IAAMlP,EAAWb,KAAK3B,MAAMM,MAAMgC,cAC5BG,EAASd,KAAK3B,MAAMM,MAAMiC,YAC5BoP,EAAOlP,EAASD,EAChBoP,EAAOjM,KAAKC,MAAM+L,GAAQD,EAAa,MAC3C9Q,QAAQC,IAAI4B,EAAS,IAAMD,EAAW,IAAMmP,EAAO,iBAAgBC,GACnEjQ,KAAK3B,MAAMM,MAAMuR,kBAAkBrP,EAAWoP,EAAMnP,EAASmP,K,mCAI7DhR,QAAQC,IACN,oBACEc,KAAK3B,MAAMM,MAAMwR,WAAWC,KAC5B,yBACApQ,KAAK3B,MAAMM,MAAMwR,WAAWE,QAIhC,IAAM1R,EAAQqB,KAAK3B,MAAMM,OZVtB,SAAP,6BYgCI2R,CArBa3R,EAAM4R,uBACD5R,EAAMwR,WAAWC,KAoBH,IAnBhBzR,EAAMwR,WAAWE,QAEjC,SAAkCG,GAChC,GAAe,MAAXA,EACFC,MACE,2HAEG,CACLxR,QAAQC,IAAIsR,GAEZA,EAASE,SAASF,GAClB,IAAMG,EAAc3M,KAAK4M,KAAKJ,EAASxQ,KAAK3B,MAAMM,MAAMkS,eACxD5R,QAAQC,IAAIyR,GACZhS,EAAMuR,kBAAkBS,EAAahS,EAAMiC,mB,yCAS9BkQ,GACjB,IAAMC,EAA6B/Q,KAAK3B,MAAMM,MAAMqS,uBACpDhR,KAAK3B,MAAMM,MAAMsS,0BAA0BH,GAC3C9Q,KAAK3B,MAAM6S,4BAA4BH,K,wCAGvBI,GAChBlS,QAAQC,IACN,sBACEiS,EAAOC,MACP,OACAD,EAAOE,QAAQF,EAAOG,eAAehR,MAGzCN,KAAKuR,mBAAmBb,SAASS,EAAOC,U,kDAIxC,IAAII,EAAoBxR,KAAK3B,MAAMM,MAAMqS,uBACrCQ,EAAoB,GACtBxR,KAAKuR,mBAAmBC,EAAoB,K,kDAK9C,IAAIA,EAAoBxR,KAAK3B,MAAMM,MAAMqS,uBACrCQ,EAAoBxR,KAAK3B,MAAMM,MAAM8S,oBAAoBvR,OAAS,GACpEF,KAAKuR,mBAAmBC,EAAoB,K,+BAItC,IAAD,OACP,OACE,yBAAKE,GAAG,oBACN,4BAAQC,UAAU,SAASD,GAAG,gBAA9B,cAGA,2BACEE,KAAK,OACLC,aAAc7R,KAAK3B,MAAMM,MAAMC,SAC/B8Q,MAAO,CAAEhM,MAAO,SAChBoO,SAAU9R,KAAK3B,MAAMM,MAAMoT,YAC3BC,MAAO,UAET,0BAAMtC,MAAO,CAAEuC,WAAY,SACzB,kBAAC,IAAD,MACG,kBACC,iDAEE,4BACEN,UAAU,SACVpH,QAAS,kBAAM,EAAK2H,8BAFtB,KAMA,4BACER,GAAG,mBACHI,SAAU,SAACK,GAAD,OAAS,EAAKC,kBAAkBD,EAAIhB,SAC9CC,MAAO,EAAK/S,MAAMM,MAAMqS,wBAEvB,EAAK3S,MAAMM,MAAM8S,oBAAoBnL,KAAI,SAAChC,EAAM8B,GAAP,OACxC,4BAAQlD,IAAKkD,EAAGgL,MAAOhL,GACpB9B,OAIP,4BACEqN,UAAU,SACVpH,QAAS,kBAAM,EAAK8H,8BAFtB,UAWR,0BAAM3C,MAAO,CAAEuC,WAAY,SACzB,4BAAQN,UAAU,SAASpH,QAAS,kBAAM,EAAK+H,OAAO,OAAtD,MAGA,4BAAQX,UAAU,SAASpH,QAAS,kBAAM,EAAK+H,OAAO,MAAtD,KAJF,0BAQE,kBAAC,IAAD,MACG,kBACC,oCACE,2BACEV,KAAK,SACLR,MAAO,EAAK/S,MAAMM,MAAM4T,YAAY,GACpCT,SAAU,SAAChO,GAAD,OACR,EAAKzF,MAAMM,MAAMuR,kBACfpM,EAAMqN,OAAOC,MACb,EAAK/S,MAAMM,MAAMiC,cAGrB8O,MAAO,CAAEhM,MAAO,UAVpB,IAaE,2BACEkO,KAAK,SACLR,MAAO,EAAK/S,MAAMM,MAAM4T,YAAY,GACpCC,UAAQ,EACR9C,MAAO,CAAEhM,MAAO,cAKxB,4BAAQiO,UAAU,SAASpH,QAAS,kBAAM,EAAK+H,MAAM,MAArD,KAGA,4BAAQX,UAAU,SAASpH,QAAS,kBAAM,EAAK+H,MAAM,OAArD,OAIF,yBAAKX,UAAW,OAAhB,uCAEE,2BACEC,KAAK,SACLa,KAAK,OACLC,YAAa,OACbZ,SAAU,SAAChO,GAAD,OACR,EAAKzF,MAAMM,MAAMgU,iBACf7O,EAAMqN,OAAOC,MACb,EAAK/S,MAAMM,MAAMwR,WAAWE,SAGhCX,MAAO,CAAEhM,MAAO,UAElB,8BAAUgO,GAAG,QACV1R,KAAK3B,MAAM4P,UAAU3P,UAAUgI,KAAI,SAAChC,EAAMpB,GAAP,OAClC,4BAAQA,IAAKA,EAAKkO,MAAO9M,QAhB/B,IAoBE,2BACEsN,KAAK,SACLc,YAAa,WACbZ,SAAU,SAAChO,GAAD,OACR,EAAKzF,MAAMM,MAAMgU,iBACf,EAAKtU,MAAMM,MAAMiU,UACjB9O,EAAMqN,OAAOC,QAGjB1B,MAAO,CAAEhM,MAAO,UAElB,0BAAMgM,MAAO,CAAEuC,WAAY,QACzB,4BAAQN,UAAU,SAASpH,QAAS,kBAAM,EAAKsI,eAA/C,UAKJ,yBAAKlB,UAAW,OACd,8BACG,IADH,4BAGE,kBAAC,EAAD,CAA8BhT,MAAOqB,KAAK3B,MAAMM,SAElD,8BACG,IADH,4BAGE,kBAAC,EAAD,CAA2BA,MAAOqB,KAAK3B,MAAMM,SAE9CqB,KAAK3B,MAAMM,MAAMkE,oBAChB,kBAAC,IAAMiQ,SAAP,KACE,8BACG,IADH,qBAGE,kBAAC,EAAD,CAAuBnU,MAAOqB,KAAK3B,MAAMM,UAI7C,qCAEF,8BACG,IADH,cAGE,kBAAC,IAAD,MACG,kBACC,2BACEiT,KAAK,SACLpN,IAAK,EACL4M,MAAO,EAAK/S,MAAMM,MAAMsG,aACxB6M,SAAU,EAAKzT,MAAMM,MAAMoU,aAC3BrD,MAAO,CAAEhM,MAAO,cAKxB,8BACG,IADH,gBAGE,2BACEkO,KAAK,SACLpN,IAAK,EACL4M,MAAOpR,KAAK3B,MAAMM,MAAM0F,gBACxByN,SAAU9R,KAAK3B,MAAMM,MAAMqU,YAC3BtD,MAAO,CAAEhM,MAAO,iB,GAlPF9B,IAAMH,WA+P5BwR,E,iLACM,IAAD,OACP,OACE,kBAAC,IAAD,MACG,kBACC,2BACErB,KAAK,WACLsB,QAAS,EAAK7U,MAAMM,MAAM8K,uBAC1BqI,SAAU,EAAKzT,MAAMM,MAAMwU,sC,GARIvR,IAAMH,WAoB3C2R,E,iLACM,IAAD,OACP,OACE,kBAAC,IAAD,MACG,kBACC,2BACExB,KAAK,WACLsB,QAAS,EAAK7U,MAAMM,MAAM8L,aAC1BqH,SAAU,EAAKzT,MAAMM,MAAM0U,4B,GARHzR,IAAMH,WAoBpC6R,E,iLACM,IAAD,OACP,OACE,kBAAC,IAAD,MACG,kBACC,2BACE1B,KAAK,WACLsB,QAAS,EAAK7U,MAAMM,MAAMkE,oBAC1BiP,SAAU,EAAKzT,MAAMM,MAAM4U,mC,GARC3R,IAAMH,WAoB/BqO,IFxSf,SAAS0D,EAAOnV,GACd,OACE,yBACEoV,IAAKrU,oCACLsU,IAAI,SACJhE,MAAO,CACLiE,SAAU,QACVC,OAAQ,OACRC,KAAM,OACNlE,WAAY,QACZzK,MAAO,QACPxB,MAAO,QACPC,OAAQ,W,IAswBDmQ,E,YAzvBb,WAAYzV,GAAQ,IAAD,8BACjB,4CAAMA,KAPR0V,SAAWnS,IAAMoS,YAME,EALnBC,UAAYrS,IAAMoS,UAAU,MAKT,EAHnBE,sBAAwB,KAGL,EAFnBC,mBAAqB,KAEF,EA0UnBC,kBAAoB,aA1UD,EA+VnBC,uBAAyB,SAACC,GACxB,EAAKvL,SAAS,CAAEwL,gBAAiBD,KAhWhB,EAoWnBtJ,sBAAwB,SAACsJ,GAElB,EAAK/Q,MAAM6E,eACE,MAAZkM,GAGFE,aAAa,EAAKN,uBAGd,EAAK3Q,MAAMgR,kBAAoBD,IAGjC,EAAKJ,sBAAwBO,YAC3B,WACE,EAAKJ,uBAAuBC,KAE9B,QAMJE,aAAa,EAAKN,uBAGgB,MAA9B,EAAK3Q,MAAMgR,kBACb,EAAKL,sBAAwBO,YAC3B,WACE,EAAKJ,uBAAuBC,KAE9B,SAlYS,EAyYnBnI,mBAAqB,SAACmI,GACpBrV,QAAQC,IAAI,sBAEZ,IAAIwV,GAAe,EAEnB,GAAIJ,EAAU,OAGgB,CAACA,EAASvR,SAAUuR,EAAStR,YAAY4L,MACnE,SAAU7Q,EAAG2I,GACX,OAAO3I,EAAI2I,KALH,mBAGLiO,EAHK,KAGIC,EAHJ,KAYNC,EAAqCnG,OAAOC,OAChDR,GACAxM,OAAO,GAAG,GAAGO,QAdH,cAiBe,EAAK7D,MAAMM,MAAM4T,YAjBhC,GAiBL1R,EAjBK,KAiBKC,EAjBL,KAkBZ,GAAI6T,EAAU9T,GAAY+T,EAAWC,EAAoC,CACvE5V,QAAQC,IAAI,uCAEZ,IAAM4V,EACJ9Q,KAAKkJ,IAAIrM,EAAW8T,GAAW3Q,KAAKkJ,IAAIpM,EAAS8T,GAJoB,cAMxC,EAAKvW,MAAMM,MAAM4T,YANuB,GAMlE5B,EANkE,KAMrDoE,EANqD,KAOnEC,EAAclU,EAASD,EACvBoU,EAAOjR,KAAKC,MAAM+Q,EAAc,GAChCF,GACDnE,EAA2BgE,EAAUM,EAAxBF,EAA8BJ,EAAUM,IAErDtE,EAA2BiE,EAAWK,EAAzBF,EAA+BH,EAAWK,GAG1D,EAAK5W,MAAMM,MAAMuR,kBAAkBS,EAAaoE,GAChDL,GAAe,GAInBF,aAAa,EAAKN,wBAIdI,IAAa,EAAKlM,cAAgBsM,KACpCzV,QAAQC,IAAI,qCAEZ,EAAK6J,SAAS,CACZwL,gBAAiBD,EACjBlM,aAAckM,KAKdA,IACFrV,QAAQC,IAAI,qBAGZsV,aAAa,EAAKL,oBAElB,EAAKA,mBAAqBM,YACxB,WACE,EAAKtI,mBAAmB,QAE1B,OA5ca,EAkmBnB+I,2BAA6B,WAC3B,IACG,EAAK7W,MAAMM,MAAMwW,SAGiB,IAAnC,EAAK9W,MAAMM,MAAMkS,gBAChB,EAAKxS,MAAMM,MAAMkE,qBAClB,EAAKxE,MAAMM,MAAM0F,iBAAmB,IACpC,EAAK4J,UAAUxP,YAAYyB,OAAS,EAGpC,OAAOwO,OAAOC,OAAOR,GAAsC7H,KACzD,SAAC+H,EAAqBjI,GAGpB,IAAMgP,EAAW,EAAKnH,UAAU1P,WAAW,GAAG0D,UAAY,EAEpDoT,EAAoB,EAAKpH,UAAUxP,YAAYkD,MACjD0M,EAAoBpM,SAAWmT,EAC/B/G,EAAoBnM,QAAUkT,EAAW,GAK7C,OACE,kBAAC,IAAMtC,SAAP,CAAgB5P,IAAK,KAAOkD,GAC1B,kBAAC,EAAD,CACEzH,MAAO,EAAKN,MAAMM,MAClB2F,KAAM+J,EACNnL,IAAKkD,EAEL3H,YAAa4W,SA9nBzB,EAAK9R,MAAQ,CACX+R,WAAY,GACZhX,UAAW,GACXiX,YAAa,EACbC,cAAe,GAEjB,EAAKvH,UAAY,IAAI7P,EAAmB,CAAEO,MAAO,EAAKN,MAAMM,QAmB5DE,YAAQ,EAAKR,MAAMM,MAAMqC,UAAW,EAAKyU,eAAenQ,KAApB,iBAGpCzG,YACE,EAAKR,MAAMM,MACX,yBACA,EAAK+W,wBAAwBpQ,KAA7B,iBAEFzG,YAAQ,EAAKR,MAAMM,MAAO,uBAAuB,WAC/C,EAAKgX,mBAEP9W,YAAQ,EAAKR,MAAMM,MAAO,eAAgB,EAAKgX,cAAcrQ,KAAnB,iBAC1CzG,YAAQ,EAAKR,MAAMM,MAAO,kBAAmB,EAAKgX,cAAcrQ,KAAnB,iBAC7CzG,YAAQ,EAAKR,MAAMM,MAAO,eAAgB,EAAKiX,QAAQtQ,KAAb,iBAI1CzG,YACE,EAAKR,MAAMM,MAAMoC,gBACjB,EAAK2U,wBAAwBpQ,KAA7B,iBAIFzG,YAAQ,EAAKR,MAAMM,MAAO,UAAW,EAAKkX,OAAOvQ,KAAZ,iBAGrCzG,YACE,EAAKR,MAAMM,MACX,aACA,EAAKuS,4BAA4B5L,KAAjC,iBAQFzG,YACE,EAAKR,MAAMM,MAAM4T,YAEjB,EAAKrB,4BAA4B5L,KAAjC,iBApEe,E,iGA+EjB6I,EAAuC,GAJL,2BAMlC,YAAkCnO,KAAKiO,UAAU1P,WAAjD,+CAA6D,CAAC,IAAnD8P,EAAkD,QAC3D,GACEpH,EACEjH,KAAK3B,MAAMM,MAAMgC,cACjBX,KAAK3B,MAAMM,MAAMiC,YACjByN,EAAoBpM,SACpBoM,EAAoBnM,SAKtBiM,EACEE,EAAoBjN,OAClBiN,OACC,GAAIA,EAAoBpM,SAAWjC,KAAK3B,MAAMM,MAAMiC,YAEzD,OAtB8B,qF,oDAkC0B,IAAlCmQ,EAAiC,wDAAH,EAKxD,GAJA9R,QAAQC,IACN,oEAIgC,OAAhCc,KAAK3B,MAAMM,MAAMgJ,YAChB3H,KAAK3B,MAAMM,MAAMgJ,WAAWC,YAAYsD,OAF3C,CAMA,IAAMrK,EAAWb,KAAK3B,MAAMM,MAAMgC,cAGlCX,KAAK3B,MAAMM,MAAMmX,uBACf9V,KAAK3B,MAAMM,MAAMgJ,WAAjB,YAA2CuD,QAE7C,IAAM3D,EAAavH,KAAK3B,MAAMM,MAAMoX,uBAjBuB,EAkBzBzO,EAChCzG,EACAb,KAAK3B,MAAMM,MAAMiC,YACjB2G,EACAvH,KAAK3B,MAAMM,OAtB8C,mBAkBtDqX,EAlBsD,KAkB3CvO,EAlB2C,KAwB3DzH,KAAK3B,MAAMM,MAAMsX,oBACfjW,KAAK3B,MAAMM,MAAMgJ,WAAWC,YAAYC,IAAIN,GAA5C,UAGF,IAAI2O,GAAoB,EACxB,GAAInF,GAA8B,EAAG,CACnC,IAAMoF,EACJnW,KAAK3B,MAAMM,MAAMoX,qBAAqBhF,GACtC/Q,KAAK3B,MAAMM,MAAMoX,uBACnB9W,QAAQC,IAAI,mBAAqBiX,GACjCD,EAAoBlW,KAAK3B,MAAMM,MAAMuR,kBACnClM,KAAKoS,OAAOvV,EAAW,GAAKsV,GAC5BnS,KAAKoS,OAAOpW,KAAK3B,MAAMM,MAAMiC,YAAc,GAAKuV,IAKpD,IAAKD,EAAmB,CACtBlW,KAAKqW,oCAGP,IAAIC,EACFlX,iIACAY,KAAK3B,MAAMM,MAAMC,SACjB,IACA2I,EACA,IACFyO,EAAYA,EAAU1P,KAAI,SAACiQ,GACzB,OAAOD,EAAYC,KAErB9O,EAAiBA,EAAenB,KAAI,SAACiQ,GACnC,OAAOD,EAAYC,KAGnBvW,KAAK3B,MAAMM,MAAM6X,qBAAqB/O,GAGjCzH,KAAK3B,MAAMM,MAAM8X,gBAAgBT,IACpChW,KAAK2V,oB,uCAKO,IAAD,OAMf,GAFA1W,QAAQC,IAAI,yDAEPc,KAAK3B,MAAMM,MAAMqC,UAAU6G,IAAI,GAApC,CANe,2BAUf,IAVe,IAUf,EAVe,iBAUN6O,EAVM,QAab,EAAKzI,UAAU0I,UAAUD,GAAWpX,MAAK,SAACO,GACxCZ,QAAQC,IAAI,iCAAmCwX,GAC/C,EAAKzI,UAAU2I,cAAcF,EAAW7W,OAL5C,EAAsBG,KAAK3B,MAAMM,MAAMqC,UAAvC,+CAAmD,IAVpC,wFAOb/B,QAAQ4X,KAAK,2B,gDAaU,IAAD,OAEtBlQ,EAAY3G,KAAK3B,MAAMM,MAAMqC,UAAWhB,KAAK3B,MAAMM,MAAMoC,mBAEzD9B,QAAQC,IACN,wCACEc,KAAKiO,UAAU1P,WAAW2B,QAE9BjB,QAAQC,IACN,wHAGFc,KAAKqW,oCAGLrW,KAAK+I,SACH,CACEuM,WAAYtV,KAAKiO,UAAU1P,WAC3BD,UAAW0B,KAAKiO,UAAU3P,YAE5B,WACE,EAAKqX,gBAEL,EAAKjM,uBLpQR,SAA+BnL,GAGpC,IAAIuY,EAAc,IAAIC,IAH0B,uBAIhD,YAAcxY,EAAd,+CAA0B,CAAC,IAAlByY,EAAiB,+BACtB,YAAgBA,EAAEtU,UAAlB,+CAA6B,CAAC,IAArBqD,EAAoB,QACzB+Q,EAAYG,IAAIlR,IAFE,oFAJsB,kFAShD,IAAImR,EAASjM,MAAMkM,KAAKL,GAAalI,OACjCwI,EAAc,GAV8B,uBAWhD,YAA2BF,EAAO7V,UAAlC,+CAA6C,CAAC,IAAD,6BAAnCgW,EAAmC,KACzCD,EADyC,MACpBC,GAZuB,kFAchD,OAAOD,EKsP+BE,CAC5B,EAAKrJ,UAAU1P,YAEjB,EAAKgZ,2BAA6B,EAAKC,+BACrC,EAAKvJ,UAAU1P,YAEjB,EAAKF,MAAMM,MAAM8Y,YAAW,S,sCAOlCxY,QAAQC,IAAI,iBADE,2BAId,YAGKc,KAAKiO,UAAU1P,WAAW8C,UAH/B,+CAG0C,CAAC,IAAD,6BAFxC+E,EAEwC,KADxCiI,EACwC,KACxCA,EAAoB5L,eAAiBzC,KAAKkO,WACxCG,EACAjI,EACA,EACA,IAZU,kFAgBd,IAAMsR,EAA6BhJ,OAAOC,OACxCR,GACA,GACIwJ,EAA4BjJ,OAAOC,OACvCR,GACAO,OAAOC,OAAOR,GAAsCjO,OAAS,GAoBzDqV,GAhBJoC,EAA0BC,WACxB5X,KAAK3B,MAAMM,MAAMkE,qBAEnB6U,EAA2BE,WACzB5X,KAAK3B,MAAMM,MAAMkE,qBAEnB8U,EAA0BvV,SAASlC,OACnCyX,EAA0BpV,WAAWrC,QACpCF,KAAK3B,MAAMM,MAAMkE,oBACd7C,KAAK3B,MAAMM,MAAM0L,iBACjBsN,EAA0B/U,SAC9B5C,KAAK6X,cAAcH,IAKqB1X,KAAK3B,MAAMM,MAAM0F,gBAE3DrE,KAAK+I,SAAS,CACZwM,YAAaA,IA5CD,MA8COvH,EACnBhO,KAAKiO,UAAU1P,WACfyB,KAAK3B,MAAMM,MAAM0F,gBACjBrE,KAAK3B,MAAMM,MAAMkL,UACjB7J,KAAK3B,MAAMM,MAAMkE,oBACjB7C,KAAK3B,MAAMM,MAAM0L,iBACjBrK,KAAKkO,WAAW5I,KAAKtF,MACrBmO,GArDY,mBA8CP2J,EA9CO,KA8CA3I,EA9CA,KAuDdnP,KAAKyO,oBAAsBqJ,EAC3B9X,KAAK3B,MAAMM,MAAMoZ,gBAAgBrH,SAASvB,M,gCAK1CnP,KAAK+I,SAAS,CAAEwL,gBAAiB,S,qDAGJhW,GAC7B,IAAIyZ,EAAUzZ,EAAW+H,KAAI,SAACxE,GAC5B,OAAOA,EAAEY,UAAUxC,UAErB,OAAO8D,KAAKE,IAAL,MAAAF,KAAI,YAAQgU,M,4CAInB,OACEhY,KAAK3B,MAAMM,MAAM8K,yBAChBzJ,KAAK0J,6BAGkCjE,IAApCzF,KAAKuX,6BACPvX,KAAKuX,2BAA6BvX,KAAKwX,+BACrCxX,KAAKiO,UAAU1P,cAShByB,KAAKuX,2BAA6B,KAAOvX,KAAK3B,MAAMM,MAAMsG,eAK1DyJ,OAAOxD,KAAKlL,KAAK0J,wBAAwBxJ,OAAS,KACnDF,KAAK3B,MAAMM,MAAMsG,e,oCA6ITyS,GACZ,OAAQ1X,KAAK3B,MAAMM,MAAMkE,oBAKrB,EAJA6U,EAA2BzV,WAAajC,KAAK3B,MAAMM,MAAMgC,cACvD,EACA+W,EAA2BtV,SAASlC,QACnCF,KAAK3B,MAAMM,MAAMgC,cAAgB+W,EAA2BzV,Y,iCAI1DoM,EAAqBjI,EAAG6R,EAAsBrT,GAEvD,GAAMyJ,EAAoBjN,SAAS+M,EAAnC,CAMA,IAAMuJ,EAA6BhJ,OAAOC,OACxCR,GACA,GAmBF,OAXEE,EAAoBuJ,WAAW5X,KAAK3B,MAAMM,MAAMkE,qBAChD6U,EAA2BE,WACzB5X,KAAK3B,MAAMM,MAAMkE,qBAEnB7C,KAAK6X,cAAcH,IAClBrJ,EAAoBjN,MAAQpB,KAAKiO,UAAU1P,WAAW,GAAG6C,OAGvC6W,EAAuBrT,GAC1C5E,KAAK3B,MAAMM,MAAM0F,gBAEQ+B,EAAIpG,KAAK3B,MAAMM,MAAM0F,mB,sCAGlCgK,EAAqBjI,EAAG9H,GAAY,IAAD,OACjD,OACE,oCACE,kBAAC,EAAD,CACEK,MAAOqB,KAAK3B,MAAMM,MAClB2F,KAAM+J,EACNnL,IAAK,IAAMkD,EACXzC,OAAQ3D,KAAKkY,sBACb5N,eACE+D,EAAoBjM,SAASlC,QAC5BF,KAAK3B,MAAMM,MAAMkE,oBACd7C,KAAK3B,MAAMM,MAAM0L,iBACjBgE,EAAoBzL,UACvByL,EAAoB9L,WAAWrC,OAAS,GAE3CwJ,uBAAwB1J,KAAK0J,uBAC7BpL,UAAWA,IAGZ+P,EAAoBjM,SAASkE,KAAI,SAACxD,EAAY8B,GAC7C,OAAO,EAAKuT,iBACV9J,EACAjI,EACA,EACAxB,EACA9B,MAGHuL,EAAoB9L,WAAWZ,MAAM,GAAI,GAAG2E,KAAI,SAACxD,EAAY8B,GAC5D,IAAIwT,EACF/J,EAAoBjM,SAASlC,QAC5B,EAAK7B,MAAMM,MAAMkE,oBACd,EAAKxE,MAAMM,MAAM0L,iBACjBgE,EAAoBzL,SAE1B,OAAO,EAAKuV,iBACV9J,EACAjI,EACAgS,EACAxT,EACA9B,S,uCAQRuL,EACAjI,EACA6R,EACArT,EACA9B,GAEA,IAAMgL,EAAgB9N,KAAKkO,WACzBG,EACAjI,EACA6R,EACArT,GALF,EAOgDsD,EAC9CpF,EACA9C,KAAKuD,MAAMgR,gBACXvU,KAAKuD,MAAM6E,cAVb,mBAOOiQ,EAPP,KAOmBC,EAPnB,KAOiCC,EAPjC,KAYA,OACE,kBAAC,EAAD,CACE5Z,MAAOqB,KAAK3B,MAAMM,MAClBuE,IAAK,YAAckD,EAAIxB,EACvBN,KAAMxB,EACNxE,UAAW0B,KAAKuD,MAAMjF,UACtBwD,EAAGgM,EACH7I,aAAcjF,KAAK3B,MAAMM,MAAMsG,aAC/BvB,MAAO1D,KAAK3B,MAAMM,MAAM0F,gBACxBb,MAAO6U,EACP5M,QAAS6M,EACT5M,OAAQ6M,EACRvN,sBAAuBhL,KAAKgL,sBAC5BtB,uBAAwB1J,KAAK0J,2B,iCAKxBwC,GAAO,IAAD,EACoBhE,EACjCgE,EAAKpJ,WACL9C,KAAKuD,MAAMgR,gBACXvU,KAAKuD,MAAM6E,cAJE,mBACRiQ,EADQ,KACIC,EADJ,KAOf,OACE,kBAAC,EAAD,CACE3Z,MAAOqB,KAAK3B,MAAMM,MAClBuE,IAAK,QAAUgJ,EAAKpJ,WAAWI,IAC/BgJ,KAAMA,EACN1I,MAAO6U,EACP5M,QAAS6M,EACTtN,sBAAuBhL,KAAKgL,sBAC5BmB,mBAAoBnM,KAAKmM,uB,wCA6CZ,IAAD,OAGhB,GAFAlN,QAAQC,IAAI,oBAERc,KAAK3B,MAAMM,MAAMwW,QAIrB,OAAOnV,KAAKiO,UAAU1P,WAAW+H,KAAI,SAAC+H,EAAqBjI,GACzD,OAAIiI,EAAoBjN,SAAS+M,EAE7B,kBAAC,IAAM2E,SAAP,CAAgB5P,IAAK,IAAMkD,GACxB,EAAKoS,gBAAgBnK,EAAqBjI,EAAG,EAAK7C,MAAMjF,YAItD,U,0CAKQ,IAAD,OAClB,IAAI0B,KAAK3B,MAAMM,MAAMwW,QAIrB,OAAOnV,KAAKyO,oBAAoBnI,KAAI,SAACyI,EAAQ3I,GAC3C,OAAO,EAAKqS,WAAW1J,Q,uCAKzB,GAAI/O,KAAK3B,MAAMM,MAAMwW,QACnB,OACE,kBAAC,OAAD,CACEjS,IAAI,UACJO,EAAG,IACHiV,SAAU,GACVhV,MAAO,IACPwB,MAAM,SACN5E,KAAK,iB,+BAMH,IAAD,OAKP,OAJArB,QAAQC,IAAI,gBAKV,oCACE,yBACEwQ,MAAO,CACLiE,SAAU,SACVxE,IAAK,EACLS,OAAQ,IACRD,WAAY,QAIZjM,MAAO1D,KAAKuD,MAAMgS,YAGlBoD,SAAU,SAGZ,kBAAC,EAAD,CACEha,MAAOqB,KAAK3B,MAAMM,MAClBuS,4BAA6B,SAACH,GAAD,OAC3B,EAAKG,4BAA4BH,IAEnC9C,UAAWjO,KAAKiO,YAGlB,kBAAC,QAAD,CACEnM,EAAG9B,KAAK3B,MAAMM,MAAMia,WACpBnV,EAAGzD,KAAK3B,MAAMwL,UACdnG,MAAO1D,KAAKuD,MAAMgS,YAClB5R,OAAQ3D,KAAK3B,MAAMM,MAAMkL,WAEzB,kBAAC,QAAD,CAAOgP,IAAK7Y,KAAKiU,WACdjU,KAAK8Y,oBACL9Y,KAAKkV,gCAKZ,kBAAC,QAAD,CACEpT,EAAG9B,KAAK3B,MAAMM,MAAMia,WACpBnV,GAAIzD,KAAK3B,MAAMM,MAAMkL,UACrBnG,MAAO1D,KAAKuD,MAAMgS,YAClB5R,OACE3D,KAAKkY,sBAAwBlY,KAAK3B,MAAMM,MAAMkM,kBAGhD,kBAAC,QAAD,CAAOgO,IAAK7Y,KAAK+T,UACd/T,KAAK+Y,iBACL/Y,KAAKgZ,oBAIV,kBAAC,EAAD,CAAmBra,MAAOqB,KAAK3B,MAAMM,QACrC,kBAAC6U,EAAD,CAAQ7U,MAAOqB,KAAK3B,MAAMM,a,GAxvBhB8C,aG9BEwX,QACW,cAA7BC,OAAOC,SAASC,UAEe,UAA7BF,OAAOC,SAASC,UAEhBF,OAAOC,SAASC,SAASC,MACvB,2D,WCdAC,GAAQC,IAAMC,MAAM,CACxBC,KAAMF,IAAMG,OACZzR,MAAOsR,IAAMI,UAAUJ,IAAMG,QAC7BnY,UAAWgY,IAAMK,QACjBzX,SAAUoX,IAAMK,QAChBC,gBAAiBN,IAAMK,QACvBE,WAAYP,IAAMK,UAEdG,GAAYR,IAAMC,MAAM,CAC5BQ,UAAWT,IAAMK,QACjBzX,SAAUoX,IAAMK,QAChB7R,MAAOwR,IAAMU,MAAMX,MAEfY,GAAaX,IAAMI,UACvBJ,IAAMC,MAAM,CACV1Z,aAAc,GACdqa,iBAAkBZ,IAAMK,QACxBhS,YAAa2R,IAAMjT,IAAIyT,OAGrBK,GAAab,IAAMC,MAAM,aAAc,CAC3CpJ,KAAMmJ,IAAMG,OACZrJ,OAAQkJ,IAAMK,UAqQHjb,GAjQD4a,IACTC,MAAM,CACL7R,WAAYuS,GACZ3H,YAAagH,IAAMc,SAASd,IAAMU,MAAMV,IAAMK,SAAU,CAAC,EAAG,MAC5DU,iBAAkB,GAClB7Q,wBAAwB,EACxB5G,qBAAqB,EACrBwH,iBAAkB,EAClBI,cAAc,EACdpG,gBAAiB,GACjBY,aAAc,EACd2T,WAAY,EACZ/O,UAAW,IACX0K,gBAAiB,EACjBgG,uBAAwB,IACxB1K,mBAAoB,GACpBjR,SAAU,aAEV6S,oBAAqB8H,IAAMc,SAASd,IAAMU,MAAMV,IAAMG,QAAS,CAAC,MAChE1I,uBAAwB,EACxBhQ,UAAWuY,IAAMc,SAASd,IAAMU,MAAMV,IAAMG,QAAS,IACrD5a,eAAgBya,IAAMc,SAASd,IAAMU,MAAMV,IAAMG,QAAS,IAE1D3Y,gBAAiBwY,IAAMc,SAASd,IAAMU,MAAMV,IAAMG,QAAS,IAE3DvJ,WAAYoJ,IAAMc,SAASD,GAAY,CAAEhK,KAAM,OAAQC,OAAQ,IAC/DE,uBAAwB,6BACxB1F,iBAAkB,GAElBsK,SAAS,EACTxP,qBAAsB4T,IAAMc,SAASd,IAAMU,MAAMV,IAAMG,QAAS,CAC9D,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,YAEF9T,mBAAoB2T,IAAMc,SAASd,IAAMU,MAAMV,IAAMG,QAAS,CAC5D,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,UACA,YAGFc,mBAAoB,IAErBC,SAAQ,SAACC,GA2GR,SAAS/Z,IACP,OAAO+Z,EAAKnI,YAAY,GAE1B,SAAS3R,IACP,OAAO8Z,EAAKnI,YAAY,GA8C1B,MAAO,CACL9S,cA7JF,SAAuBD,GACrBP,QAAQC,IAAI,uCAGZwb,EAAK/S,WAAa,KAElB+S,EAAK/S,WAAanI,GAwJlB0Q,kBAtJF,SAA2ByK,EAAUC,GACnC3b,QAAQC,IAAI,uBAAyByb,EAAW,MAAQC,GAExD,IA+HsBjK,EAAaoE,EA/H7BlU,EAAWF,IACXG,EAASF,IASf,GAJA+Z,EAAW3W,KAAKE,IAAI,EAAGF,KAAKoS,MAAMuE,KAClCC,EAAS5W,KAAKE,IAAI,EAAGF,KAAKoS,MAAMuE,EAAWD,EAAKJ,oBAGnCI,EAAKF,mBAAoB,CACpC,IAAIK,EAAcD,EAASF,EAAKF,mBAEhCG,EAAW3W,KAAKE,IAAI,EAAGyW,EAAWE,GAClCD,EAAS5W,KAAKE,IAAI,EAAG0W,EAASC,GAGhC,OAAIF,IAAa9Z,GAAY+Z,IAAW9Z,KA8GlB6P,EA7GLgK,EA6GkB5F,EA7GR6F,EA8G3BF,EAAKnI,YAAc,CAAC5B,EAAaoE,GA7G/B9V,QAAQC,IAAI,0BAA4Byb,EAAW,IAAMC,IAClD,IAgIT7C,gBA3HF,SAAyB+C,GACnB/O,OAAOC,SAAS8O,IAAiB/O,OAAOgP,cAAcD,KACxDJ,EAAK7Q,UAAYiR,EAAe,KA0HlCE,sBAnHF,SAA+B1G,GAC7BoG,EAAKnG,gBAAkBD,GAmHvBjL,gBAjHF,SAAyB4R,GACvBP,EAAKH,uBAAyBvW,KAAKE,IACjCwW,EAAKH,uBACLU,IA+GFC,iBA5GF,WACER,EAAKH,uBAAyB,GA4G9BxV,yBA1GF,SAAkCoW,GAChCT,EAAK7K,mBAAqBzM,OAAO+X,IA0GjCC,uBA3HF,SAAgCtX,GAC9B,IAAIuX,EAAYvX,EAAMqN,OAAOC,MAC7BsJ,EAAKrQ,iBAAmBrG,KAAKE,IAAI,EAAG6H,OAAOsP,KA0H3ClI,6BAzGF,WACEuH,EAAKjR,wBAA0BiR,EAAKjR,wBAyGpC8J,0BAvGF,WACEmH,EAAK7X,qBAAuB6X,EAAK7X,qBAuGjCwQ,mBArGF,WACEqH,EAAKjQ,cAAgBiQ,EAAKjQ,cAqG1BsI,aAnGF,SAAsBjP,GACpB4W,EAAKzV,aAAejB,KAAKE,IAAI,EAAG6H,OAAOjI,EAAMqN,OAAOC,SAmGpD4B,YAjGF,SAAqBlP,GACnB4W,EAAKrW,gBAAkBL,KAAKE,IAAI,EAAG6H,OAAOjI,EAAMqN,OAAOC,SAiGvDW,YA9FF,SAAqBjO,GAGfxG,EADF8B,iIAA8B0E,EAAMqN,OAAOC,MAAQ,oBAEnDnS,QAAQC,IAAI,4BAA8B4E,EAAMqN,OAAOC,OACvDsJ,EAAK9b,SAAWkF,EAAMqN,OAAOC,QA2F/BqF,gBAtFF,SAAyB6E,GACvB,OAAK3U,EAAY2U,EAAaZ,EAAK1Z,aACjC/B,QAAQC,IAAI,iCAAmCoc,GAC/CZ,EAAK1Z,UAAYsa,EACjBZ,EAAK3Z,gBAAkB,IAEhB,IAiFTyV,qBA7EF,SAA8B8E,GACvB3U,EAAY2U,EAAaZ,EAAK5b,kBACjCG,QAAQC,IAAI,4CAA8Coc,GAC1DZ,EAAK5b,eAAiBwc,IA2ExB5Z,kBAxEF,SAA2B6Z,GACzBtc,QAAQC,IAAI,sBAAwBqc,GACpCb,EAAK3Z,gBAAgBL,KAAK6a,IAwE1B5a,cACAC,YACA+R,iBArCF,SAA0BvC,EAAMC,GAE5BA,EADEA,EACOK,SAASL,GAET,EAEXqK,EAAKvK,WAAa,CAAEC,KAAMA,EAAMC,OAAQA,IAsCxCQ,YAvEF,WAEE,OAAO9E,OAAO2O,EAAK3E,yBAsEnBA,qBApEF,WAA4D,IAA9B/E,EAA6B,wDAAH,EAElDjT,EACF2c,EAAKjJ,oBACHT,GAA0B,EACtBA,EACA0J,EAAK1J,wBAEb,OAAOjT,GAAQ,KA6DfkT,0BA3DF,SAAmC7P,GACjCsZ,EAAK1J,uBAAyB5P,GA2D9B0U,uBAxDF,SAAgCrE,GAC9B,IAAI+J,EAAG,YAAO/J,GAEdiJ,EAAKjJ,oBAAsB+J,GAuD3B/D,WAxCF,SAAoBtF,GAClBuI,EAAKvF,QAAUhD,GAyCf8D,oBAvCF,SAA6B9D,GAC3BuI,EAAKF,mBAAqBrI,OAyC7BsJ,OAAM,SAACf,GAAD,MAAW,MAEWgB,OAAO,ICxRtCC,IAAS9F,OAAO,kBAAC,EAAD,CAAKlX,MAAOA,KAAWid,SAASC,eAAe,SF0HzD,kBAAmBC,WACrBA,UAAUC,cAAcC,MAAM1c,MAAK,SAAC2c,GAClCA,EAAaC,iB","file":"static/js/main.c9861315.chunk.js","sourcesContent":["/// a collection of functions to deal with URL requests\n\nexport function urlExists(dataName) {\n  if (dataName === \"\") {\n    return false;\n  } else {\n    //source: https://stackoverflow.com/a/22011478/3067894\n    var http = new XMLHttpRequest();\n      http.open(\"HEAD\", dataName, false);\n    http.send();\n    return http.status !== 404;\n  }\n}\n\nexport async function httpGetAsync(theUrl, callback) {\n  var xmlHttp = new XMLHttpRequest();\n  xmlHttp.onreadystatechange = function () {\n    if (xmlHttp.readyState === 4 && xmlHttp.status === 200)\n      callback(xmlHttp.responseText);\n  };\n  await xmlHttp.open(\"GET\", theUrl, true); // true for asynchronous\n  xmlHttp.send(null);\n}\n","import React from \"react\";\nimport { observe } from \"mobx\";\nimport { urlExists } from \"./URL\";\n\nclass PangenomeSchematic extends React.Component {\n  constructor(props) {\n    /*Only plain objects will be made observable. For non-plain objects it is considered the\n\t\t responsibility of the constructor to initialize the observable properties. Either use\n\t\t the @observable annotation or the extendObservable function.*/\n\n    super(props);\n    this.pathNames = [];\n    this.components = [];\n    this.jsonCache = {}; // URL keys, values are entire JSON file datas\n    // TODO: make jsonCache store React components and save them in mobx\n    // TODO: make FILO queue to remove old jsonCache once we hit max memory usage\n    this.nucleotides = []; // nucleotides attribute and its edges\n\n    this.loadIndexFile(this.props.store.jsonName); //initializes this.chunkIndex\n\n    //STEP #1: whenever jsonName changes, loadIndexFile\n    observe(this.props.store, \"jsonName\", () => {\n      this.loadIndexFile(this.props.store.jsonName);\n    });\n\n    // The FASTA files are read only when there are new chunks to read\n    observe(this.props.store.chunkFastaURLs, () => {\n      this.loadFasta();\n    });\n\n    //STEP #7: JsonCache causes processArray to update chunksProcessed\n    // observe(this.props.store.jsonCache,\n    //     this.processArray.bind(this));\n\n    // console.log(\"public \", process.env.PUBLIC_URL ) //PUBLIC_URL is empty\n  }\n  componentDidUpdate() {\n    // console.log(\"#components: \" + this.components);\n  }\n\n  loadIndexFile(jsonFilename) {\n    console.log(\"STEP #1: whenever jsonName changes, loadIndexFile\");\n\n    let indexPath =\n      process.env.REACT_APP_FETCH + jsonFilename + \"/bin2file.json\";\n    console.log(\"loadIndexFile - START reading\", indexPath);\n    return fetch(indexPath)\n      .then((res) => res.json())\n      .then((json) => {\n        console.log(\"loadIndexFile - END reading\", indexPath);\n\n        //STEP #2: chunkIndex contents loaded\n        this.props.store.setChunkIndex(json);\n      });\n  }\n\n  jsonFetch(filepath) {\n    if (!filepath)\n      throw new Error(\n        \"No filepath given. Ensure chunknames in bin2file.json are correct.\"\n      );\n    console.log(\"Fetching\", filepath);\n    return fetch(filepath).then((res) => res.json());\n  }\n\n  loadJsonCache(url, data) {\n    console.log(\"STEP #6: fetched chunks go into loadJsonCache\");\n\n    if (data.json_version !== 16) {\n      throw MediaError(\n        \"Wrong Data JSON version: was expecting version 16, got \" +\n        data.json_version +\n        \".  \" +\n        \"This version added compressedX.  \" + // KEEP THIS UP TO DATE!\n          \"Using a mismatched data file and renderer will cause unpredictable behavior,\" +\n          \" instead generate a new data file using github.com/graph-genome/component_segmentation.\"\n      );\n    }\n    this.jsonCache[url] = data;\n    this.pathNames = data.path_names; //TODO: in later JSON versions path_names gets moved to bin2file.json\n      console.log(this.pathNames.length, \" path names loaded\")\n    this.processArray();\n  }\n\n  loadFasta() {\n    console.log(\"loadFasta\");\n\n    // Clear the nucleotides information\n    this.nucleotides = [];\n\n    // This loop will automatically cap out at the fasta file corrisponding to the last loaded chunk\n    for (let path_fasta of this.props.store.chunkFastaURLs) {\n      if (urlExists(path_fasta)) {\n        //console.log(\"loadFasta - START: \", path_fasta);\n\n        fetch(path_fasta)\n          .then((response) => {\n            return response.text();\n          })\n          .then((text) => {\n            const sequence = text\n              .replace(/.*/, \"\")\n              .substr(1)\n              .replace(/[\\r\\n]+/gm, \"\");\n\n            //split into array of nucleotides\n            this.nucleotides.push(...sequence);\n\n            console.log(\"loadFasta - END: \", path_fasta);\n          });\n      }\n    }\n  }\n\n  /**Parses beginBin to endBin range, returns false if new file needed.\n   * This calculates the pre-render for all contiguous JSON data.\n   * State information is stored in store.chunksProcessed.\n   * Checks if there's new available data to pre-render in processArray()\n   * run through list of urls in order and see if we have data to load.**/\n  processArray() {\n    //TODO: make processArray parallelized by placing outputs in a Key Map and rendering out of order\n    console.log(\n      \"STEP #7: JsonCache causes processArray to update chunksProcessed\"\n    );\n    let store = this.props.store;\n    let [beginBin, endBin] = [store.getBeginBin(), store.getEndBin()];\n\n    if (\n      store.chunksProcessed.length === 0 ||\n      store.chunksProcessed[0] !== this.props.store.chunkURLs[0]\n    ) {\n      this.components = []; // clear all pre-render data\n    }\n    // may have additional chunks to pre-render\n    console.log(\"processArray - parsing components \", beginBin, \" - \", endBin);\n\n    for (let urlIndex = 0; urlIndex < store.chunkURLs.length; urlIndex++) {\n      //if end of pre-render is earlier than end of contiguous available chunks, process new data\n      if (urlIndex >= store.chunksProcessed.length) {\n        //only process if data is available\n        if (store.chunkURLs[urlIndex] in this.jsonCache) {\n          let url = store.chunkURLs[urlIndex];\n          let jsonChunk = this.jsonCache[url];\n\n          /*console.log(\n            \"processArray - jsonChunk.components[0].x: \" +\n              jsonChunk.components[0].x\n          );*/\n\n            // At the moment, the index is used as a rank of the component, then it has to be progressive between chunks\n          const num_components_already_loaded =\n              this.components.length > 0\n                  ? this.components[this.components.length - 1].index + 1\n                  : 0;\n          for (let [index, component] of jsonChunk.components.entries()) {\n            if (component.first_bin > 0) {\n              let componentItem = new Component(\n                component,\n                num_components_already_loaded + index\n              );\n              this.components.push(componentItem); //TODO: concurrent modification?\n              //if (component.last_bin >= beginBin) { NOTE: we are now reading in whole chunk, this may place\n              //xOffset further right than it was intended when beginBin > chunk.first_bin\n            }\n          }\n          store.addChunkProcessed(url);\n        } else {\n          //we've run into a contiguous chunk that is not available yet\n          return false;\n        }\n      }\n    }\n\n    console.log(\n      \"processArray\",\n      store.chunksProcessed[0],\n      store.chunksProcessed.slice(-1)[0],\n      \"out of\",\n      this.props.store.chunkURLs.length,\n      \"chunks\"\n    );\n    //console.log(this.props)\n\n    return true; //store.chunksProcessed.length > 0;\n  }\n}\n\nclass Component {\n  //extends React.Component{\n  constructor(component, index) {\n    this.columnX = component.x;\n    this.compressedColumnX = component.compressedX;\n\n    this.index = index;\n    this.firstBin = component.first_bin;\n    this.lastBin = component.last_bin;\n\n    this.arrivals = [];\n    for (let arrival of component.arrivals) {\n      this.arrivals.push(new LinkColumn(arrival));\n    }\n    this.departures = [];\n    for (let departure of component.departures) {\n      //don't slice off adjacent here\n      this.departures.push(new LinkColumn(departure));\n    }\n\n    this.relativePixelX = -1;\n\n    // deep copy of occupants\n    this.occupants = component.occupants; //Array.from(\n    this.matrix = component.matrix; // Array.from(\n    this.num_bin = this.lastBin - this.firstBin + 1;\n  }\n\n  getColumnX(useWidthCompression) {\n    return useWidthCompression ? this.compressedColumnX : this.columnX;\n  }\n}\n\nclass LinkColumn {\n  constructor(linkColumn) {\n    this.upstream = linkColumn.upstream;\n    this.downstream = linkColumn.downstream;\n    this.participants = linkColumn.participants; //new Set\n    this.key = this.edgeToKey();\n  }\n  edgeToKey() {\n    /**downstream and upstream are always in the same orientation regardless of if it is a\n     * departing LinkColumn or an arriving LinkColumn.**/\n    return (\n      String(this.downstream).padStart(13, \"0\") +\n      String(this.upstream).padStart(13, \"0\")\n    );\n  }\n}\n\nexport default PangenomeSchematic;\n","import React from \"react\";\nimport {Rect} from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nexport class ConnectorRect extends React.Component {\n  state = {\n    color: this.props.color,\n  };\n\n  render() {\n    return (\n      <Rect\n        x={this.props.x}\n        y={this.props.y}\n        width={this.props.width}\n        height={this.props.height || 1}\n        fill={this.state.color}\n      />\n    );\n  }\n}\n\nConnectorRect.propTypes = {\n  x: PropTypes.number,\n  y: PropTypes.number,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  store: PropTypes.node,\n  color: PropTypes.node,\n};\n","import React from \"react\";\nimport {Rect, Text} from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nexport class MatrixCell extends React.Component {\n    onHover(event) {\n        //tooltip: this.props.item.mean_pos\n\n        // An example: Path_name, Coverage: 0.23, Inversion: 0.0, Pos: 2365-27289\n\n        //TODO: calculate relative X and select item from this.props.range\n        let relColumnX = Math.floor(Math.max(0, event.evt.layerX - this.props.x) / this.props.store.pixelsPerColumn);\n        //console.log(event, this.props.range, relColumnX);\n\n\n        let item = this.props.range[Math.min(this.props.range.length - 1, relColumnX)];\n        let tooltipContent = '\"';\n        tooltipContent +=\n            this.props.pathName +\n            '\"\\nCoverage: ' +\n            item[0] +\n            \"\\nInversion: \" +\n            item[1] +\n            \"\\nPos: \";\n\n        const ranges = item[2];\n        for (let j = 0; j < ranges.length; j++) {\n            let start = ranges[j][0];\n            let end = ranges[j][1];\n            if (j === 0) {\n                tooltipContent += start + \"-\" + end;\n            } else {\n                tooltipContent += \",\" + start + \"-\" + end;\n            }\n        }\n        this.props.store.updateCellTooltipContent(tooltipContent); //item[2] is array of ranges\n    }\n\n    onLeave() {\n        this.props.store.updateCellTooltipContent(\"\"); // we don't want any tooltip displayed if we leave the cell\n    }\n\n    /**Reduced number of Text elements generated for inversions,\n     * mouse events restored**/\n    inversionText(inverted) {\n        if (this.props.store.pixelsPerRow > 9 && inverted) {\n            return (\n                <Text\n                    x={this.props.x}\n                    y={this.props.y}\n                    width={this.props.width}\n                    height={this.props.height || 1}\n                    align={\"center\"}\n                    verticalAlign={\"center\"}\n                    text={inverted ? \"<\" : \" \"}\n                    onMouseMove={this.onHover.bind(this)}\n                    onMouseLeave={this.onLeave.bind(this)}\n                />\n            );\n        } else {\n            return null;\n        }\n    }\n\n    render() {\n        if (this.props.range === undefined || this.props.range.length === 0) {\n            return null; //giving up\n        }\n        const inverted = this.props.range[0][1] > 0.5;\n        const copyNumber = this.props.range[0][0];\n\n        let color = \"#838383\";\n\n        if (copyNumber > 1 && !inverted) {\n            // 11 items is number of colors in copyNumberColorArray\n            if (copyNumber < 10) {\n                color = this.props.store.copyNumberColorArray[copyNumber];\n            } else {\n                color = this.props.store.copyNumberColorArray[10];\n            }\n        }\n\n        if (inverted) {\n            // 11 items is number of colors in invertedColorArray\n            if (copyNumber < 10) {\n                color = this.props.store.invertedColorArray[copyNumber];\n            } else {\n                color = this.props.store.invertedColorArray[10];\n            }\n        }\n\n        // TODO: if possible, use HTML/CSS to write the '<', avoiding the <Text />s rendering, therefore improving the performance\n        return (\n            <>\n                <Rect\n                    x={this.props.x}\n                    y={this.props.y}\n                    width={this.props.width}\n                    height={this.props.height || 1}\n                    fill={color}\n                    onMouseMove={this.onHover.bind(this)}\n                    onMouseLeave={this.onLeave.bind(this)}\n                />\n                {this.inversionText(inverted)}\n            </>\n        );\n    }\n}\n\nMatrixCell.propTypes = {\n    store: PropTypes.object,\n    range: PropTypes.object,\n    x: PropTypes.number,\n    y: PropTypes.number,\n    width: PropTypes.number,\n    height: PropTypes.number,\n    color: PropTypes.node,\n    pathName: PropTypes.node,\n};\n\nexport class SpanCell extends React.Component {\n    constructor(props) {\n        super(props);\n        this.width = props.row.length;\n        //https://github.com/graph-genome/Schematize/issues/87\n        //Sparse matrix includes the relative columns for each bin inside a component\n        //Columns are not necessarily contiguous, but follow the same order as `row`\n    }\n\n    render() {\n        if (!this.props.row.length || !this.props.iColumns.length) {\n            return null;\n        }\n        let prev = this.props.iColumns[0] - 1;\n        let spans = [];\n        let newSpan = {width: 0, x: this.props.iColumns[0], range: []}\n        for (let i = 0; i < this.props.iColumns.length; i++) {\n            let column = this.props.iColumns[i];\n            if (column === prev + 1) {//contiguous\n                newSpan.width += 1;\n                newSpan.range.push(this.props.row[i]);\n            } else {//non-contiguous\n                spans.push(newSpan)\n                //create new newSpan\n                newSpan = {width: 1, x: column, range: [this.props.row[i]]};\n            }\n            prev = column;\n        }\n        spans.push(newSpan)\n        return <>\n            {spans.map((span) =>\n            <MatrixCell\n                key={\"span\" + this.props.rowNumber + \",\" + span.x}\n                range={span.range}\n                store={this.props.store}\n                pathName={this.props.pathName}\n                x={this.props.x + span.x * this.props.store.pixelsPerColumn}\n                y={this.props.y}\n                rowNumber={this.props.rowNumber}\n                width={span.width * this.props.store.pixelsPerColumn}\n                height={this.props.store.pixelsPerRow}\n            />)}\n        </>;\n    }\n}\n\nMatrixCell.propTypes = {\n    row: PropTypes.node,\n    iColumns: PropTypes.node,\n    parent: PropTypes.object,\n    store: PropTypes.object,\n    pathName: PropTypes.node,\n    y: PropTypes.number,\n    rowNumber: PropTypes.number,\n    verticalRank: PropTypes.number,\n};\n","export const zip = (arr, ...arrs) => {\n  /*Credit: https://gist.github.com/renaudtertrais/25fc5a2e64fe5d0e86894094c6989e10*/\n  return arr.map((val, i) => arrs.reduce((a, arr) => [...a, arr[i]], [val]));\n};\n\nexport function sum(a, b) {\n  return a + b;\n}\n\nexport function arraysEqual(A, B) {\n  return (\n    (A.length === 0 && B.length === 0) ||\n    (A.length === B.length && A.every((e) => B.indexOf(e) > -1))\n  );\n}\n\nexport function areOverlapping(startA, endA, startB, endB) {\n  if (startB < startA) {\n    return endB >= startA;\n  } else if (startB > startA) {\n    return startB <= endA;\n  } else {\n    return true;\n  }\n}\n\nexport function calculateEndBinFromScreen(beginBin, endBin, selZoomLev, store) {\n  let chunkURLarray = [];\n  let fileArrayFasta = [];\n\n  let level = store.chunkIndex.zoom_levels.get(selZoomLev);\n  //this loop will automatically cap out at the last bin of the file\n  for (let ichunk = 0; ichunk < level.files.length; ichunk++) {\n    // The \"x\" info is not here\n    let chunk = level.files[ichunk];\n    if (areOverlapping(beginBin, endBin, chunk.first_bin, chunk.last_bin)) {\n      chunkURLarray.push(chunk[\"file\"]);\n      if (chunk.fasta !== null) {\n        fileArrayFasta.push(chunk.fasta);\n      }\n    }\n  }\n\n  // store.updateBeginEndBin(b, b + widthInCells);\n  //TODO the logic in let width = could be much more complex by looking at\n  //width of components and whether various settings are on.  The consequence\n  //of overestimating widthInCells is to make the shift buttons step too big\n  return [chunkURLarray, fileArrayFasta];\n}\n\nexport function range(start, end) {\n  return [...Array(1 + end - start).keys()].map((v) => start + v);\n}\n\nexport function stringToColorAndOpacity(\n  linkColumn,\n  highlightedLinkColumn,\n  selectedLink\n) {\n  const whichLinkToConsider = selectedLink\n    ? selectedLink\n    : highlightedLinkColumn;\n\n  const colorKey = (linkColumn.downstream + 1) * (linkColumn.upstream + 1);\n  if (whichLinkToConsider) {\n    // When the mouse in on a Link, all the other ones will become gray and fade out\n    let matchColor =\n      (whichLinkToConsider.downstream + 1) * (whichLinkToConsider.upstream + 1);\n    // Check if the mouse in on a Link (highlightedLinkColumn) or if a Link was clicked (selectedLink)\n    if ((!highlightedLinkColumn && !selectedLink) || colorKey === matchColor) {\n      return [\n        stringToColourSave(colorKey),\n        1.0,\n        highlightedLinkColumn || selectedLink ? \"black\" : null,\n      ];\n    } else {\n      return [\"gray\", 0.3, null];\n    }\n  } else {\n    return [stringToColourSave(colorKey), 1.0, null];\n  }\n}\n\nexport function stringToColourSave(colorKey) {\n  colorKey = colorKey.toString();\n  let hash = 0;\n  for (let i = 0; i < colorKey.length; i++) {\n    hash = colorKey.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  let colour = \"#\";\n  for (let j = 0; j < 3; j++) {\n    const value = (hash >> (j * 8)) & 0xff;\n    colour += (\"00\" + value.toString(16)).substr(-2);\n  }\n  return colour;\n}\n","/* eslint-disable require-jsdoc */\nimport React from \"react\";\nimport {Rect} from \"react-konva\";\nimport {ConnectorRect} from \"./ComponentConnectorRect\";\nimport {SpanCell} from \"./SpanCell\";\nimport PropTypes from \"prop-types\";\nimport {sum} from \"./utilities\";\n\nexport function compress_visible_rows(components) {\n  /*Returns a Map with key of the original row number and value of the new, compressed row number.\n   * Use this for y values of occupancy and LinkColumn cells.  */\n  let all_visible = new Set();\n  for (let c of components) {\n      for (let row of c.occupants) {\n          all_visible.add(row);\n      }\n  }\n  let sorted = Array.from(all_visible).sort();\n  let row_mapping = {};\n  for (let [count, index] of sorted.entries()) {\n      row_mapping[index] = count;\n  }\n  return row_mapping;\n}\n\n\nclass ComponentRect extends React.Component {\n  state = {\n    color: \"lightgray\",\n  };\n\n  handleClick = () => {\n    if (this.state.color === \"lightgray\") {\n      this.setState({ color: \"lightblue\" });\n    } else if (this.state.color === \"lightblue\") {\n      this.setState({ color: \"lightgray\" });\n    }\n  };\n\n  renderMatrix() {\n    let parts = this.props.item.matrix.map((entry, vertical_rank) => {\n      let row_n = entry[0];\n        return this.renderMatrixRow(entry[1], vertical_rank, row_n);\n    });\n      this.props.store.updateMaxHeight(this.props.item.occupants.length); //Set max observed occupants in mobx store for render height\n    return <>{parts}</>;\n  }\n\n    renderMatrixRow(entry, verticalRank, uncompressed_y) {\n        let this_y = verticalRank;\n        if (!this.props.store.useVerticalCompression) {\n            if (!this.props.compressed_row_mapping.hasOwnProperty(uncompressed_y)) {\n                return null; // we need compressed_y and we don't have it.  give up\n            }\n            this_y = this.props.compressed_row_mapping[uncompressed_y];\n        }\n        return <SpanCell\n            key={\"occupant\" + uncompressed_y}\n            row={entry[1]}\n            iColumns={entry[0]}\n            parent={this.props.item}\n            store={this.props.store}\n            pathName={this.props.pathNames[uncompressed_y]}\n            x={this.props.item.relativePixelX +\n            this.props.item.arrivals.length * this.props.store.pixelsPerColumn}\n            y={this_y * this.props.store.pixelsPerRow +\n            this.props.store.topOffset}\n            rowNumber={uncompressed_y}\n            verticalRank={verticalRank}\n        />\n    }\n\n  renderAllConnectors() {\n    const departures = this.props.item.departures;\n    let connectorsColumn = departures.slice(-1)[0];\n    if (connectorsColumn !== undefined) {\n      //count starts at the sum(sum(departure columns)) so that it's clear\n      // adjacent connectors are alternatives to LinkColumns\n      //offset the y to start below link columns when using vertical compression\n      let yOffset = departures.slice(0, -1)\n          .map((column) => {\n            return column.participants.length;\n          })\n          .reduce(sum, 0); // sum of trues in all columns\n      return (\n        <>\n          {connectorsColumn.participants.map((uncompressed_row) => {\n            yOffset++;// only used in vertical compression\n            return this.renderComponentConnector(yOffset, uncompressed_row);\n          })}\n        </>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  renderComponentConnector(verticalRank, uncompressedRow) {\n    let component = this.props.item;\n    // x is the (num_bins + num_arrivals + num_departures)*pixelsPerColumn\n    const x_val =\n      component.relativePixelX +\n      (component.arrivals.length +\n        (this.props.store.useWidthCompression\n          ? this.props.store.binScalingFactor\n          : component.num_bin) +\n        component.departures.length -\n        1) *\n        this.props.store.pixelsPerColumn;\n    let this_y = verticalRank;\n    if (!this.props.store.useVerticalCompression) {\n      this_y = this.props.compressed_row_mapping[uncompressedRow];\n    }\n    return (\n      <ConnectorRect\n          key={\"connector\" + uncompressedRow}\n          x={x_val}\n          y={this.props.store.topOffset + this_y * this.props.store.pixelsPerRow}\n          width={this.props.store.pixelsPerColumn} //Clarified and corrected adjacent connectors as based on pixelsPerColumn width #9\n          height={this.props.store.pixelsPerRow}\n          color={\"#464646\"}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <>\n        <Rect\n          x={this.props.item.relativePixelX}\n          y={this.props.store.topOffset}\n          key={this.state.key + \"R\"}\n          width={this.props.widthInColumns * this.props.store.pixelsPerColumn}\n          height={this.props.height - 2} //TODO: change to compressed height\n          fill={this.state.color}\n          onClick={this.handleClick}\n        />\n        {!this.props.store.useWidthCompression ? this.renderMatrix() : null}\n        {this.props.store.useConnector ? this.renderAllConnectors() : null}\n      </>\n    );\n  }\n}\n\nComponentRect.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.object,\n  compressed_row_mapping: PropTypes.object,\n  widthInColumns: PropTypes.number,\n  height: PropTypes.number,\n  pathNames: PropTypes.node,\n};\n\nexport default ComponentRect;\n","import React from \"react\";\nimport { Text } from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nclass ComponentNucleotides extends React.Component {\n  renderMatrixRow() {\n    const parent = this.props.item;\n    const x_val =\n      parent.relativePixelX +\n      parent.arrivals.length * this.props.store.pixelsPerColumn;\n\n    //console.log('x_val: ' + x_val)\n\n    var listOfObjects = [];\n    for (var x = 0; x < this.props.item.num_bin; x++) {\n      listOfObjects.push(\n        <Text\n          key={\"nuc_text\" + x}\n          x={x_val + x * this.props.store.pixelsPerColumn}\n          y={this.props.store.topOffset - this.props.store.nucleotideHeight}\n          text={this.props.nucleotides[x]}\n          align=\"center\"\n          height={this.props.store.nucleotideHeight}\n          width={this.props.store.pixelsPerColumn}\n        />\n      );\n    }\n    return listOfObjects;\n  }\n\n  render() {\n    //console.log('ComponentNucleotides - render')\n    return this.renderMatrixRow();\n  }\n}\n\nComponentNucleotides.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.object,\n};\n\nexport default ComponentNucleotides;\n","import React from \"react\";\nimport {Rect} from \"react-konva\";\nimport PropTypes from \"prop-types\";\nimport {range} from \"./utilities\";\n\nclass LinkColumn extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseOut = this.handleMouseOut.bind(this);\n    this.handleMouseOver = this.handleMouseOver.bind(this);\n  }\n  handleMouseOver() {\n    this.props.updateHighlightedNode(this.props.item);\n  }\n  handleMouseOut() {\n    this.props.updateHighlightedNode(null);\n  }\n  linkCells() {\n      if (!this.props.store.useVerticalCompression) { //regular layout\n          return this.props.item.participants.map((pathIndex) =>\n              this.props.compressed_row_mapping[pathIndex] * this.props.store.pixelsPerRow);\n      }\n      //else, just stack each up at the top of the screen\n      return range(0, this.props.item.participants.length).map(\n          (y) => y * this.props.store.pixelsPerRow);\n  }\n  componentDidMount() {\n    this.setState({\n      color: this.props.color,\n    });\n  }\n  render() {\n    const contents = this.linkCells();\n    return (\n      <>\n        {contents.map((y_coord, d) => {\n          return (\n            <Rect\n              key={\"dot\" + d}\n              x={this.props.x}\n              y={\n                this.props.store.topOffset +\n                y_coord\n              }\n              width={this.props.store.pixelsPerColumn}\n              height={this.props.store.pixelsPerRow}\n              fill={this.props.color}\n              opacity={this.props.opacity}\n              stroke={this.props.stroke}\n              // onClick={this.handleClick}\n              onMouseOver={this.handleMouseOver}\n              onMouseOut={this.handleMouseOut}\n            />\n          );\n        })}\n      </>\n    );\n  }\n}\n\nLinkColumn.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.object,\n  updateHighlightedNode: PropTypes.func,\n  compressed_row_mapping: PropTypes.object,\n  x: PropTypes.node,\n  column: PropTypes.node,\n  color: PropTypes.node,\n};\n\nexport default LinkColumn;\n","import React from \"react\";\nimport { Arrow } from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nfunction isInfinity(n) {\n  return !Number.isFinite(n);\n}\n\nclass LinkArrow extends React.Component {\n  /** Serves as a contract to store visual layout information**/\n  constructor(props) {\n    super(props);\n    this.arrowXCoord = null;\n    this.points = [];\n    this.handleMouseOut = this.handleMouseOut.bind(this);\n    this.handleMouseOver = this.handleMouseOver.bind(this);\n  }\n  componentDidUpdate() {\n    //this.calculatePoints();\n  }\n\n  calculatePoints() {\n    /*Translates the LinkRecord coordinates into pixels and defines the curve shape.\n     * I've spent way too long fiddling with these numbers at different pixelsPerColumn\n     * I suggest you don't fiddle with them unless you plan on nesting the React\n     * Components to ensure that everything is relative coordinates.*/\n    let link = this.props.link;\n    this.arrowXCoord = this.props.link.xArrival;\n    let absDepartureX = this.props.link.xDepart;\n    // put in relative coordinates to arriving LinkColumn\n    let departureX =\n      absDepartureX - this.arrowXCoord + this.props.store.pixelsPerColumn / 2;\n    let arrX = this.props.store.pixelsPerColumn / 2;\n    let bottom = -2; //-this.props.store.pixelsPerColumn;\n    let turnDirection = departureX < 0 ? -1 : 1;\n    const departOrigin = [departureX, this.props.store.pixelsPerColumn - 2];\n    const departCorner = [departureX - turnDirection, -link.elevation + 2];\n    let departTop = [departureX - turnDirection * 6, -link.elevation];\n    let arriveTop = [arrX + turnDirection * 6, -link.elevation];\n    let arriveCorner = [arrX + turnDirection, -link.elevation + 2]; // 1.5 in from actual corner\n    const arriveCornerEnd = [arrX, -5];\n    this.points = [\n      departOrigin[0],\n      departOrigin[1],\n      departCorner[0],\n      departCorner[1],\n      departTop[0],\n      departTop[1],\n      arriveTop[0],\n      arriveTop[1],\n      arriveCorner[0],\n      arriveCorner[1],\n      arriveCornerEnd[0],\n      arriveCornerEnd[1],\n      arrX,\n      -1,\n    ];\n    if (Math.abs(departureX) <= this.props.store.pixelsPerColumn) {\n      // FIXME Small distances, usually self loops\n      if (link.isArrival) {\n        this.points = [\n          arrX,\n          -10, //-link.elevation - 4,\n          arrX,\n          bottom,\n        ];\n      } else {\n        this.points = [\n          departOrigin[0],\n          bottom + this.props.store.pixelsPerColumn,\n          departOrigin[0],\n          -5,\n        ]; //-link.elevation-this.props.store.pixelsPerColumn*2,];\n      }\n    }\n    if (this.points.some(isNaN) || this.points.some(isInfinity)) {\n      console.log(\"Some points are NaN: \" + this.points);\n    }\n  }\n\n  render() {\n    // if(this.arrowXCoord === null){\n    this.calculatePoints();\n    // }\n    /*upstream={this.props.upstream}\n        downstream={this.props.downstream}\n        */\n\n    return (\n      <Arrow\n        x={this.arrowXCoord}\n        y={this.props.store.topOffset - 10}\n        width={this.props.store.pixelsPerColumn}\n        points={this.points}\n        bezier={false}\n        strokeWidth={this.props.store.pixelsPerColumn}\n        fill={this.props.color}\n        stroke={this.props.color}\n        opacity={this.props.opacity}\n        stroke-opacity={this.props.opacity}\n        pointerLength={1}\n        pointerWidth={1}\n        tension={1 / 3}\n        onMouseOver={this.handleMouseOver}\n        onMouseOut={this.handleMouseOut}\n        onClick={this.handleClick}\n        // lineCap={'round'}\n      />\n    );\n  }\n\n  handleMouseOver = () => {\n    this.props.updateHighlightedNode(this.props.link.linkColumn);\n  };\n  handleMouseOut = () => {\n    this.props.updateHighlightedNode(null);\n  };\n  handleClick = (event) => {\n    console.log(\"Click\", event, this.props.link);\n\n    this.props.updateSelectedLink(this.props.link.linkColumn);\n  };\n}\n\nLinkArrow.propTypes = {\n  store: PropTypes.object,\n  link: PropTypes.object,\n  color: PropTypes.node,\n};\n\nexport default LinkArrow;\n","export class LinkRecord {\n  constructor(linkColumn, xCoordArrival = 0, xCoordDeparture = 0, isArrival) {\n    this.linkColumn = linkColumn;\n    if (linkColumn === undefined) {\n      console.log(linkColumn, xCoordArrival, xCoordDeparture);\n    }\n    this.xArrival = xCoordArrival;\n    this.xDepart = xCoordDeparture;\n    this.elevation = 10;\n    this.isArrival = isArrival;\n  }\n  distance() {\n    return Math.abs(this.xDepart - this.xArrival) || 1;\n  }\n}\n\nexport function calculateLinkCoordinates(\n  schematic,\n  pixelsPerColumn,\n  topOffset,\n  useWidthCompression,\n  binScalingFactor,\n  leftXStart,\n  index_to_component_to_visualize_dict\n) {\n  //leftXStart is necessary as a method at the moment\n  /** calculate the x coordinates of all components\n   * calculate the x coordinates of all arrivals and departures */\n\n  /* In this dictionary the key is the global unique paddedKey created by @edgetoKey.\n    The value is a list of size 2:\n    1. Element: the x-coordinate of the arrival link column\n    2. Element: the x-coordinate of the corresponding departure link column */\n  let linkToXMapping = {}; //(paddedKey): [arrivalX, departureX]\n\n  for (let i = 0; i < schematic.length; i++) {\n    let schematizeComponent = schematic[i];\n\n    if (schematizeComponent.index in index_to_component_to_visualize_dict) {\n      //schematizeComponent.relativePixelX = leftXStart(schematizeComponent, i, 0, 0);\n      //ARRIVALS: Calculate all X\n      for (let j = 0; j < schematizeComponent.arrivals.length; j++) {\n        let arrival = schematizeComponent.arrivals[j];\n        let xCoordArrival = leftXStart(schematizeComponent, i, 0, j);\n        let paddedKey = arrival.key;\n        if (!(paddedKey in linkToXMapping)) {\n          //place holder value, go as far right as possible\n          // TODO place holder value in the same place\n          linkToXMapping[paddedKey] = new LinkRecord(\n            arrival,\n            xCoordArrival,\n            xCoordArrival,\n            true\n          );\n        } else {\n          linkToXMapping[paddedKey].xArrival = xCoordArrival; // set with real value\n        }\n      }\n      //DEPARTURES: Calculate all X\n      for (let k = 0; k < schematizeComponent.departures.length - 1; k++) {\n        let departure = schematizeComponent.departures[k];\n        let xCoordDeparture = leftXStart(\n          schematizeComponent,\n          i,\n          schematizeComponent.arrivals.length +\n            (useWidthCompression\n              ? binScalingFactor\n              : schematizeComponent.num_bin),\n          k\n        );\n        let paddedKey = departure.key;\n        if (!(paddedKey in linkToXMapping)) {\n          //place holder value, go as far left as possible\n          // linkToXMapping[paddedKey] = [this.state.actualWidth + 100, xCoordDeparture]\n          linkToXMapping[paddedKey] = new LinkRecord(\n            departure,\n            xCoordDeparture,\n            xCoordDeparture,\n            false\n          );\n        } else {\n          linkToXMapping[paddedKey].xDepart = xCoordDeparture; // set real value\n        }\n      }\n    }\n  }\n  return calculateLinkElevations(linkToXMapping, pixelsPerColumn, topOffset);\n}\n\nfunction calculateLinkElevations(linkToXmapping, pixelsPerColumn, topOffset) {\n  /**Starting with the shortest links, claim a spot of elevation to place the link in.\n   * As the links get bigger, you take the max() of the range of the link and add 1.\n   * This claims the \"air space\" for that link to travel through without colliding with anything.\n   * The longest link should end up on top.  We'll probably need a \"link gutter\" maximum to keep\n   * this from getting unreasonably tall.**/\n  let distanceSortedLinks = Object.values(linkToXmapping).sort(\n    (a, b) => a.distance() - b.distance()\n  );\n  let elevationOccupied = reserveElevationAirSpace(\n    distanceSortedLinks,\n    pixelsPerColumn,\n    topOffset\n  );\n  let top = Math.max(...elevationOccupied) + pixelsPerColumn * 3;\n  return [distanceSortedLinks, top];\n}\n\nfunction reserveElevationAirSpace(\n  distanceSortedLinks,\n  pixelsPerColumn,\n  topOffset\n) {\n  /* Set up an array of zeros, then gradually fill it with height stacking\n   * @Simon this section is largely done, it just needs a sorted distanceSortedLinks as input*/\n  let length = Math.max(\n    0,\n    ...distanceSortedLinks.map((x) => Math.max(x.xDepart, x.xArrival))\n  ); //this.props.endBin - this.props.beginBin;\n  let elevationOccupied = new Array(length).fill(15);\n  for (let record of distanceSortedLinks) {\n    let linkBegin = Math.max(0, Math.min(record.xArrival, record.xDepart));\n    let linkEnd = Math.max(record.xArrival, record.xDepart, linkBegin + 1);\n    let range = elevationOccupied.slice(linkBegin, linkEnd + 1);\n    let elevation = range.length ? Math.max(...range) : 10;\n    if (isNaN(elevation) || !Number.isFinite(elevation)) {\n      console.log(\n        \"Bad elevation\",\n        record,\n        linkBegin,\n        linkEnd,\n        range,\n        elevationOccupied\n      );\n    }\n    const stillSmall = true; //elevation < topOffset / 3;\n    elevation += stillSmall ? pixelsPerColumn : pixelsPerColumn / 4;\n    for (let x = linkBegin; x < linkEnd && x < elevationOccupied.length; x++) {\n      elevationOccupied[x] = elevation;\n    }\n    record.elevation = elevation; //storing final value for render\n  }\n  return elevationOccupied;\n}\n","import { Layer, Stage, Text } from \"react-konva\";\nimport React, { Component } from \"react\";\n\nimport \"./App.css\";\nimport PangenomeSchematic from \"./PangenomeSchematic\";\nimport ComponentRect, { compress_visible_rows } from \"./ComponentRect\";\nimport ComponentNucleotides from \"./ComponentNucleotides\";\nimport LinkColumn from \"./LinkColumn\";\nimport LinkArrow from \"./LinkArrow\";\nimport { calculateLinkCoordinates } from \"./LinkRecord\";\nimport NucleotideTooltip from \"./NucleotideTooltip\";\nimport ControlHeader from \"./ControlHeader\";\nimport { observe } from \"mobx\";\nimport {\n  areOverlapping,\n  arraysEqual,\n  calculateEndBinFromScreen,\n  stringToColorAndOpacity,\n} from \"./utilities\";\n\n//import makeInspectable from \"mobx-devtools-mst\";\n// TO_DO: improve the management of visualized components\nlet index_to_component_to_visualize_dict;\n\nfunction Legend(props) {\n  return (\n    <img\n      src={process.env.PUBLIC_URL + \"/\" + \"Schematize legend.gif\"}\n      alt=\"legend\"\n      style={{\n        position: \"fixed\",\n        bottom: \"20px\",\n        left: \"20px\",\n        background: \"white\",\n        align: \"right\",\n        width: \"100px\",\n        height: \"200px\",\n      }}\n    />\n  );\n}\n\nclass App extends Component {\n  layerRef = React.createRef();\n  layerRef2 = React.createRef(null);\n  // Timer for the LinkArrow highlighting and selection (clicking on it)\n  timerHighlightingLink = null;\n  timerSelectionLink = null;\n\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      schematize: [],\n      pathNames: [],\n      actualWidth: 1,\n      buttonsHeight: 0,\n    };\n    this.schematic = new PangenomeSchematic({ store: this.props.store }); //Read file, parse nothing\n\n    /* == State control flow --> redundancies here can waste processing time\n    * STEP #1: whenever jsonName changes, loadIndexFile\n    * STEP #2: chunkIndex contents loaded\n    * STEP #3: with new chunkIndex, this.openRelevantChunksFromIndex()\n    * STEP #4: Set switchChunkURLs\n    * STEP #5: once ChunkURLs are listed, go fetchAllChunks\n    * STEP #6: fetched chunks go into loadJsonCache\n    * STEP #7: JsonCache causes processArray to update chunksProcessed\n    * STEP #8: chunksProcessed finishing triggers updateSchematicMetadata with final rendering info for this loaded chunks\n      * STEP #9: reserveAirspace\n      * STEP #10: calcMaxNumRowsAcrossComponents\n    //TODO: separate processArray into its  own observer\n    * STEP #11: Y values calculated, trigger do the render\n    * */\n\n    //Arrays must be observed directly, simple objects are observed by name\n    //STEP #5: once ChunkURLs are listed, go fetchAllChunks\n    observe(this.props.store.chunkURLs, this.fetchAllChunks.bind(this));\n\n    // observe(this.props.store, \"pixelsPerRow\", this.recalcY.bind(this));\n    observe(\n      this.props.store,\n      \"useVerticalCompression\",\n      this.updateSchematicMetadata.bind(this)\n    );\n    observe(this.props.store, \"useWidthCompression\", () => {\n      this.recalcXLayout();\n    });\n    observe(this.props.store, \"useConnector\", this.recalcXLayout.bind(this)); //TODO faster rerender\n    observe(this.props.store, \"pixelsPerColumn\", this.recalcXLayout.bind(this)); //TODO faster rerender\n    observe(this.props.store, \"pixelsPerRow\", this.recalcY.bind(this)); //TODO faster rerender\n\n    //STEP #8: chunksProcessed finishing triggers updateSchematicMetadata with final\n    // rendering info for this loaded chunks\n    observe(\n      this.props.store.chunksProcessed,\n      this.updateSchematicMetadata.bind(this)\n    );\n\n    //STEP #11: Y values calculated, trigger do the render\n    observe(this.props.store, \"loading\", this.render.bind(this));\n\n    //STEP #3: with new chunkIndex, openRelevantChunksFromIndex\n    observe(\n      this.props.store,\n      \"chunkIndex\",\n      this.openRelevantChunksFromIndex.bind(this)\n    );\n\n    /*observe(\n      this.props.store,\n      \"indexSelectedZoomLevel\",\n      this.openRelevantChunksFromIndex.bind(this) // Whenever the selected zoom level changes\n    );*/\n    observe(\n      this.props.store.beginEndBin, //user moves start position\n      //This following part is important to scroll right and left on browser\n      this.openRelevantChunksFromIndex.bind(this)\n    );\n\n    // For debugging purposes\n      //makeInspectable(this.props.store);\n  }\n\n  prepareWhichComponentsToVisualize() {\n    // It prepares a dictionary with the components to visualize. It is improvable putting all the components\n    // in a dictionary (this.schematic.components becames a dictionary).\n\n    index_to_component_to_visualize_dict = {};\n\n    for (const schematizeComponent of this.schematic.components) {\n      if (\n        areOverlapping(\n          this.props.store.getBeginBin(),\n          this.props.store.getEndBin(),\n          schematizeComponent.firstBin,\n          schematizeComponent.lastBin\n        )\n      ) {\n          //console.log('PREPARE: ' + schematizeComponent.index + ': [' + schematizeComponent.firstBin + ',' + schematizeComponent.lastBin + '] - ' + schematizeComponent.arrivals.length + ' - ' + schematizeComponent.departures.length)\n\n        index_to_component_to_visualize_dict[\n          schematizeComponent.index\n        ] = schematizeComponent;\n      } else if (schematizeComponent.firstBin > this.props.store.getEndBin()) {\n        // The components to visualized was already taken\n        break;\n      }\n    }\n\n    //console.log(this.schematic.components.length)\n    //console.log(this.props.store.getBeginBin() + ' - ' + this.props.store.getEndBin())\n    //console.log('index_to_component_to_visualize_dict: '  + Object.keys(index_to_component_to_visualize_dict))\n  }\n\n  /** Compares bin2file @param indexContents with the beginBin and EndBin.\n   * It finds the appropriate chunk URLS from the index and updates\n   * switchChunkURLs which trigger json fetches for the new chunks. **/\n  openRelevantChunksFromIndex(lastIndexSelectedZoomLevel = -1) {\n    console.log(\n      \"STEP #3: with new chunkIndex, this.openRelevantChunksFromIndex()\"\n    );\n\n    if (\n      this.props.store.chunkIndex === null ||\n      !this.props.store.chunkIndex.zoom_levels.keys()\n    ) {\n      return; //before the class is fully initialized\n    }\n    const beginBin = this.props.store.getBeginBin();\n\n    // With new chunkIndex, it sets the available zoom levels\n    this.props.store.setAvailableZoomLevels(\n      this.props.store.chunkIndex[\"zoom_levels\"].keys()\n    );\n    const selZoomLev = this.props.store.getSelectedZoomLevel();\n    let [fileArray, fileArrayFasta] = calculateEndBinFromScreen(\n      beginBin,\n      this.props.store.getEndBin(),\n      selZoomLev,\n      this.props.store\n    );\n    this.props.store.setLastBinPangenome(\n      this.props.store.chunkIndex.zoom_levels.get(selZoomLev)[\"last_bin\"]\n    );\n\n    let bin_range_changed = false;\n    if (lastIndexSelectedZoomLevel > -1) {\n      const scaling_factor =\n        this.props.store.getSelectedZoomLevel(lastIndexSelectedZoomLevel) /\n        this.props.store.getSelectedZoomLevel();\n      console.log(\"scaling_factor: \" + scaling_factor);\n      bin_range_changed = this.props.store.updateBeginEndBin(\n        Math.round((beginBin - 1) * scaling_factor),\n        Math.round((this.props.store.getEndBin() - 1) * scaling_factor)\n      );\n    }\n\n    // To avoid to do the preparation and the following operations two times\n    if (!bin_range_changed) {\n      this.prepareWhichComponentsToVisualize();\n\n    //console.log([selZoomLev, endBin, fileArray, fileArrayFasta]);\n    let URLprefix =\n      process.env.REACT_APP_FETCH +\n      this.props.store.jsonName +\n      \"/\" +\n      selZoomLev +\n      \"/\";\n    fileArray = fileArray.map((filename) => {\n      return URLprefix + filename;\n    });\n    fileArrayFasta = fileArrayFasta.map((filename) => {\n      return URLprefix + filename;\n    });\n\n      this.props.store.switchChunkFastaURLs(fileArrayFasta);\n\n      // If there are no new chunck, it has only to recalculate the X layout\n      if (!this.props.store.switchChunkURLs(fileArray)) {\n        this.recalcXLayout();\n      }\n    }\n  }\n\n  fetchAllChunks() {\n    /*Dispatches fetches for all chunk files\n     * Read https://github.com/graph-genome/Schematize/issues/22 for details\n     */\n    console.log(\"STEP #5: once ChunkURLs are listed, go fetchAllChunks\");\n    //console.log(\"fetchAllChunks\", this.props.store.chunkURLs);\n    if (!this.props.store.chunkURLs.get(0)) {\n      console.warn(\"No chunk URL defined.\");\n      return;\n    }\n    for (let chunkPath of this.props.store.chunkURLs) {\n      //TODO: conditional on jsonCache not already having chunk\n      //console.log(\"fetchAllChunks - START reading: \" + chunkPath);\n      this.schematic.jsonFetch(chunkPath).then((data) => {\n        console.log(\"fetchAllChunks - END reading: \" + chunkPath);\n        this.schematic.loadJsonCache(chunkPath, data);\n      });\n    }\n  }\n\n  updateSchematicMetadata() {\n    if (\n      arraysEqual(this.props.store.chunkURLs, this.props.store.chunksProcessed)\n    ) {\n      console.log(\n        \"updateSchematicMetadata #components: \" +\n          this.schematic.components.length\n      );\n      console.log(\n        \"STEP #8: chunksProcessed finishing triggers updateSchematicMetadata with final rendering info for this loaded chunks\"\n      );\n\n      this.prepareWhichComponentsToVisualize();\n\n      // console.log(this.schematic.components);\n      this.setState(\n        {\n          schematize: this.schematic.components,\n          pathNames: this.schematic.pathNames,\n        },\n        () => {\n          this.recalcXLayout();\n\n          this.compressed_row_mapping = compress_visible_rows(\n            this.schematic.components\n          );\n          this.maxNumRowsAcrossComponents = this.calcMaxNumRowsAcrossComponents(\n            this.schematic.components\n          ); // TODO add this to mobx-state-tree\n          this.props.store.setLoading(false);\n        }\n      );\n    }\n  }\n\n  recalcXLayout() {\n    console.log(\"recalcXLayout\");\n\n    // In this way the updated relativePixelX information is available everywhere for the rendering\n    for (const [\n      i,\n      schematizeComponent,\n    ] of this.schematic.components.entries()) {\n      schematizeComponent.relativePixelX = this.leftXStart(\n        schematizeComponent,\n        i,\n        0,\n        0\n      );\n    }\n\n    const first_visualized_component = Object.values(\n      index_to_component_to_visualize_dict\n    )[0];\n    const last_visualized_component = Object.values(\n      index_to_component_to_visualize_dict\n    )[Object.values(index_to_component_to_visualize_dict).length - 1];\n\n    // The actualWidth is calculated on the visualized components\n    const columnsInComponents =\n      last_visualized_component.getColumnX(\n        this.props.store.useWidthCompression\n      ) -\n      first_visualized_component.getColumnX(\n        this.props.store.useWidthCompression\n      ) +\n      last_visualized_component.arrivals.length +\n      last_visualized_component.departures.length +\n      (this.props.store.useWidthCompression\n        ? this.props.store.binScalingFactor\n        : last_visualized_component.num_bin) -\n      this._column_shift(first_visualized_component);\n\n    //TO_DO: to remove?\n    /*const paddingBetweenComponents =\n      this.props.store.pixelsPerColumn * this.schematic.components.length;*/\n    const actualWidth = columnsInComponents * this.props.store.pixelsPerColumn;\n    //+ paddingBetweenComponents;\n    this.setState({\n      actualWidth: actualWidth,\n    });\n    const [links, top] = calculateLinkCoordinates(\n      this.schematic.components,\n      this.props.store.pixelsPerColumn,\n      this.props.store.topOffset,\n      this.props.store.useWidthCompression,\n      this.props.store.binScalingFactor,\n      this.leftXStart.bind(this),\n      index_to_component_to_visualize_dict\n    );\n    this.distanceSortedLinks = links;\n    this.props.store.updateTopOffset(parseInt(top));\n  }\n\n  recalcY() {\n    // forceUpdate() doesn't work with callback function\n    this.setState({ highlightedLink: null }); // nothing code to force update.\n  }\n\n  calcMaxNumRowsAcrossComponents(components) {\n    let lengths = components.map((x) => {\n      return x.occupants.length;\n    });\n    return Math.max(...lengths); //this should likely be faster than doing a search for true values\n  }\n\n  visibleHeightPixels() {\n    if (\n      this.props.store.useVerticalCompression ||\n      !this.compressed_row_mapping\n    ) {\n      // this.state.schematize.forEach(value => Math.max(value.occupants.filter(Boolean).length, maxNumberRowsInOneComponent));\n      if (this.maxNumRowsAcrossComponents === undefined) {\n        this.maxNumRowsAcrossComponents = this.calcMaxNumRowsAcrossComponents(\n          this.schematic.components\n        );\n      }\n      /*console.log(\n        \"maxNumRowsAcrossComponents\",\n        this.maxNumRowsAcrossComponents\n      );*/\n\n      return (\n        (this.maxNumRowsAcrossComponents + 2.5) * this.props.store.pixelsPerRow\n      );\n    } else {\n      return (\n        //TODO: NOTE that Object.keys is wrong if you change compressed_row_mapping to a mobx object\n        (Object.keys(this.compressed_row_mapping).length + 0.25) *\n        this.props.store.pixelsPerRow\n      );\n    }\n  }\n\n  componentDidMount = () => {\n    /*let buttonContainerDiv = document.getElementById(\"button-container\");\n    let clientHeight = buttonContainerDiv.clientHeight;\n\n    const arrowsDiv = document.getElementsByClassName(\"konvajs-content\")[0];\n    arrowsDiv.style.position = \"relative\";\n\n    this.setState({ buttonsHeight: clientHeight });\n\n    this.layerRef.current.getCanvas()._canvas.id = \"cnvs\";\n    this.layerRef.current.getCanvas()._canvas.position = \"relative\";\n\n    this.layerRef2.current.getCanvas()._canvas.id = \"arrow\";\n    this.layerRef2.current.getCanvas()._canvas.position = \"relative\";*/\n    //this.layerRef2.current.getCanvas()._canvas.style.top = \"95px\";\n    /*if(this.props.store.useVerticalCompression) {\n      this.props.store.resetRenderStats(); //FIXME: should not require two renders to get the correct number\n    }*/\n  };\n\n  // Now it is wrapped in the updateHighlightedNode() function\n  _updateHighlightedNode = (linkRect) => {\n    this.setState({ highlightedLink: linkRect });\n  };\n\n  // Wrapper function to wrap the logic (no link selected and time delay)\n  updateHighlightedNode = (linkRect) => {\n    // The highlighting has to work only if there isn't any selected link\n    if (!this.state.selectedLink) {\n      if (linkRect != null) {\n        // It comes from an handleMouseOver event\n\n        clearTimeout(this.timerHighlightingLink);\n\n        // To avoid unnecessary rendering when linkRect is still the this.state.highlightedLink link.\n        if (this.state.highlightedLink !== linkRect) {\n          // This ES6 syntaxt avoid to pass the result of the callback to setTimeoutwork.\n          // It works because the ES6 arrow function does not change the context of this.\n          this.timerHighlightingLink = setTimeout(\n            () => {\n              this._updateHighlightedNode(linkRect);\n            },\n            600 // TODO: value to tune. Create a config file where all these hard-coded settings will be\n          );\n        }\n      } else {\n        // It comes from an handleMouseOut event\n\n        clearTimeout(this.timerHighlightingLink);\n\n        // To avoid unnecessary rendering when linkRect == null and this.state.highlightedLink is already null for any reason.\n        if (this.state.highlightedLink != null) {\n          this.timerHighlightingLink = setTimeout(\n            () => {\n              this._updateHighlightedNode(linkRect);\n            },\n            600 // TODO: value to tune. Create a config file where all these hard-coded settings will be\n          );\n        }\n      }\n    }\n  };\n\n  updateSelectedLink = (linkRect) => {\n    console.log(\"updateSelectedLink\");\n\n    let update_state = false;\n\n    if (linkRect) {\n      //TO_DO: lift down this logic when it will be visualized partial chunks (or\n      // pass info about the visualized chunks to the LinkArrow tags)\n      const [binLeft, binRight] = [linkRect.upstream, linkRect.downstream].sort(\n        function (a, b) {\n          return a - b;\n        }\n      );\n\n      /*console.log([linkRect.upstream, linkRect.downstream])\n      console.log(binLeft, binRight)*/\n\n      const last_bin_last_visualized_component = Object.values(\n        index_to_component_to_visualize_dict\n      ).slice(-1)[0].lastBin;\n      // if (linkRect !== this.state.selectedLink) //else it is a re-clik on the same link, so do nothing here\n\n      const [beginBin, endBin] = this.props.store.beginEndBin;\n      if (binLeft < beginBin || binRight > last_bin_last_visualized_component) {\n        console.log(\"updateSelectedLink - NewBeginEndBin\");\n\n        const end_closer =\n          Math.abs(beginBin - binLeft) > Math.abs(endBin - binRight);\n\n        let [newBeginBin, newEndBin] = this.props.store.beginEndBin;\n        let screenWidth = endBin - beginBin;\n        let half = Math.floor(screenWidth / 2);\n        if (end_closer) {\n          [newBeginBin, newEndBin] = [binLeft - half, binLeft + half];\n        } else {\n          [newBeginBin, newEndBin] = [binRight - half, binRight + half];\n        }\n\n        this.props.store.updateBeginEndBin(newBeginBin, newEndBin);\n        update_state = true;\n      }\n    }\n\n    clearTimeout(this.timerHighlightingLink);\n\n    // Update the rendering if it is selected a new arrow (or deselected the last one) or\n    // if the range in changed (clicking on a new arrow or recliking on the same one)\n    if (linkRect !== this.selectedLink || update_state) {\n      console.log(\"updateSelectedLink - NewSelection\");\n\n      this.setState({\n        highlightedLink: linkRect,\n        selectedLink: linkRect,\n      });\n    }\n\n    // Auto de-selection after a delay\n    if (linkRect) {\n      console.log(\"Timer deselection\");\n\n      // Eventually restart the timer if it was already ongoing\n      clearTimeout(this.timerSelectionLink);\n\n      this.timerSelectionLink = setTimeout(\n        () => {\n          this.updateSelectedLink(null);\n        },\n        5000 // TODO: to tune. Create a config file where all these hard-coded settings will be\n      );\n    }\n  };\n\n  // Specific utility function to calculate the visualization shift for the first partial visualized component\n  _column_shift(first_visualized_component) {\n    return !this.props.store.useWidthCompression\n      ? first_visualized_component.firstBin === this.props.store.getBeginBin()\n        ? 0\n        : first_visualized_component.arrivals.length +\n          (this.props.store.getBeginBin() - first_visualized_component.firstBin)\n      : 0; // When only rearrangements are shown, the width does not correspond to the number of bin, so for now we avoid any shifting\n  }\n\n  leftXStart(schematizeComponent, i, firstDepartureColumn, j) {\n    // Avoid calling the function too early or for not visualized components\n    if (!(schematizeComponent.index in index_to_component_to_visualize_dict)) {\n      return;\n    }\n\n    //Return the x coordinate pixel that starts the LinkColumn at i, j\n\n    const first_visualized_component = Object.values(\n      index_to_component_to_visualize_dict\n    )[0];\n\n    /*\n    - \"schematizeComponent.getColumnX(...) - first_visualized_component.getColumnX(..)\": offset of the current component respect to the first visualized one\n    - \"this._column_shift(first_visualized_component)\"\": to hide the arrow on the left\n    - \"(schematizeComponent.index - this.schematic.components[0].index\": number of padding white columns\n    */\n    const previousColumns =\n      schematizeComponent.getColumnX(this.props.store.useWidthCompression) -\n      first_visualized_component.getColumnX(\n        this.props.store.useWidthCompression\n      ) -\n      this._column_shift(first_visualized_component) -\n      (schematizeComponent.index - this.schematic.components[0].index);\n\n    const pixelsFromColumns =\n      (previousColumns + firstDepartureColumn + j) *\n      this.props.store.pixelsPerColumn;\n\n    return pixelsFromColumns + i * this.props.store.pixelsPerColumn;\n  }\n\n  renderComponent(schematizeComponent, i, pathNames) {\n    return (\n      <>\n        <ComponentRect\n          store={this.props.store}\n          item={schematizeComponent}\n          key={\"r\" + i}\n          height={this.visibleHeightPixels()}\n          widthInColumns={\n            schematizeComponent.arrivals.length +\n            (this.props.store.useWidthCompression\n              ? this.props.store.binScalingFactor\n              : schematizeComponent.num_bin) +\n            (schematizeComponent.departures.length - 1)\n          }\n          compressed_row_mapping={this.compressed_row_mapping}\n          pathNames={pathNames}\n        />\n\n        {schematizeComponent.arrivals.map((linkColumn, j) => {\n          return this.renderLinkColumn(\n            schematizeComponent,\n            i,\n            0,\n            j,\n            linkColumn\n          );\n        })}\n        {schematizeComponent.departures.slice(0, -1).map((linkColumn, j) => {\n          let leftPad =\n            schematizeComponent.arrivals.length +\n            (this.props.store.useWidthCompression\n              ? this.props.store.binScalingFactor\n              : schematizeComponent.num_bin);\n\n          return this.renderLinkColumn(\n            schematizeComponent,\n            i,\n            leftPad,\n            j,\n            linkColumn\n          );\n        })}\n      </>\n    );\n  }\n\n  renderLinkColumn(\n    schematizeComponent,\n    i,\n    firstDepartureColumn,\n    j,\n    linkColumn\n  ) {\n    const xCoordArrival = this.leftXStart(\n      schematizeComponent,\n      i,\n      firstDepartureColumn,\n      j\n    );\n    const [localColor, localOpacity, localStroke] = stringToColorAndOpacity(\n      linkColumn,\n      this.state.highlightedLink,\n      this.state.selectedLink\n    );\n    return (\n      <LinkColumn\n        store={this.props.store}\n        key={\"departure\" + i + j}\n        item={linkColumn}\n        pathNames={this.state.pathNames}\n        x={xCoordArrival}\n        pixelsPerRow={this.props.store.pixelsPerRow}\n        width={this.props.store.pixelsPerColumn}\n        color={localColor}\n        opacity={localOpacity}\n        stroke={localStroke}\n        updateHighlightedNode={this.updateHighlightedNode}\n        compressed_row_mapping={this.compressed_row_mapping}\n      />\n    );\n  }\n\n  renderLink(link) {\n    const [localColor, localOpacity] = stringToColorAndOpacity(\n      link.linkColumn,\n      this.state.highlightedLink,\n      this.state.selectedLink\n    );\n\n    return (\n      <LinkArrow\n        store={this.props.store}\n        key={\"arrow\" + link.linkColumn.key}\n        link={link}\n        color={localColor}\n        opacity={localOpacity}\n        updateHighlightedNode={this.updateHighlightedNode}\n        updateSelectedLink={this.updateSelectedLink}\n      />\n    );\n  }\n\n  renderNucleotidesSchematic = () => {\n    if (\n      !this.props.store.loading &&\n      // The conditions on binWidht and useWidthCompression are lifted here,\n      // avoiding any computation if nucleotides have not to be visualized.\n      this.props.store.getBinWidth() === 1 &&\n      !this.props.store.useWidthCompression &&\n      this.props.store.pixelsPerColumn >= 10 &&\n      this.schematic.nucleotides.length > 0\n    ) {\n      //console.log('renderNucleotidesSchematic - START')\n      return Object.values(index_to_component_to_visualize_dict).map(\n        (schematizeComponent, i) => {\n          // The dummy component (firstBin and lastBin equal to 0) is not loaded in this.schematic.components, but there is a nucleotide for it in the FASTA file.\n          // If the first component has firstBin == 1, then in the FASTA there is a nucleotide not visualized, so the shift start from 0, and not 1\n          const nt_shift = this.schematic.components[0].firstBin || 1;\n\n          const nucleotides_slice = this.schematic.nucleotides.slice(\n              schematizeComponent.firstBin - nt_shift, // firstBin is 1 indexed, but this is canceled by nt_shift\n              schematizeComponent.lastBin - nt_shift + 1 // inclusive end\n          );\n\n          //console.log(\"nucleotides_slice: \" + nucleotides_slice);\n\n          return (\n            <React.Fragment key={\"nt\" + i}>\n              <ComponentNucleotides\n                store={this.props.store}\n                item={schematizeComponent}\n                key={i}\n                // They are passed only the nucleotides associated to the current component\n                nucleotides={nucleotides_slice}\n              />\n            </React.Fragment>\n          );\n        }\n      );\n    }\n  };\n\n  renderSchematic() {\n    console.log(\"renderSchematic\");\n\n    if (this.props.store.loading) {\n      return;\n    }\n\n    return this.schematic.components.map((schematizeComponent, i) => {\n      if (schematizeComponent.index in index_to_component_to_visualize_dict) {\n        return (\n          <React.Fragment key={\"f\" + i}>\n            {this.renderComponent(schematizeComponent, i, this.state.pathNames)}\n          </React.Fragment>\n        );\n      } else {\n        return null;\n      }\n    });\n  }\n\n  renderSortedLinks() {\n    if (this.props.store.loading) {\n      return;\n    }\n\n    return this.distanceSortedLinks.map((record, i) => {\n      return this.renderLink(record);\n    });\n  }\n\n  loadingMessage() {\n    if (this.props.store.loading) {\n      return (\n        <Text\n          key=\"loading\"\n          y={100}\n          fontSize={60}\n          width={300}\n          align=\"center\"\n          text=\"Loading...\"\n        />\n      );\n    }\n  }\n\n  render() {\n    console.log(\"Start render\");\n\n    //console.log('renderNucleotidesSchematic - START')\n\n    return (\n      <>\n        <div\n          style={{\n            position: \"sticky\",\n            top: 0,\n            zIndex: \"2\",\n            background: \"white\",\n\n            // To keep the matrix under the container with the vertical scrolling\n            // when the matrix is larger than the page\n            width: this.state.actualWidth,\n\n            // To avoid width too low with large bin_width\n            minWidth: \"100%\",\n          }}\n        >\n          <ControlHeader\n            store={this.props.store}\n            openRelevantChunksFromIndex={(lastIndexSelectedZoomLevel) =>\n              this.openRelevantChunksFromIndex(lastIndexSelectedZoomLevel)\n            }\n            schematic={this.schematic}\n          />\n\n          <Stage\n            x={this.props.store.leftOffset}\n            y={this.props.topOffset}\n            width={this.state.actualWidth}\n            height={this.props.store.topOffset}\n          >\n            <Layer ref={this.layerRef2}>\n              {this.renderSortedLinks()}\n              {this.renderNucleotidesSchematic()}\n            </Layer>\n          </Stage>\n        </div>\n\n        <Stage\n          x={this.props.store.leftOffset} // removed leftOffset to simplify code. Relative coordinates are always better.\n          y={-this.props.store.topOffset} // For some reason, I have to put this, but I'd like to put 0\n          width={this.state.actualWidth}\n          height={\n            this.visibleHeightPixels() + this.props.store.nucleotideHeight\n          }\n        >\n          <Layer ref={this.layerRef}>\n            {this.loadingMessage()}\n            {this.renderSchematic()}\n          </Layer>\n        </Stage>\n\n        <NucleotideTooltip store={this.props.store} />\n        <Legend store={this.props.store} />\n      </>\n    );\n  }\n}\n\n// render(<App />, document.getElementById('root'));\n\nexport default App;\n","import React from \"react\";\nimport MouseTooltip from \"react-sticky-mouse-tooltip\";\nimport {Observer} from \"mobx-react\";\nimport PropTypes from \"prop-types\";\n\nexport default class NucleotideTooltip extends React.Component {\n  render() {\n    return (\n      <MouseTooltip\n          visible={true}\n          offsetX={15}\n          offsetY={-20}\n          style={{background: \"white\", zIndex: 4, \"whiteSpace\": \"pre-line\"}}\n      >\n        <Observer>\n          {() => <span>{this.props.store.cellToolTipContent}</span>}\n        </Observer>\n      </MouseTooltip>\n    );\n  }\n}\n\nNucleotideTooltip.propTypes = {\n  store: PropTypes.object,\n};\n","import React from \"react\";\nimport { Observer } from \"mobx-react\";\nimport { httpGetAsync } from \"./URL\";\nimport PropTypes from \"prop-types\";\n\nclass ControlHeader extends React.Component {\n  shift(percentage) {\n    const beginBin = this.props.store.getBeginBin();\n    const endBin = this.props.store.getEndBin();\n    let size = endBin - beginBin;\n    let diff = Math.floor(size * (percentage / 100));\n    console.log(endBin + \"-\" + beginBin + \"=\" + size + \" --> diff: \" + diff);\n    this.props.store.updateBeginEndBin(beginBin + diff, endBin + diff);\n  }\n\n  handleJump() {\n    console.log(\n      \"JUMP: path name: \" +\n        this.props.store.pathNucPos.path +\n        \" nucleotide position: \" +\n        this.props.store.pathNucPos.nucPos\n    );\n    // I don't know why, but in order for the CORS headers to exchange we need to make a first GET request to \"/hi\" which will not return anything\n\n    const store = this.props.store;\n    const addr = store.pathIndexServerAddress;\n    const path_name = store.pathNucPos.path;\n    const nuc_pos = store.pathNucPos.nucPos;\n\n    function handleOdgiServerResponse(result) {\n      if (result === \"0\") {\n        alert(\n          \"The jump query returned 0. Either your path does not exist or your position in the path is wrong. Please try again.\"\n        );\n      } else {\n        console.log(result);\n        // go from nucleotide position to bin\n        result = parseInt(result);\n        const newBeginBin = Math.ceil(result / this.props.store.getBinWidth());\n        console.log(newBeginBin);\n        store.updateBeginEndBin(newBeginBin, store.getEndBin());\n      }\n    }\n    // httpGetAsync(addr + \"hi\", printResult);\n    // httpGetAsync(addr + \"5/1\", printResult);\n    // httpGetAsync(addr + \"4/3\", printResult);\n    httpGetAsync(addr + path_name + \"/\" + nuc_pos, handleOdgiServerResponse);\n  }\n\n  _change_zoom_level(newIndexSelectedZoomLevel) {\n    const lastIndexSelectedZoomLevel = this.props.store.indexSelectedZoomLevel;\n    this.props.store.setIndexSelectedZoomLevel(newIndexSelectedZoomLevel);\n    this.props.openRelevantChunksFromIndex(lastIndexSelectedZoomLevel);\n  }\n\n  change_zoom_level(target) {\n    console.log(\n      \"change_zoom_level: \" +\n        target.value +\n        \" ---\" +\n        target.options[target.selectedIndex].text\n    );\n\n    this._change_zoom_level(parseInt(target.value));\n  }\n\n  decIndexSelectedZoomLevel() {\n    let indexSelZoomLevel = this.props.store.indexSelectedZoomLevel;\n    if (indexSelZoomLevel > 0) {\n      this._change_zoom_level(indexSelZoomLevel - 1);\n    }\n  }\n\n  incIndexSelectedZoomLevel() {\n    let indexSelZoomLevel = this.props.store.indexSelectedZoomLevel;\n    if (indexSelZoomLevel < this.props.store.availableZoomLevels.length - 1) {\n      this._change_zoom_level(indexSelZoomLevel + 1);\n    }\n  }\n\n  render() {\n    return (\n      <div id=\"button-container\">\n        <button className=\"button\" id=\"btn-download\">\n          Save Image\n        </button>\n        <input\n          type=\"text\"\n          defaultValue={this.props.store.jsonName}\n          style={{ width: \"330px\" }}\n          onChange={this.props.store.tryJSONpath}\n          title={\"File:\"}\n        />\n        <span style={{ marginLeft: \"30px\" }}>\n          <Observer>\n            {() => (\n              <>\n                Bin width:\n                <button\n                  className=\"button\"\n                  onClick={() => this.decIndexSelectedZoomLevel()}\n                >\n                  -\n                </button>\n                <select\n                  id=\"select_bin_width\"\n                  onChange={(val) => this.change_zoom_level(val.target)}\n                  value={this.props.store.indexSelectedZoomLevel}\n                >\n                  {this.props.store.availableZoomLevels.map((item, i) => (\n                    <option key={i} value={i}>\n                      {item}\n                    </option>\n                  ))}\n                </select>\n                <button\n                  className=\"button\"\n                  onClick={() => this.incIndexSelectedZoomLevel()}\n                >\n                  +\n                </button>\n              </>\n            )}\n          </Observer>\n        </span>\n\n        <span style={{ marginLeft: \"30px\" }}>\n          <button className=\"button\" onClick={() => this.shift(-100)}>\n            &lt;&lt;\n          </button>\n          <button className=\"button\" onClick={() => this.shift(-50)}>\n            &lt;\n          </button>\n          Pangenome Bin Position:\n          <Observer>\n            {() => (\n              <>\n                <input\n                  type=\"number\"\n                  value={this.props.store.beginEndBin[0]} // TODO Get methods don't work here, but I don't know why. Need to ask Robert Buels.\n                  onChange={(event) =>\n                    this.props.store.updateBeginEndBin(\n                      event.target.value,\n                      this.props.store.getEndBin()\n                    )\n                  }\n                  style={{ width: \"80px\" }}\n                />\n                -\n                <input\n                  type=\"number\"\n                  value={this.props.store.beginEndBin[1]}\n                  readOnly\n                  style={{ width: \"80px\" }}\n                />\n              </>\n            )}\n          </Observer>\n          <button className=\"button\" onClick={() => this.shift(50)}>\n            &gt;\n          </button>\n          <button className=\"button\" onClick={() => this.shift(100)}>\n            &gt;&gt;\n          </button>\n        </span>\n        <div className={\"row\"}>\n          Jump to path at nucleotide position:\n          <input\n            type=\"string\"\n            list=\"path\"\n            placeholder={\"path\"}\n            onChange={(event) =>\n              this.props.store.updatePathNucPos(\n                event.target.value,\n                this.props.store.pathNucPos.nucPos\n              )\n            }\n            style={{ width: \"80px\" }}\n          />\n          <datalist id=\"path\">\n            {this.props.schematic.pathNames.map((item, key) => (\n              <option key={key} value={item} />\n            ))}\n          </datalist>\n          -\n          <input\n            type=\"number\"\n            placeholder={\"position\"}\n            onChange={(event) =>\n              this.props.store.updatePathNucPos(\n                this.props.store.getPath(),\n                event.target.value\n              )\n            }\n            style={{ width: \"80px\" }}\n          />\n          <span style={{ marginLeft: \"2px\" }}>\n            <button className=\"button\" onClick={() => this.handleJump()}>\n              Jump\n            </button>\n          </span>\n        </div>\n        <div className={\"row\"}>\n          <span>\n            {\" \"}\n            Use Vertical Compression:\n            <VerticalCompressedViewSwitch store={this.props.store} />\n          </span>\n          <span>\n            {\" \"}\n            Show Only Rearrangements:\n            <WidthCompressedViewSwitch store={this.props.store} />\n          </span>\n          {this.props.store.useWidthCompression ? (\n            <React.Fragment>\n              <span>\n                {\" \"}\n                Render Connectors:\n                <RenderConnectorSwitch store={this.props.store} />\n              </span>\n            </React.Fragment>\n          ) : (\n            <></>\n          )}\n          <span>\n            {\" \"}\n            Row Height:\n            <Observer>\n              {() => (\n                <input\n                  type=\"number\"\n                  min={1}\n                  value={this.props.store.pixelsPerRow}\n                  onChange={this.props.store.updateHeight}\n                  style={{ width: \"30px\" }}\n                />\n              )}\n            </Observer>\n          </span>\n          <span>\n            {\" \"}\n            Column Width:\n            <input\n              type=\"number\"\n              min={1}\n              value={this.props.store.pixelsPerColumn}\n              onChange={this.props.store.updateWidth}\n              style={{ width: \"30px\" }}\n            />\n          </span>\n        </div>\n      </div>\n    );\n  }\n}\n\nControlHeader.propTypes = {\n  store: PropTypes.object,\n};\n\nclass VerticalCompressedViewSwitch extends React.Component {\n  render() {\n    return (\n      <Observer>\n        {() => (\n          <input\n            type=\"checkbox\"\n            checked={this.props.store.useVerticalCompression}\n            onChange={this.props.store.toggleUseVerticalCompression}\n          />\n        )}\n      </Observer>\n    );\n  }\n}\n\nVerticalCompressedViewSwitch.propTypes = {\n  store: PropTypes.object,\n};\n\nclass RenderConnectorSwitch extends React.Component {\n  render() {\n    return (\n      <Observer>\n        {() => (\n          <input\n            type=\"checkbox\"\n            checked={this.props.store.useConnector}\n            onChange={this.props.store.toggleUseConnector}\n          />\n        )}\n      </Observer>\n    );\n  }\n}\n\nRenderConnectorSwitch.propTypes = {\n  store: PropTypes.object,\n};\n\nclass WidthCompressedViewSwitch extends React.Component {\n  render() {\n    return (\n      <Observer>\n        {() => (\n          <input\n            type=\"checkbox\"\n            checked={this.props.store.useWidthCompression}\n            onChange={this.props.store.toggleUseWidthCompression}\n          />\n        )}\n      </Observer>\n    );\n  }\n}\n\nWidthCompressedViewSwitch.propTypes = {\n  store: PropTypes.object,\n};\n\nexport default ControlHeader;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import { types } from \"mobx-state-tree\";\nimport { urlExists } from \"./URL\";\nimport { arraysEqual } from \"./utilities\";\n\nconst Chunk = types.model({\n  file: types.string,\n  fasta: types.maybeNull(types.string),\n  first_bin: types.integer,\n  last_bin: types.integer,\n  component_count: types.integer,\n  link_count: types.integer,\n});\nconst ZoomLevel = types.model({\n  bin_width: types.integer,\n  last_bin: types.integer,\n  files: types.array(Chunk),\n});\nconst ChunkIndex = types.maybeNull(\n  types.model({\n    json_version: 14,\n    pangenome_length: types.integer,\n    zoom_levels: types.map(ZoomLevel),\n  })\n);\nconst PathNucPos = types.model(\"PathNucPos\", {\n  path: types.string,\n  nucPos: types.integer,\n});\n\nlet RootStore;\nRootStore = types\n  .model({\n    chunkIndex: ChunkIndex,\n    beginEndBin: types.optional(types.array(types.integer), [1, 100]),\n    maxWidthBinRange: 99,\n    useVerticalCompression: false,\n    useWidthCompression: false,\n    binScalingFactor: 3,\n    useConnector: true,\n    pixelsPerColumn: 10,\n    pixelsPerRow: 3,\n    leftOffset: 1,\n    topOffset: 400,\n    highlightedLink: 0, // we will compare linkColumns\n    maximumHeightThisFrame: 150,\n    cellToolTipContent: \"\",\n    jsonName: \"SARS-CoV-b\",\n    // Added attributes for the zoom level management\n    availableZoomLevels: types.optional(types.array(types.string), [\"1\"]),\n    indexSelectedZoomLevel: 0,\n    chunkURLs: types.optional(types.array(types.string), []),\n    chunkFastaURLs: types.optional(types.array(types.string), []),\n    //to be compared against chunkURLs\n    chunksProcessed: types.optional(types.array(types.string), []),\n\n    pathNucPos: types.optional(PathNucPos, { path: \"path\", nucPos: 0 }), // OR: types.maybe(PathNucPos)\n    pathIndexServerAddress: \"http://193.196.29.24:3010/\",\n    nucleotideHeight: 10,\n\n    loading: true,\n    copyNumberColorArray: types.optional(types.array(types.string), [\n      \"#6a6a6a\",\n      \"#5f5f5f\",\n      \"#545454\",\n      \"#4a4a4a\",\n      \"#3f3f3f\",\n      \"#353535\",\n      \"#2a2a2a\",\n      \"#1f1f1f\",\n      \"#151515\",\n      \"#0a0a0a\",\n      \"#000000\",\n    ]),\n    invertedColorArray: types.optional(types.array(types.string), [\n      \"#de4b39\",\n      \"#c74333\",\n      \"#b13c2d\",\n      \"#9b3427\",\n      \"#852d22\",\n      \"#6f251c\",\n      \"#581e16\",\n      \"#421611\",\n      \"#2c0f0b\",\n      \"#160705\",\n      \"#000000\",\n    ]),\n\n    last_bin_pangenome: 0,\n  })\n  .actions((self) => {\n    function setChunkIndex(json) {\n      console.log(\"STEP #2: chunkIndex contents loaded\");\n      //console.log(\"Index updated with content:\", json);\n\n      self.chunkIndex = null; // TODO: TEMPORARY HACK before understanding more in depth mobx-state or change approach\n\n      self.chunkIndex = json;\n    }\n    function updateBeginEndBin(newBegin, newEnd) {\n      console.log(\"updateBeginEndBin - \" + newBegin + \" - \" + newEnd);\n\n      const beginBin = getBeginBin();\n      const endBin = getEndBin();\n\n      /*This method needs to be atomic to avoid spurious updates and out of date validation.*/\n\n      //TO_DO: remove endBin and manage beginBin and widthBinRange (100 by default)?\n      newBegin = Math.max(1, Math.round(newBegin));\n      newEnd = Math.max(2, Math.round(newBegin + self.maxWidthBinRange));\n\n      // So that the end bin is at the most the end of the pangenome\n      if (newEnd > self.last_bin_pangenome) {\n        let excess_bins = newEnd - self.last_bin_pangenome;\n\n        newBegin = Math.max(1, newBegin - excess_bins);\n        newEnd = Math.max(2, newEnd - excess_bins);\n      }\n\n      if (newBegin !== beginBin || newEnd !== endBin) {\n        setBeginEndBin(newBegin, newEnd);\n        console.log(\"updated begin and end: \" + newBegin + \" \" + newEnd);\n        return true;\n      }\n\n      return false;\n    }\n    function updateTopOffset(newTopOffset) {\n      if (Number.isFinite(newTopOffset) && Number.isSafeInteger(newTopOffset)) {\n        self.topOffset = newTopOffset + 10;\n      }\n    }\n    function updateBinScalingFactor(event) {\n      let newFactor = event.target.value;\n      self.binScalingFactor = Math.max(1, Number(newFactor));\n    }\n    function updateHighlightedLink(linkRect) {\n      self.highlightedLink = linkRect;\n    }\n    function updateMaxHeight(latestHeight) {\n      self.maximumHeightThisFrame = Math.max(\n        self.maximumHeightThisFrame,\n        latestHeight\n      );\n    }\n    function resetRenderStats() {\n      self.maximumHeightThisFrame = 1;\n    }\n    function updateCellTooltipContent(newContents) {\n      self.cellToolTipContent = String(newContents);\n    }\n    function toggleUseVerticalCompression() {\n      self.useVerticalCompression = !self.useVerticalCompression;\n    }\n    function toggleUseWidthCompression() {\n      self.useWidthCompression = !self.useWidthCompression;\n    }\n    function toggleUseConnector() {\n      self.useConnector = !self.useConnector;\n    }\n    function updateHeight(event) {\n      self.pixelsPerRow = Math.max(1, Number(event.target.value));\n    }\n    function updateWidth(event) {\n      self.pixelsPerColumn = Math.max(3, Number(event.target.value));\n    }\n\n    function tryJSONpath(event) {\n      const url =\n        process.env.REACT_APP_FETCH + event.target.value + \"/bin2file.json\";\n      if (urlExists(url)) {\n        console.log(\"STEP#1: New Data Source: \" + event.target.value);\n        self.jsonName = event.target.value;\n      }\n    }\n\n    // Lifted down the control of the emptyness of the arrays\n    function switchChunkURLs(arrayOfFile) {\n      if (!arraysEqual(arrayOfFile, self.chunkURLs)) {\n        console.log(\"STEP #4: Set switchChunkURLs: \" + arrayOfFile);\n        self.chunkURLs = arrayOfFile;\n        self.chunksProcessed = []; //clear\n\n        return true;\n      }\n      return false;\n    }\n    function switchChunkFastaURLs(arrayOfFile) {\n      if (!arraysEqual(arrayOfFile, self.chunkFastaURLs)) {\n        console.log(\"STEP #4.fasta: Set switchChunkFastaURLs: \" + arrayOfFile);\n        self.chunkFastaURLs = arrayOfFile;\n      }\n    }\n    function addChunkProcessed(singleChunk) {\n      console.log(\"STEP #7: processed \" + singleChunk);\n      self.chunksProcessed.push(singleChunk);\n    }\n    function getBeginBin() {\n      return self.beginEndBin[0];\n    }\n    function getEndBin() {\n      return self.beginEndBin[1];\n    }\n\n    // Getter and setter for zoom info management\n    function getBinWidth() {\n      //Zoom level and BinWidth are actually the same thing\n      return Number(self.getSelectedZoomLevel());\n    }\n    function getSelectedZoomLevel(indexSelectedZoomLevel = -1) {\n      //This is a genuinely useful getter\n      let a =\n        self.availableZoomLevels[\n          indexSelectedZoomLevel > -1\n            ? indexSelectedZoomLevel\n            : self.indexSelectedZoomLevel\n        ];\n      return a ? a : \"1\";\n    }\n    function setIndexSelectedZoomLevel(index) {\n      self.indexSelectedZoomLevel = index;\n    }\n\n    function setAvailableZoomLevels(availableZoomLevels) {\n      let arr = [...availableZoomLevels];\n\n      self.availableZoomLevels = arr;\n    }\n\n    function setBeginEndBin(newBeginBin, newEndBin) {\n      self.beginEndBin = [newBeginBin, newEndBin];\n    }\n    function updatePathNucPos(path, nucPos) {\n      if (nucPos) {\n        nucPos = parseInt(nucPos);\n      } else {\n        nucPos = 0;\n      }\n      self.pathNucPos = { path: path, nucPos: nucPos };\n    }\n\n    function setLoading(val) {\n      self.loading = val;\n    }\n    function setLastBinPangenome(val) {\n      self.last_bin_pangenome = val;\n    }\n    return {\n      setChunkIndex,\n      updateBeginEndBin,\n      updateTopOffset,\n      updateHighlightedLink,\n      updateMaxHeight,\n      resetRenderStats,\n      updateCellTooltipContent,\n      updateBinScalingFactor,\n      toggleUseVerticalCompression,\n      toggleUseWidthCompression,\n      toggleUseConnector,\n      updateHeight,\n      updateWidth,\n      tryJSONpath,\n\n      switchChunkURLs,\n      switchChunkFastaURLs,\n      addChunkProcessed,\n\n      getBeginBin,\n      getEndBin,\n      updatePathNucPos,\n\n      //NOTE: DO NOT ADD GETTERS here.  They are not necessary in mobx.\n      // You can reference store.val directly without store.getVal()\n      //Only write getters to encapsulate useful logic for derived values\n\n      // Added zoom actions\n      getBinWidth,\n      getSelectedZoomLevel,\n      setIndexSelectedZoomLevel,\n      setAvailableZoomLevels,\n\n      setLoading,\n\n      setLastBinPangenome,\n    };\n  })\n  .views((self) => ({}));\n\nexport const store = RootStore.create({});\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { store } from \"./ViewportInputsStore\";\n\nReactDOM.render(<App store={store} />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}