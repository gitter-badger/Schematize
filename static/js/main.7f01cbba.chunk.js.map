{"version":3,"sources":["URL.js","PangenomeSchematic.js","ComponentConnectorRect.js","utilities.js","ComponentRect.js","ComponentNucleotides.js","LinkColumn.js","LinkArrow.js","LinkRecord.js","NucleotideTooltip.js","ControlHeader.js","App.js","serviceWorker.js","ViewportInputsStore.js","index.js"],"names":["urlExists","dataName","http","XMLHttpRequest","open","send","status","theUrl","callback","a","xmlHttp","onreadystatechange","readyState","responseText","PangenomeSchematic","props","pathNames","components","jsonCache","nucleotides","loadIndexFile","store","jsonName","observe","chunkFastaURLs","loadFasta","jsonFilename","console","log","indexPath","process","fetch","then","res","json","setChunkIndex","filepath","Error","url","data","json_version","MediaError","this","path_names","processArray","path_fasta","response","text","sequence","replace","substr","push","getBeginBin","getEndBin","beginBin","endBin","chunksProcessed","length","chunkURLs","urlIndex","jsonChunk","x","setBeginColumnX","first_bin","setChunkBeginBin","entries","index","component","componentItem","Component","addChunkProcessed","slice","React","columnX","firstBin","lastBin","last_bin","arrivals","arrival","LinkColumn","departures","departure","relativePixelX","occupants","matrix","num_bin","linkColumn","upstream","downstream","participants","key","edgeToKey","String","padStart","ConnectorRect","state","color","y","width","height","fill","MatrixCell","tooltipContent","pathName","item","ranges","j","start","end","updateCellTooltipContent","inverted","pixelsPerRow","align","verticalAlign","onMouseEnter","onHover","bind","onMouseLeave","onLeave","inversionText","sum","b","arraysEqual","A","B","every","e","indexOf","stringToColorAndOpacity","highlightedLinkColumn","selectedLink","whichLinkToConsider","colorKey","matchColor","stringToColourSave","toString","hash","i","charCodeAt","colour","ComponentRect","handleClick","setState","parts","map","entry","vertical_rank","row_n","renderMatrixRow","updateMaxHeight","uncompressed_y","row","parent","pixelsX","cX","pixelsPerColumn","xBase","this_y","useVerticalCompression","compressed_row_mapping","hasOwnProperty","cell","topOffset","row_number","connectorsColumn","undefined","yOffset","column","reduce","uncompressed_row","renderComponentConnector","verticalRank","uncompressedRow","x_val","useWidthCompression","binScalingFactor","widthInColumns","onClick","renderMatrix","useConnector","renderAllConnectors","ComponentNucleotides","listOfObjects","nucleotideHeight","handleMouseOut","handleMouseOver","updateHighlightedNode","Array","keys","v","pathIndex","contents","linkCells","y_coord","d","opacity","stroke","onMouseOver","onMouseOut","isInfinity","n","Number","isFinite","LinkArrow","link","event","beginEndBin","newBeginBin","newEndBin","mid_bin","destination_bin","Math","abs","max","updateSelectedLink","arrowXCoord","points","xArrival","departureX","xDepart","arrX","turnDirection","departOrigin","departCorner","elevation","departTop","arriveTop","arriveCorner","arriveCornerEnd","isArrival","some","isNaN","calculatePoints","bezier","strokeWidth","stroke-opacity","pointerLength","pointerWidth","tension","LinkRecord","xCoordArrival","xCoordDeparture","calculateLinkCoordinates","schematic","leftXStart","linkToXMapping","schematizeComponent","paddedKey","k","linkToXmapping","distanceSortedLinks","Object","values","sort","distance","elevationOccupied","record","linkBegin","min","linkEnd","range","reserveElevationAirSpace","top","calculateLinkElevations","NucleotideTooltip","MouseTooltip","visible","offsetX","offsetY","style","background","zIndex","cellToolTipContent","ControlHeader","percentage","size","diff","floor","updateBeginEndBin","pathNucPos","path","nucPos","httpGetAsync","pathIndexServerAddress","result","alert","parseInt","ceil","getBinWidth","target","value","options","selectedIndex","setIndexSelectedZoomLevel","indexSelZoomLevel","indexSelectedZoomLevel","availableZoomLevels","id","className","type","defaultValue","onChange","tryJSONpath","title","marginLeft","decIndexSelectedZoomLevel","val","change_zoom_level","incIndexSelectedZoomLevel","shift","readOnly","list","placeholder","updatePathNucPos","getPath","handleJump","updateHeight","updateWidth","VerticalCompressedViewSwitch","checked","toggleUseVerticalCompression","App","layerRef","createRef","layerRef2","timerHighlightingLink","timerSelectionLink","componentDidMount","clientHeight","document","getElementById","getElementsByClassName","position","buttonsHeight","current","getCanvas","_canvas","_updateHighlightedNode","linkRect","highlightedLink","recalcXLayout","clearTimeout","setTimeout","update_state","renderNucleotidesSchematic","loading","nucleotides_slice","chunkBeginBin","Fragment","visibleHeightPixels","schematize","actualWidth","fetchAllChunks","updateSchematicMetadata","recalcY","render","openRelevantChunksFromIndex","makeInspectable","chunkIndex","zoom_levels","setAvailableZoomLevels","selZoomLev","getSelectedZoomLevel","widthInCells","chunkURLarray","fileArrayFasta","currEnd","workingWidth","level","get","ichunk","files","chunk","columnsLeftToAdd","fasta","density","round","calculateEndBinFromScreen","fileArray","URLprefix","filename","switchChunkFastaURLs","switchChunkURLs","chunkPath","jsonFetch","loadJsonCache","warn","all_visible","Set","c","add","sorted","from","row_mapping","count","compress_visible_rows","maxNumRowsAcrossComponents","calcMaxNumRowsAcrossComponents","setLoading","columnsInComponents","accumulator","currentValue","paddingBetweenComponents","links","updateTopOffset","lengths","firstDepartureColumn","beginColumnX","renderLinkColumn","leftPad","localColor","localOpacity","localStroke","renderComponent","renderLink","fontSize","minWidth","leftOffset","ref","renderSortedLinks","loadingMessage","renderSchematic","Boolean","window","location","hostname","match","Chunk","types","model","file","string","maybeNull","integer","component_count","link_count","ZoomLevel","bin_width","array","ChunkIndex","pangenome_length","PathNucPos","optional","maximumHeightThisFrame","pangenomelast_bin","actions","self","newBegin","newEnd","newTopOffset","isSafeInteger","updateHighlightedLink","latestHeight","resetRenderStats","newContents","updateBinScalingFactor","newFactor","toggleUseWidthCompression","toggleUseConnector","arrayOfFile","singleChunk","arr","views","create","ReactDOM","navigator","serviceWorker","ready","registration","unregister"],"mappings":"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","file":"static/js/main.7f01cbba.chunk.js","sourcesContent":["/// a collection of functions to deal with URL requests\n\nexport function urlExists(dataName) {\n  if (dataName === \"\") {\n    return false;\n  } else {\n    //source: https://stackoverflow.com/a/22011478/3067894\n    var http = new XMLHttpRequest();\n    http.open(\"HEAD\", dataName, false);\n    http.send();\n    return http.status !== 404;\n  }\n}\n\nexport async function httpGetAsync(theUrl, callback) {\n  var xmlHttp = new XMLHttpRequest();\n  xmlHttp.onreadystatechange = function () {\n    if (xmlHttp.readyState === 4 && xmlHttp.status === 200)\n      callback(xmlHttp.responseText);\n  };\n  await xmlHttp.open(\"GET\", theUrl, true); // true for asynchronous\n  xmlHttp.send(null);\n}\n","import React from \"react\";\nimport {observe} from \"mobx\";\nimport {urlExists} from \"./URL\";\n\nclass PangenomeSchematic extends React.Component {\n  constructor(props) {\n    /*Only plain objects will be made observable. For non-plain objects it is considered the\n\t\t responsibility of the constructor to initialize the observable properties. Either use\n\t\t the @observable annotation or the extendObservable function.*/\n\n    super(props);\n    this.pathNames = [];\n    this.components = [];\n    this.jsonCache = {}; // URL keys, values are entire JSON file datas\n    // TODO: make jsonCache store React components and save them in mobx\n    // TODO: make FILO queue to remove old jsonCache once we hit max memory usage\n    this.nucleotides = []; // nucleotides attribute and its edges\n\n    this.loadIndexFile(this.props.store.jsonName); //initializes this.chunkIndex\n\n    //STEP #1: whenever jsonName changes, loadIndexFile\n    observe(this.props.store, \"jsonName\", () => {\n      this.loadIndexFile(this.props.store.jsonName);\n    });\n\n    // The FASTA files are read only when there are new chunks to read\n    observe(this.props.store.chunkFastaURLs, () => {\n      this.loadFasta();\n    });\n\n    //STEP #7: JsonCache causes processArray to update chunksProcessed\n    // observe(this.props.store.jsonCache,\n    //     this.processArray.bind(this));\n\n    // console.log(\"public \", process.env.PUBLIC_URL ) //PUBLIC_URL is empty\n  }\n  componentDidUpdate() {\n    // console.log(\"#components: \" + this.components);\n  }\n\n  loadIndexFile(jsonFilename) {\n    console.log(\"STEP #1: whenever jsonName changes, loadIndexFile\");\n\n    let indexPath =\n      process.env.REACT_APP_FETCH + jsonFilename + \"/bin2file.json\";\n    console.log(\"loadIndexFile - START reading\", indexPath);\n    return fetch(indexPath)\n      .then((res) => res.json())\n      .then((json) => {\n        console.log(\"loadIndexFile - END reading\", indexPath);\n\n        //STEP #2: chunkIndex contents loaded\n        this.props.store.setChunkIndex(json);\n      });\n  }\n\n  jsonFetch(filepath) {\n    if (!filepath)\n      throw new Error(\n        \"No filepath given. Ensure chunknames in bin2file.json are correct.\"\n      );\n    console.log(\"Fetching\", filepath);\n    return fetch(filepath).then((res) => res.json());\n  }\n\n  loadJsonCache(url, data) {\n    console.log(\"STEP #6: fetched chunks go into loadJsonCache\");\n\n      if (data.json_version !== 15) {\n      throw MediaError(\n          \"Wrong Data JSON version: was expecting version 15, got \" +\n        data.json_version +\n        \".  \" +\n          \"This version switched to sparse JSON.  \" + // KEEP THIS UP TO DATE!\n          \"Using a mismatched data file and renderer will cause unpredictable behavior,\" +\n          \" instead generate a new data file using github.com/graph-genome/component_segmentation.\"\n      );\n    }\n    this.jsonCache[url] = data;\n    this.pathNames = data.path_names; //TODO: in later JSON versions path_names gets moved to bin2file.json\n    this.processArray();\n  }\n\n  loadFasta() {\n    console.log(\"loadFasta\");\n\n    // Clear the nucleotides information\n    this.nucleotides = [];\n\n    // This loop will automatically cap out at the fasta file corrisponding to the last loaded chunk\n    for (let path_fasta of this.props.store.chunkFastaURLs) {\n      if (urlExists(path_fasta)) {\n        console.log(\"loadFasta - START: \", path_fasta);\n\n        fetch(path_fasta)\n          .then((response) => {\n            return response.text();\n          })\n          .then((text) => {\n            const sequence = text\n              .replace(/.*/, \"\")\n              .substr(1)\n              .replace(/[\\r\\n]+/gm, \"\");\n\n            //split into array of nucleotides\n            this.nucleotides.push(...sequence);\n\n            console.log(\"loadFasta - END: \", path_fasta);\n          });\n      }\n    }\n  }\n\n  /**Parses beginBin to endBin range, returns false if new file needed.\n   * This calculates the pre-render for all contiguous JSON data.\n   * State information is stored in store.chunksProcessed.\n   * Checks if there's new available data to pre-render in processArray()\n   * run through list of urls in order and see if we have data to load.**/\n  processArray() {\n    //TODO: make processArray parallelized by placing outputs in a Key Map and rendering out of order\n    console.log(\n      \"STEP #7: JsonCache causes processArray to update chunksProcessed\"\n    );\n    let store = this.props.store;\n    let [beginBin, endBin] = [store.getBeginBin(), store.getEndBin()];\n\n    if (\n      store.chunksProcessed.length === 0 ||\n      store.chunksProcessed[0] !== this.props.store.chunkURLs[0]\n    ) {\n      this.components = []; // clear all pre-render data\n    }\n    // may have additional chunks to pre-render\n    console.log(\"processArray - parsing components \", beginBin, \" - \", endBin);\n\n    for (let urlIndex = 0; urlIndex < store.chunkURLs.length; urlIndex++) {\n      //if end of pre-render is earlier than end of contiguous available chunks, process new data\n      if (urlIndex >= store.chunksProcessed.length) {\n        //only process if data is available\n        if (store.chunkURLs[urlIndex] in this.jsonCache) {\n          let url = store.chunkURLs[urlIndex];\n          let jsonChunk = this.jsonCache[url];\n\n          console.log(\n            \"processArray - jsonChunk.components[0].x: \" +\n              jsonChunk.components[0].x\n          );\n          if (urlIndex === 0) {\n            // first component in the render\n            store.setBeginColumnX(jsonChunk.components[0].x);\n            console.log(\n              \"processArray - jsonChunk.first_bin: \" + jsonChunk.first_bin\n            );\n            store.setChunkBeginBin(jsonChunk.first_bin);\n          }\n\n          for (let [index, component] of jsonChunk.components.entries()) {\n            if (component.first_bin > 0) {\n              let componentItem = new Component(component, index);\n              this.components.push(componentItem); //TODO: concurrent modification?\n              //if (component.last_bin >= beginBin) { NOTE: we are now reading in whole chunk, this may place\n              //xOffset further right than it was intended when beginBin > chunk.first_bin\n            }\n          }\n          store.addChunkProcessed(url);\n        } else {\n          //we've run into a contiguous chunk that is not available yet\n          return false;\n        }\n      }\n    }\n\n    console.log(\n      \"processArray\",\n      store.chunksProcessed[0],\n      store.chunksProcessed.slice(-1)[0],\n      \"out of\",\n      this.props.store.chunkURLs.length,\n      \"chunks\"\n    );\n    //console.log(this.props)\n\n    return true; //store.chunksProcessed.length > 0;\n  }\n}\n\nclass Component {\n  //extends React.Component{\n  constructor(component, index) {\n    this.columnX = component.x;\n    this.index = index;\n    this.firstBin = component.first_bin;\n    this.lastBin = component.last_bin;\n    this.arrivals = [];\n    for (let arrival of component.arrivals) {\n      this.arrivals.push(new LinkColumn(arrival));\n    }\n    this.departures = [];\n    for (let departure of component.departures) {\n      //don't slice off adjacent here\n      this.departures.push(new LinkColumn(departure));\n    }\n    // we do not know the x val for this component, yet\n    this.relativePixelX = component.x;\n    // deep copy of occupants\n      this.occupants = component.occupants; //Array.from(\n      this.matrix = component.matrix; // Array.from(\n    this.num_bin = this.lastBin - this.firstBin + 1;\n  }\n}\n\nclass LinkColumn {\n  constructor(linkColumn) {\n    this.upstream = linkColumn.upstream;\n    this.downstream = linkColumn.downstream;\n    this.participants = linkColumn.participants; //new Set\n    this.key = this.edgeToKey();\n  }\n  edgeToKey() {\n    /**downstream and upstream are always in the same orientation regardless of if it is a\n     * departing LinkColumn or an arriving LinkColumn.**/\n    return (\n      String(this.downstream).padStart(13, \"0\") +\n      String(this.upstream).padStart(13, \"0\")\n    );\n  }\n}\n\nexport default PangenomeSchematic;\n","import React from \"react\";\nimport { Rect, Text } from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nexport class ConnectorRect extends React.Component {\n  state = {\n    color: this.props.color,\n  };\n\n  render() {\n    return (\n      <Rect\n        x={this.props.x}\n        y={this.props.y}\n        width={this.props.width}\n        height={this.props.height || 1}\n        fill={this.state.color}\n      />\n    );\n  }\n}\n\nConnectorRect.propTypes = {\n  x: PropTypes.number,\n  y: PropTypes.number,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  store: PropTypes.node,\n  color: PropTypes.node,\n};\n\nexport class MatrixCell extends React.Component {\n  onHover() {\n    //tooltip: this.props.item.mean_pos\n\n    // An example: Path_name, Coverage: 0.23, Inversion: 0.0, Pos: 2365-27289\n\n    let tooltipContent = '\"';\n    tooltipContent +=\n      this.props.pathName +\n      '\"\\nCoverage: ' +\n      this.props.item[0] +\n      \"\\nInversion: \" +\n      this.props.item[1] +\n      \"\\nPos: \";\n\n    const ranges = this.props.item[2];\n    for (let j = 0; j < ranges.length; j++) {\n      let start = ranges[j][0];\n      let end = ranges[j][1];\n      if (j === 0) {\n        tooltipContent += start + \"-\" + end;\n      } else {\n        tooltipContent += \",\" + start + \"-\" + end;\n      }\n    }\n    this.props.store.updateCellTooltipContent(tooltipContent); //item[2] is array of ranges\n  }\n\n  onLeave() {\n    this.props.store.updateCellTooltipContent(\"\"); // we don't want any tooltip displayed if we leave the cell\n  }\n\n  /**Reduced number of Text elements generated for inversions,\n   * mouse events restored**/\n  inversionText(inverted) {\n    if (this.props.store.pixelsPerRow > 9 && inverted) {\n      return (\n        <Text\n          x={this.props.x}\n          y={this.props.y}\n          width={this.props.width}\n          height={this.props.height || 1}\n          align={\"center\"}\n          verticalAlign={\"center\"}\n          text={inverted ? \"<\" : \" \"}\n          onMouseEnter={this.onHover.bind(this)}\n          onMouseLeave={this.onLeave.bind(this)}\n        />\n      );\n    } else {\n      return null;\n    }\n  }\n  render() {\n    const inverted = this.props.item[1] > 0.5;\n\n    let color = \"#838383\";\n\n    if (inverted) {\n      color = \"#DE4B39\";\n    }\n\n    if (this.props.item[0] > 1) {\n      color = \"#6A6A6A\";\n    }\n\n    // TODO: if possible, use HTML/CSS to write the '<', avoiding the <Text />s rendering, therefore improving the performance\n    return (\n      <>\n        <Rect\n          x={this.props.x}\n          y={this.props.y}\n          width={this.props.width}\n          height={this.props.height || 1}\n          fill={color}\n          onMouseEnter={this.onHover.bind(this)}\n          onMouseLeave={this.onLeave.bind(this)}\n        ></Rect>\n        {this.inversionText(inverted)}\n      </>\n    );\n  }\n}\n\nMatrixCell.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.node,\n  x: PropTypes.number,\n  y: PropTypes.number,\n  width: PropTypes.number,\n  height: PropTypes.number,\n  color: PropTypes.node,\n  pathName: PropTypes.node,\n};\n","export const zip = (arr, ...arrs) => {\n  /*Credit: https://gist.github.com/renaudtertrais/25fc5a2e64fe5d0e86894094c6989e10*/\n  return arr.map((val, i) => arrs.reduce((a, arr) => [...a, arr[i]], [val]));\n};\n\nexport function sum(a, b) {\n  return a + b;\n}\n\nexport function arraysEqual(A, B) {\n  return (A.length === 0 && B.length === 0) ||\n      (A.length === B.length &&\n          A.every((e) => B.indexOf(e) > -1));\n}\n\nexport function calculateEndBinFromScreen(beginBin, selZoomLev, store) {\n  let deviceWidth = 1920; // TODO: get width from browser\n  let widthInCells = deviceWidth / store.pixelsPerColumn;\n  let chunkURLarray = [];\n  let fileArrayFasta = [];\n\n  let currEnd = beginBin + 1;\n  let workingWidth = 0;\n  //this loop will automatically cap out at the last bin of the file\n  let level = store.chunkIndex.zoom_levels.get(selZoomLev);\n  for (let ichunk = 0; ichunk < level.files.length; ichunk++) {\n    // The \"x\" info is not here\n    let chunk = level.files[ichunk];\n    if (chunk.last_bin >= beginBin) {\n      let width =\n          chunk[\"last_bin\"] -\n          chunk[\"first_bin\"] +\n          chunk[\"component_count\"] +\n          chunk[\"link_count\"];\n      let columnsLeftToAdd = widthInCells - workingWidth;\n      workingWidth += width;\n      chunkURLarray.push(chunk[\"file\"]);\n      if (chunk.fasta !== null) {\n        fileArrayFasta.push(chunk.fasta);\n      }\n      if (workingWidth > widthInCells) {\n        // fractional chunk to add, could cut a Component in half\n        let density = (chunk[\"last_bin\"] - chunk[\"first_bin\"]) / width;\n        currEnd = Math.round(columnsLeftToAdd * density);\n        // currEnd = chunk[\"last_bin\"];\n        break;\n      }\n    }\n  }\n\n  // store.updateBeginEndBin(b, b + widthInCells);\n  //TODO the logic in let width = could be much more complex by looking at\n  //width of components and whether various settings are on.  The consequence\n  //of overestimating widthInCells is to make the shift buttons step too big\n  return [currEnd, chunkURLarray, fileArrayFasta];\n}\n\nexport function range(start, end) {\n  return [...Array(1 + end - start).keys()].map((v) => start + v);\n}\n\nexport function stringToColorAndOpacity(\n    linkColumn,\n    highlightedLinkColumn,\n    selectedLink\n) {\n  const whichLinkToConsider = selectedLink\n      ? selectedLink\n      : highlightedLinkColumn;\n\n  const colorKey = (linkColumn.downstream + 1) * (linkColumn.upstream + 1);\n  if (whichLinkToConsider) {\n    // When the mouse in on a Link, all the other ones will become gray and fade out\n    let matchColor =\n        (whichLinkToConsider.downstream + 1) * (whichLinkToConsider.upstream + 1);\n    // Check if the mouse in on a Link (highlightedLinkColumn) or if a Link was clicked (selectedLink)\n    if ((!highlightedLinkColumn && !selectedLink) || colorKey === matchColor) {\n      return [\n        stringToColourSave(colorKey),\n        1.0,\n        highlightedLinkColumn || selectedLink ? \"black\" : null,\n      ];\n    } else {\n      return [\"gray\", 0.3, null];\n    }\n  } else {\n    return [stringToColourSave(colorKey), 1.0, null];\n  }\n}\n\nexport function stringToColourSave(colorKey) {\n  colorKey = colorKey.toString();\n  let hash = 0;\n  for (let i = 0; i < colorKey.length; i++) {\n    hash = colorKey.charCodeAt(i) + ((hash << 5) - hash);\n  }\n  let colour = \"#\";\n  for (let j = 0; j < 3; j++) {\n    const value = (hash >> (j * 8)) & 0xff;\n    colour += (\"00\" + value.toString(16)).substr(-2);\n  }\n  return colour;\n}\n","/* eslint-disable require-jsdoc */\nimport React from \"react\";\nimport {Rect} from \"react-konva\";\nimport {ConnectorRect, MatrixCell} from \"./ComponentConnectorRect\";\nimport PropTypes from \"prop-types\";\nimport {sum} from \"./utilities\";\n\nexport function compress_visible_rows(components) {\n  /*Returns a Map with key of the original row number and value of the new, compressed row number.\n   * Use this for y values of occupancy and LinkColumn cells.  */\n  let all_visible = new Set();\n  for (let c of components) {\n      for (let row of c.occupants) {\n          all_visible.add(row);\n      }\n  }\n  let sorted = Array.from(all_visible).sort();\n  let row_mapping = {};\n  for (let [count, index] of sorted.entries()) {\n      row_mapping[index] = count;\n  }\n  return row_mapping;\n}\n\n\nclass ComponentRect extends React.Component {\n  state = {\n    color: \"lightgray\",\n  };\n\n  handleClick = () => {\n    if (this.state.color === \"lightgray\") {\n      this.setState({ color: \"lightblue\" });\n    } else if (this.state.color === \"lightblue\") {\n      this.setState({ color: \"lightgray\" });\n    }\n  };\n\n  renderMatrix() {\n    let parts = this.props.item.matrix.map((entry, vertical_rank) => {\n      let row_n = entry[0];\n        return this.renderMatrixRow(entry[1], vertical_rank, row_n);\n    });\n      this.props.store.updateMaxHeight(this.props.item.occupants.length); //Set max observed occupants in mobx store for render height\n    return <>{parts}</>;\n  }\n\n    renderMatrixRow(entry, vertical_rank, uncompressed_y) {\n        let row = entry[1];\n    const parent = this.props.item;\n        //https://github.com/graph-genome/Schematize/issues/87\n        //Sparse matrix includes the relative columns for each bin inside a component\n        //Columns are not necessarily contiguous, but follow the same order as `row`\n        let iColumns = entry[0];\n        let pixelsX = iColumns.map((cX) => cX * this.props.store.pixelsPerColumn)\n        const xBase =\n      parent.relativePixelX +\n      parent.arrivals.length * this.props.store.pixelsPerColumn;\n    const width = 1 * this.props.store.pixelsPerColumn;\n    let this_y = vertical_rank;\n    if (!this.props.store.useVerticalCompression) {\n      if (!this.props.compressed_row_mapping.hasOwnProperty(uncompressed_y)) {\n        return null; // we need compressed_y and we don't have it.  give up\n      }\n      this_y = this.props.compressed_row_mapping[uncompressed_y];\n    }\n\n    return row.map((cell, x) => {\n      if (cell.length) {\n        return (\n          <>\n            <MatrixCell\n                key={\"occupant\" + uncompressed_y + x}\n                item={cell}\n                store={this.props.store}\n                pathName={this.props.pathNames[uncompressed_y]}\n                x={xBase + pixelsX[x]}\n                y={\n                this_y * this.props.store.pixelsPerRow +\n                this.props.store.topOffset\n              }\n                row_number={uncompressed_y}\n                width={width}\n                height={this.props.store.pixelsPerRow}\n            />\n          </>\n        );\n      } else {\n        return null;\n      }\n    });\n  }\n\n  renderAllConnectors() {\n    const departures = this.props.item.departures;\n    let connectorsColumn = departures.slice(-1)[0];\n    if (connectorsColumn !== undefined) {\n      //count starts at the sum(sum(departure columns)) so that it's clear\n      // adjacent connectors are alternatives to LinkColumns\n      //offset the y to start below link columns when using vertical compression\n      let yOffset = departures.slice(0, -1)\n          .map((column) => {\n            return column.participants.length;\n          })\n          .reduce(sum, 0); // sum of trues in all columns\n      return (\n        <>\n          {connectorsColumn.participants.map((uncompressed_row) => {\n            yOffset++;// only used in vertical compression\n            return this.renderComponentConnector(yOffset, uncompressed_row);\n          })}\n        </>\n      );\n    } else {\n      return null;\n    }\n  }\n\n  renderComponentConnector(verticalRank, uncompressedRow) {\n    let component = this.props.item;\n    // x is the (num_bins + num_arrivals + num_departures)*pixelsPerColumn\n    const x_val =\n      component.relativePixelX +\n      (component.arrivals.length +\n        (this.props.store.useWidthCompression\n          ? this.props.store.binScalingFactor\n          : component.num_bin) +\n        component.departures.length -\n        1) *\n        this.props.store.pixelsPerColumn;\n    let this_y = verticalRank;\n    if (!this.props.store.useVerticalCompression) {\n      this_y = this.props.compressed_row_mapping[uncompressedRow];\n    }\n    return (\n      <ConnectorRect\n          key={\"connector\" + uncompressedRow}\n          x={x_val}\n          y={this.props.store.topOffset + this_y * this.props.store.pixelsPerRow}\n          width={this.props.store.pixelsPerColumn} //Clarified and corrected adjacent connectors as based on pixelsPerColumn width #9\n          height={this.props.store.pixelsPerRow}\n          color={\"#464646\"}\n      />\n    );\n  }\n\n  render() {\n    return (\n      <>\n        <Rect\n          x={this.props.item.relativePixelX}\n          y={this.props.store.topOffset}\n          key={this.state.key + \"R\"}\n          width={this.props.widthInColumns * this.props.store.pixelsPerColumn}\n          height={this.props.height - 2} //TODO: change to compressed height\n          fill={this.state.color}\n          onClick={this.handleClick}\n        />\n        {!this.props.store.useWidthCompression ? this.renderMatrix() : null}\n        {this.props.store.useConnector ? this.renderAllConnectors() : null}\n      </>\n    );\n  }\n}\n\nComponentRect.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.object,\n  compressed_row_mapping: PropTypes.object,\n  widthInColumns: PropTypes.number,\n  height: PropTypes.number,\n  pathNames: PropTypes.node,\n};\n\nexport default ComponentRect;\n","import React from \"react\";\nimport { Text } from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nclass ComponentNucleotides extends React.Component {\n  renderMatrixRow() {\n    const parent = this.props.item;\n    const x_val =\n      parent.relativePixelX +\n      parent.arrivals.length * this.props.store.pixelsPerColumn;\n\n    //console.log('x_val: ' + x_val)\n\n    var listOfObjects = [];\n    for (var x = 0; x < this.props.item.num_bin; x++) {\n      listOfObjects.push(\n        <Text\n          key={\"nuc_text\" + x}\n          x={x_val + x * this.props.store.pixelsPerColumn}\n          y={this.props.store.topOffset - this.props.store.nucleotideHeight}\n          text={this.props.nucleotides[x]}\n          align=\"center\"\n          height={this.props.store.nucleotideHeight}\n          width={this.props.store.pixelsPerColumn}\n        />\n      );\n    }\n    return listOfObjects;\n  }\n\n  render() {\n    //console.log('ComponentNucleotides - render')\n    return this.renderMatrixRow();\n  }\n}\n\nComponentNucleotides.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.object,\n  width: PropTypes.node,\n  height: PropTypes.node,\n};\n\nexport default ComponentNucleotides;\n","import React from \"react\";\nimport {Rect} from \"react-konva\";\nimport PropTypes from \"prop-types\";\nimport {range} from \"./utilities\";\n\nclass LinkColumn extends React.Component {\n  constructor(props) {\n    super(props);\n    this.handleMouseOut = this.handleMouseOut.bind(this);\n    this.handleMouseOver = this.handleMouseOver.bind(this);\n  }\n  handleMouseOver() {\n    this.props.updateHighlightedNode(this.props.item);\n  }\n  handleMouseOut() {\n    this.props.updateHighlightedNode(null);\n  }\n  linkCells() {\n      if (!this.props.store.useVerticalCompression) { //regular layout\n          return this.props.item.participants.map((pathIndex) =>\n              this.props.compressed_row_mapping[pathIndex] * this.props.store.pixelsPerRow);\n      }\n      //else, just stack each up at the top of the screen\n      return range(0, this.props.item.participants.length).map(\n          (y) => y * this.props.store.pixelsPerRow);\n  }\n  componentDidMount() {\n    this.setState({\n      color: this.props.color,\n    });\n  }\n  render() {\n    const contents = this.linkCells();\n    return (\n      <>\n        {contents.map((y_coord, d) => {\n          return (\n            <Rect\n              key={\"dot\" + d}\n              x={this.props.x}\n              y={\n                this.props.store.topOffset +\n                y_coord\n              }\n              width={this.props.store.pixelsPerColumn}\n              height={this.props.store.pixelsPerRow}\n              fill={this.props.color}\n              opacity={this.props.opacity}\n              stroke={this.props.stroke}\n              // onClick={this.handleClick}\n              onMouseOver={this.handleMouseOver}\n              onMouseOut={this.handleMouseOut}\n            />\n          );\n        })}\n      </>\n    );\n  }\n}\n\nLinkColumn.propTypes = {\n  store: PropTypes.object,\n  item: PropTypes.object,\n  updateHighlightedNode: PropTypes.func,\n  compressed_row_mapping: PropTypes.object,\n  x: PropTypes.node,\n  column: PropTypes.node,\n  color: PropTypes.node,\n};\n\nexport default LinkColumn;\n","import React from \"react\";\nimport { Arrow } from \"react-konva\";\nimport PropTypes from \"prop-types\";\n\nfunction isInfinity(n) {\n  return !Number.isFinite(n);\n}\n\nclass LinkArrow extends React.Component {\n  /** Serves as a contract to store visual layout information**/\n  constructor(props) {\n    super(props);\n    this.arrowXCoord = null;\n    this.points = [];\n    this.handleMouseOut = this.handleMouseOut.bind(this);\n    this.handleMouseOver = this.handleMouseOver.bind(this);\n  }\n  componentDidUpdate() {\n    //this.calculatePoints(); // AG: is it necessary?\n  }\n\n  calculatePoints() {\n    /*Translates the LinkRecord coordinates into pixels and defines the curve shape.\n     * I've spent way too long fiddling with these numbers at different pixelsPerColumn\n     * I suggest you don't fiddle with them unless you plan on nesting the React\n     * Components to ensure that everything is relative coordinates.*/\n    let link = this.props.link;\n    this.arrowXCoord = this.props.link.xArrival;\n    let absDepartureX = this.props.link.xDepart;\n    // put in relative coordinates to arriving LinkColumn\n    let departureX =\n      absDepartureX - this.arrowXCoord + this.props.store.pixelsPerColumn / 2;\n    let arrX = this.props.store.pixelsPerColumn / 2;\n    let bottom = -2; //-this.props.store.pixelsPerColumn;\n    let turnDirection = departureX < 0 ? -1 : 1;\n    const departOrigin = [departureX, this.props.store.pixelsPerColumn - 2];\n    const departCorner = [departureX - turnDirection, -link.elevation + 2];\n    let departTop = [departureX - turnDirection * 6, -link.elevation];\n    let arriveTop = [arrX + turnDirection * 6, -link.elevation];\n    let arriveCorner = [arrX + turnDirection, -link.elevation + 2]; // 1.5 in from actual corner\n    const arriveCornerEnd = [arrX, -5];\n    this.points = [\n      departOrigin[0],\n      departOrigin[1],\n      departCorner[0],\n      departCorner[1],\n      departTop[0],\n      departTop[1],\n      arriveTop[0],\n      arriveTop[1],\n      arriveCorner[0],\n      arriveCorner[1],\n      arriveCornerEnd[0],\n      arriveCornerEnd[1],\n      arrX,\n      -1,\n    ];\n    if (Math.abs(departureX) <= this.props.store.pixelsPerColumn) {\n      // FIXME Small distances, usually self loops\n      if (link.isArrival) {\n        this.points = [\n          arrX,\n          -10, //-link.elevation - 4,\n          arrX,\n          bottom,\n        ];\n      } else {\n        this.points = [\n          departOrigin[0],\n          bottom + this.props.store.pixelsPerColumn,\n          departOrigin[0],\n          -5,\n        ]; //-link.elevation-this.props.store.pixelsPerColumn*2,];\n      }\n    }\n    if (this.points.some(isNaN) || this.points.some(isInfinity)) {\n      console.log(\"Some points are NaN: \" + this.points);\n    }\n  }\n\n  render() {\n    // if(this.arrowXCoord === null){\n    this.calculatePoints();\n    // }\n    /*upstream={this.props.upstream}\n        downstream={this.props.downstream}\n        */\n\n    return (\n      <Arrow\n        x={this.arrowXCoord}\n        y={this.props.store.topOffset - 10}\n        width={this.props.store.pixelsPerColumn}\n        points={this.points}\n        bezier={false}\n        strokeWidth={this.props.store.pixelsPerColumn}\n        fill={this.props.color}\n        stroke={this.props.color}\n        opacity={this.props.opacity}\n        stroke-opacity={this.props.opacity}\n        pointerLength={1}\n        pointerWidth={1}\n        tension={1 / 3}\n        onMouseOver={this.handleMouseOver}\n        onMouseOut={this.handleMouseOut}\n        onClick={this.handleClick}\n        // lineCap={'round'}\n      />\n    );\n  }\n\n  handleMouseOver = () => {\n    this.props.updateHighlightedNode(this.props.link.linkColumn);\n  };\n  handleMouseOut = () => {\n    this.props.updateHighlightedNode(null);\n  };\n  handleClick = (event) => {\n    /*Jump on Link click rough draft. Detects which end is closest to the view and\n    jumps to the other side. TODO: Still needs visual highlighting at destination.*/\n    console.log(\"Click\", event, this.props.link);\n\n    let [newBeginBin, newEndBin] = this.props.store.beginEndBin;\n\n    const [beginBin, endBin] = this.props.store.beginEndBin;\n\n    // Find middle position of viewport\n    let width = endBin - beginBin;\n    let mid_bin = beginBin + width / 2;\n\n    // Compare with ends of arrow coordinates\n    let end_closer =\n      Math.abs(this.props.link.linkColumn.upstream - mid_bin) <\n      Math.abs(this.props.link.linkColumn.downstream - mid_bin);\n\n    // Identify more distant end\n    let destination_bin = end_closer\n      ? this.props.link.linkColumn.downstream\n      : this.props.link.linkColumn.upstream;\n\n    if (!(destination_bin >= beginBin && destination_bin <= endBin)) {\n      // Calculate beginBin that will place distant end in middle of viewport\n      // The ~~ operator is a double NOT bitwise operator. It is used as a faster substitute for Math.floor().\n      newBeginBin = Math.max(1, ~~(destination_bin - width / 2));\n      newEndBin = newBeginBin + width;\n      // Called after the bin updating to start the timers after the rendering\n    }\n\n    this.props.updateSelectedLink(\n      this.props.link.linkColumn,\n      newBeginBin,\n      newEndBin\n    );\n  };\n}\n\nLinkArrow.propTypes = {\n  store: PropTypes.object,\n  link: PropTypes.object,\n  color: PropTypes.node,\n  updateHighlightedNode: PropTypes.func,\n  updateSelectedLink: PropTypes.func,\n};\n\nexport default LinkArrow;\n","export class LinkRecord {\n  constructor(linkColumn, xCoordArrival = 0, xCoordDeparture = 0, isArrival) {\n    this.linkColumn = linkColumn;\n    if (linkColumn === undefined) {\n      console.log(linkColumn, xCoordArrival, xCoordDeparture);\n    }\n    this.xArrival = xCoordArrival;\n    this.xDepart = xCoordDeparture;\n    this.elevation = 10;\n    this.isArrival = isArrival;\n  }\n  distance() {\n    return Math.abs(this.xDepart - this.xArrival) || 1;\n  }\n}\n\nexport function calculateLinkCoordinates(\n  schematic,\n  pixelsPerColumn,\n  topOffset,\n  useWidthCompression,\n  binScalingFactor,\n  leftXStart\n) {\n  //leftXStart is necessary as a method at the moment\n  /** calculate the x coordinates of all components\n   * calculate the x coordinates of all arrivals and departures */\n\n  /* In this dictionary the key is the global unique paddedKey created by @edgetoKey.\n    The value is a list of size 2:\n    1. Element: the x-coordinate of the arrival link column\n    2. Element: the x-coordinate of the corresponding departure link column */\n  let linkToXMapping = {}; //(paddedKey): [arrivalX, departureX]\n\n  for (let i = 0; i < schematic.length; i++) {\n    let schematizeComponent = schematic[i];\n    //schematizeComponent.relativePixelX = leftXStart(schematizeComponent, i, 0, 0);\n    //ARRIVALS: Calculate all X\n    for (let j = 0; j < schematizeComponent.arrivals.length; j++) {\n      let arrival = schematizeComponent.arrivals[j];\n      let xCoordArrival = leftXStart(schematizeComponent, i, 0, j);\n      let paddedKey = arrival.key;\n      if (!(paddedKey in linkToXMapping)) {\n        //place holder value, go as far right as possible\n        // TODO place holder value in the same place\n        linkToXMapping[paddedKey] = new LinkRecord(\n          arrival,\n          xCoordArrival,\n          xCoordArrival,\n          true\n        );\n      } else {\n        linkToXMapping[paddedKey].xArrival = xCoordArrival; // set with real value\n      }\n    }\n    //DEPARTURES: Calculate all X\n    for (let k = 0; k < schematizeComponent.departures.length - 1; k++) {\n      let departure = schematizeComponent.departures[k];\n      let xCoordDeparture = leftXStart(\n        schematizeComponent,\n        i,\n        schematizeComponent.arrivals.length +\n          (useWidthCompression\n            ? binScalingFactor\n            : schematizeComponent.num_bin),\n        k\n      );\n      let paddedKey = departure.key;\n      if (!(paddedKey in linkToXMapping)) {\n        //place holder value, go as far left as possible\n        // linkToXMapping[paddedKey] = [this.state.actualWidth + 100, xCoordDeparture]\n        linkToXMapping[paddedKey] = new LinkRecord(\n          departure,\n          xCoordDeparture,\n          xCoordDeparture,\n          false\n        );\n      } else {\n        linkToXMapping[paddedKey].xDepart = xCoordDeparture; // set real value\n      }\n    }\n  }\n  return calculateLinkElevations(linkToXMapping, pixelsPerColumn, topOffset);\n}\n\nfunction calculateLinkElevations(linkToXmapping, pixelsPerColumn, topOffset) {\n  /**Starting with the shortest links, claim a spot of elevation to place the link in.\n   * As the links get bigger, you take the max() of the range of the link and add 1.\n   * This claims the \"air space\" for that link to travel through without colliding with anything.\n   * The longest link should end up on top.  We'll probably need a \"link gutter\" maximum to keep\n   * this from getting unreasonably tall.**/\n  let distanceSortedLinks = Object.values(linkToXmapping).sort(\n    (a, b) => a.distance() - b.distance()\n  );\n  let elevationOccupied = reserveElevationAirSpace(\n    distanceSortedLinks,\n    pixelsPerColumn,\n    topOffset\n  );\n  let top = Math.max(...elevationOccupied) + pixelsPerColumn * 3;\n  return [distanceSortedLinks, top];\n}\n\nfunction reserveElevationAirSpace(\n  distanceSortedLinks,\n  pixelsPerColumn,\n  topOffset\n) {\n  /* Set up an array of zeros, then gradually fill it with height stacking\n   * @Simon this section is largely done, it just needs a sorted distanceSortedLinks as input*/\n  let length = Math.max(\n    0,\n    ...distanceSortedLinks.map((x) => Math.max(x.xDepart, x.xArrival))\n  ); //this.props.endBin - this.props.beginBin;\n  let elevationOccupied = new Array(length).fill(15);\n  for (let record of distanceSortedLinks) {\n    let linkBegin = Math.max(0, Math.min(record.xArrival, record.xDepart));\n    let linkEnd = Math.max(record.xArrival, record.xDepart, linkBegin + 1);\n    let range = elevationOccupied.slice(linkBegin, linkEnd + 1);\n    let elevation = range.length ? Math.max(...range) : 10;\n    if (isNaN(elevation) || !Number.isFinite(elevation)) {\n      console.log(\n        \"Bad elevation\",\n        record,\n        linkBegin,\n        linkEnd,\n        range,\n        elevationOccupied\n      );\n    }\n    const stillSmall = true; //elevation < topOffset / 3;\n    elevation += stillSmall ? pixelsPerColumn : pixelsPerColumn / 4;\n    for (let x = linkBegin; x < linkEnd && x < elevationOccupied.length; x++) {\n      elevationOccupied[x] = elevation;\n    }\n    record.elevation = elevation; //storing final value for render\n  }\n  return elevationOccupied;\n}\n","import React from \"react\";\nimport MouseTooltip from \"react-sticky-mouse-tooltip\";\nimport {Observer} from \"mobx-react\";\nimport PropTypes from \"prop-types\";\n\nexport default class NucleotideTooltip extends React.Component {\n  render() {\n    return (\n      <MouseTooltip\n          visible={true}\n          offsetX={15}\n          offsetY={-20}\n          style={{background: \"white\", zIndex: 4, \"whiteSpace\": \"pre-line\"}}\n      >\n        <Observer>\n          {() => <span>{this.props.store.cellToolTipContent}</span>}\n        </Observer>\n      </MouseTooltip>\n    );\n  }\n}\n\nNucleotideTooltip.propTypes = {\n  store: PropTypes.object,\n};\n","import React from \"react\";\nimport {Observer} from \"mobx-react\";\nimport {httpGetAsync} from \"./URL\";\nimport PropTypes from \"prop-types\";\n\nclass ControlHeader extends React.Component {\n  shift(percentage) {\n    const beginBin = this.props.store.getBeginBin();\n    const endBin = this.props.store.getEndBin();\n    let size = endBin - beginBin;\n    let diff = Math.floor(size * (percentage / 100));\n    console.log(endBin + \"-\" + beginBin + \"=\" + size + \" --> diff: \" + diff);\n    this.props.store.updateBeginEndBin(beginBin + diff, endBin + diff);\n  }\n\n  handleJump() {\n    console.log(\n      \"JUMP: path name: \" +\n        this.props.store.pathNucPos.path +\n        \" nucleotide position: \" +\n        this.props.store.pathNucPos.nucPos\n    );\n    // I don't know why, but in order for the CORS headers to exchange we need to make a first GET request to \"/hi\" which will not return anything\n\n    const store = this.props.store;\n    const addr = store.pathIndexServerAddress;\n    const path_name = store.pathNucPos.path;\n    const nuc_pos = store.pathNucPos.nucPos;\n\n    function handleOdgiServerResponse(result) {\n      if (result === \"0\") {\n        alert(\n          \"The jump query returned 0. Either your path does not exist or your position in the path is wrong. Please try again.\"\n        );\n      } else {\n        console.log(result);\n        // go from nucleotide position to bin\n        result = parseInt(result);\n        const newBeginBin = Math.ceil(result / this.props.store.getBinWidth());\n        console.log(newBeginBin);\n        store.updateBeginEndBin(newBeginBin, store.getEndBin());\n      }\n    }\n    // httpGetAsync(addr + \"hi\", printResult);\n    // httpGetAsync(addr + \"5/1\", printResult);\n    // httpGetAsync(addr + \"4/3\", printResult);\n    httpGetAsync(addr + path_name + \"/\" + nuc_pos, handleOdgiServerResponse);\n  }\n\n  // AG\n  change_zoom_level(target) {\n    console.log(\n      \"change_zoom_level: \" +\n        target.value +\n        \" ---\" +\n        target.options[target.selectedIndex].text\n    );\n    this.props.store.setIndexSelectedZoomLevel(parseInt(target.value));\n  }\n\n  decIndexSelectedZoomLevel() {\n    let indexSelZoomLevel = this.props.store.indexSelectedZoomLevel;\n    if (indexSelZoomLevel > 0) {\n      this.props.store.setIndexSelectedZoomLevel(indexSelZoomLevel - 1);\n    }\n  }\n\n  incIndexSelectedZoomLevel() {\n    let indexSelZoomLevel = this.props.store.indexSelectedZoomLevel;\n    if (indexSelZoomLevel < this.props.store.availableZoomLevels.length - 1) {\n      this.props.store.setIndexSelectedZoomLevel(indexSelZoomLevel + 1);\n    }\n  }\n\n  render() {\n    return (\n      <div id=\"button-container\">\n        <button className=\"button\" id=\"btn-download\">\n          Save Image\n        </button>\n        <input\n          type=\"text\"\n          defaultValue={this.props.store.jsonName}\n          style={{ width: \"330px\" }}\n          onChange={this.props.store.tryJSONpath}\n          title={\"File:\"}\n        />\n        <span style={{ marginLeft: \"30px\" }}>\n          <Observer>\n            {() => (\n              <>\n                Bin width:\n                <button\n                  className=\"button\"\n                  onClick={() => this.decIndexSelectedZoomLevel()}\n                >\n                  -\n                </button>\n                <select\n                  id=\"select_bin_width\"\n                  onChange={(val) => this.change_zoom_level(val.target)}\n                  value={this.props.store.indexSelectedZoomLevel}\n                >\n                  {this.props.store.availableZoomLevels.map((item, i) => (\n                    <option key={i} value={i}>\n                      {item}\n                    </option>\n                  ))}\n                </select>\n                <button\n                  className=\"button\"\n                  onClick={() => this.incIndexSelectedZoomLevel()}\n                >\n                  +\n                </button>\n              </>\n            )}\n          </Observer>\n        </span>\n\n        <span style={{ marginLeft: \"30px\" }}>\n          <button className=\"button\" onClick={() => this.shift(-100)}>\n            &lt;&lt;\n          </button>\n          <button className=\"button\" onClick={() => this.shift(-50)}>\n            &lt;\n          </button>\n          Pangenome Bin Position:\n          <Observer>\n            {() => (\n              <>\n                <input\n                  type=\"number\"\n                  value={this.props.store.beginEndBin[0]} // TODO Get methods don't work here, but I don't know why. Need to ask Robert Buels.\n                  onChange={(event) =>\n                    this.props.store.updateBeginEndBin(\n                      event.target.value,\n                      this.props.store.getEndBin()\n                    )\n                  }\n                  style={{ width: \"80px\" }}\n                />\n                -\n                <input\n                  type=\"number\"\n                  value={this.props.store.beginEndBin[1]}\n                  readOnly\n                  style={{ width: \"80px\" }}\n                />\n              </>\n            )}\n          </Observer>\n          <button className=\"button\" onClick={() => this.shift(50)}>\n            &gt;\n          </button>\n          <button className=\"button\" onClick={() => this.shift(100)}>\n            &gt;&gt;\n          </button>\n        </span>\n        <div className={\"row\"}>\n          Jump to path at nucleotide position:\n          <input\n            type=\"string\"\n            list=\"path\"\n            placeholder={\"path\"}\n            onChange={(event) =>\n              this.props.store.updatePathNucPos(\n                event.target.value,\n                this.props.store.pathNucPos.nucPos\n              )\n            }\n            style={{ width: \"80px\" }}\n          />\n          <datalist id=\"path\">\n            {this.props.schematic.pathNames.map((item, key) => (\n              <option key={key} value={item} />\n            ))}\n          </datalist>\n          -\n          <input\n            type=\"number\"\n            placeholder={\"position\"}\n            onChange={(event) =>\n              this.props.store.updatePathNucPos(\n                this.props.store.getPath(),\n                event.target.value\n              )\n            }\n            style={{ width: \"80px\" }}\n          />\n          <span style={{ marginLeft: \"2px\" }}>\n            <button className=\"button\" onClick={() => this.handleJump()}>\n              Jump\n            </button>\n          </span>\n        </div>\n        <div className={\"row\"}>\n          <span>\n            {\" \"}\n            Use Vertical Compression:\n            <VerticalCompressedViewSwitch store={this.props.store} />\n          </span>\n            {/*<span>*/}\n            {/*  {\" \"}*/}\n            {/*    Show Only Rearrangements:*/}\n            {/*  <WidthCompressedViewSwitch store={this.props.store} />*/}\n            {/*</span>*/}\n            {/*{this.props.store.useWidthCompression ? (*/}\n            {/*  <React.Fragment>*/}\n            {/*    <span>*/}\n            {/*      {\" \"}*/}\n            {/*      Render Connectors:*/}\n            {/*      <RenderConnectorSwitch store={this.props.store} />*/}\n            {/*    </span>*/}\n\n            {/*  </React.Fragment>*/}\n            {/*) : (*/}\n            {/*  <></>*/}\n            {/*)}*/}\n          <span>\n            {\" \"}\n            Row Height:\n            <Observer>\n              {() => (\n                  <input\n                      type=\"number\"\n                      min={1}\n                      value={this.props.store.pixelsPerRow}\n                      onChange={this.props.store.updateHeight}\n                      style={{width: \"30px\"}}\n                  />)}\n            </Observer>\n          </span>\n          <span>\n            {\" \"}\n            Column Width:\n            <input\n              type=\"number\"\n              min={1}\n              value={this.props.store.pixelsPerColumn}\n              onChange={this.props.store.updateWidth}\n              style={{ width: \"30px\" }}\n            />\n          </span>\n        </div>\n      </div>\n    );\n  }\n}\n\nControlHeader.propTypes = {\n  store: PropTypes.object,\n};\n\nclass VerticalCompressedViewSwitch extends React.Component {\n  render() {\n    return (\n      <Observer>\n        {() => (\n          <input\n            type=\"checkbox\"\n            checked={this.props.store.useVerticalCompression}\n            onChange={this.props.store.toggleUseVerticalCompression}\n          />\n        )}\n      </Observer>\n    );\n  }\n}\n\nVerticalCompressedViewSwitch.propTypes = {\n  store: PropTypes.object,\n};\n\nclass RenderConnectorSwitch extends React.Component {\n  render() {\n    return (\n      <Observer>\n        {() => (\n          <input\n            type=\"checkbox\"\n            checked={this.props.store.useConnector}\n            onChange={this.props.store.toggleUseConnector}\n          />\n        )}\n      </Observer>\n    );\n  }\n}\n\nRenderConnectorSwitch.propTypes = {\n  store: PropTypes.object,\n};\n\nclass WidthCompressedViewSwitch extends React.Component {\n  render() {\n    return (\n      <Observer>\n        {() => (\n          <input\n            type=\"checkbox\"\n            checked={this.props.store.useWidthCompression}\n            onChange={this.props.store.toggleUseWidthCompression}\n          />\n        )}\n      </Observer>\n    );\n  }\n}\n\nWidthCompressedViewSwitch.propTypes = {\n  store: PropTypes.object,\n};\n\nexport default ControlHeader;\n","import { Layer, Stage, Text } from \"react-konva\";\nimport React, { Component } from \"react\";\n\nimport \"./App.css\";\nimport PangenomeSchematic from \"./PangenomeSchematic\";\nimport ComponentRect, { compress_visible_rows } from \"./ComponentRect\";\nimport ComponentNucleotides from \"./ComponentNucleotides\";\nimport LinkColumn from \"./LinkColumn\";\nimport LinkArrow from \"./LinkArrow\";\nimport { calculateLinkCoordinates } from \"./LinkRecord\";\nimport NucleotideTooltip from \"./NucleotideTooltip\";\nimport ControlHeader from \"./ControlHeader\";\nimport { observe } from \"mobx\";\nimport {\n  arraysEqual,\n  calculateEndBinFromScreen,\n  stringToColorAndOpacity,\n} from \"./utilities\";\n\nimport makeInspectable from \"mobx-devtools-mst\";\n\nclass App extends Component {\n  layerRef = React.createRef();\n  layerRef2 = React.createRef(null);\n  timerHighlightingLink = null;\n  timerSelectionLink = null;\n\n  constructor(props) {\n    super(props);\n\n    this.updateHighlightedNode = this.updateHighlightedNode.bind(this);\n    this.updateSelectedLink = this.updateSelectedLink.bind(this);\n\n    this.state = {\n      schematize: [],\n      pathNames: [],\n      actualWidth: 1,\n      buttonsHeight: 0,\n    };\n    this.schematic = new PangenomeSchematic({ store: this.props.store }); //Read file, parse nothing\n\n    /* == State control flow --> redundancies here can waste processing time\n    * STEP #1: whenever jsonName changes, loadIndexFile\n    * STEP #2: chunkIndex contents loaded\n    * STEP #3: with new chunkIndex, this.openRelevantChunksFromIndex()\n    * STEP #4: Set switchChunkURLs\n    * STEP #5: once ChunkURLs are listed, go fetchAllChunks\n    * STEP #6: fetched chunks go into loadJsonCache\n    * STEP #7: JsonCache causes processArray to update chunksProcessed\n    * STEP #8: chunksProcessed finishing triggers updateSchematicMetadata with final rendering info for this loaded chunks\n      * STEP #9: reserveAirspace\n      * STEP #10: calcMaxNumRowsAcrossComponents\n    //TODO: separate processArray into its  own observer\n    * STEP #11: Y values calculated, trigger do the render\n    * */\n\n    //Arrays must be observed directly, simple objects are observed by name\n    //STEP #5: once ChunkURLs are listed, go fetchAllChunks\n    observe(this.props.store.chunkURLs, this.fetchAllChunks.bind(this));\n\n    // observe(this.props.store, \"pixelsPerRow\", this.recalcY.bind(this));\n    observe(\n      this.props.store,\n      \"useVerticalCompression\",\n      this.updateSchematicMetadata.bind(this)\n    );\n    observe(\n      this.props.store,\n      \"useWidthCompression\",\n      this.recalcXLayout.bind(this)\n    );\n    observe(this.props.store, \"useConnector\", this.recalcXLayout.bind(this)); //TODO faster rerender\n    observe(this.props.store, \"pixelsPerColumn\", this.recalcXLayout.bind(this)); //TODO faster rerender\n    observe(this.props.store, \"pixelsPerRow\", this.recalcY.bind(this)); //TODO faster rerender\n\n    //STEP #8: chunksProcessed finishing triggers updateSchematicMetadata with final\n    // rendering info for this loaded chunks\n    observe(\n      this.props.store.chunksProcessed,\n      this.updateSchematicMetadata.bind(this)\n    );\n\n    //STEP #11: Y values calculated, trigger do the render\n    observe(this.props.store, \"loading\", this.render.bind(this));\n\n    //STEP #3: with new chunkIndex, openRelevantChunksFromIndex\n    observe(\n      this.props.store,\n      \"chunkIndex\", //TODO: this is currently not triggering on input change. No idea why\n      this.openRelevantChunksFromIndex.bind(this)\n    );\n\n    observe(\n      this.props.store,\n      \"indexSelectedZoomLevel\",\n      this.openRelevantChunksFromIndex.bind(this) // Whenever the selected zoom level changes\n    );\n    observe(\n      this.props.store.beginEndBin, //user moves start position\n      //This following part is important to scroll right and left on browser\n      this.openRelevantChunksFromIndex.bind(this)\n    );\n\n    makeInspectable(this.props.store);\n  }\n\n  /** Compares bin2file @param indexContents with the beginBin and EndBin.\n   * It finds the appropriate chunk URLS from the index and updates\n   * switchChunkURLs which trigger json fetches for the new chunks. **/\n  openRelevantChunksFromIndex() {\n    console.log(\n      \"STEP #3: with new chunkIndex, this.openRelevantChunksFromIndex()\"\n    );\n\n    if (\n      this.props.store.chunkIndex === null ||\n      !this.props.store.chunkIndex.zoom_levels.keys()\n    ) {\n      return; //before the class is fully initialized\n    }\n    const beginBin = this.props.store.getBeginBin();\n\n    // With new chunkIndex, it sets the available zoom levels\n    this.props.store.setAvailableZoomLevels(\n      this.props.store.chunkIndex[\"zoom_levels\"].keys()\n    );\n    const selZoomLev = this.props.store.getSelectedZoomLevel();\n    let [endBin, fileArray, fileArrayFasta] = calculateEndBinFromScreen(\n      beginBin,\n      selZoomLev,\n      this.props.store\n    );\n    //TODO: commented because maybe it creates problems\n    //this.props.store.updateBeginEndBin(beginBin, endBin);\n\n    console.log([selZoomLev, endBin, fileArray, fileArrayFasta]);\n    let URLprefix =\n      process.env.REACT_APP_FETCH +\n      this.props.store.jsonName +\n      \"/\" +\n      selZoomLev +\n      \"/\";\n    fileArray = fileArray.map((filename) => {\n      return URLprefix + filename;\n    });\n    fileArrayFasta = fileArrayFasta.map((filename) => {\n      return URLprefix + filename;\n    });\n\n    this.props.store.switchChunkFastaURLs(fileArrayFasta);\n\n    // If there are no new chunck, it has only to recalcualte the X layout\n    if (!this.props.store.switchChunkURLs(fileArray)) {\n      this.recalcXLayout();\n    }\n  }\n\n  fetchAllChunks() {\n    /*Dispatches fetches for all chunk files\n     * Read https://github.com/graph-genome/Schematize/issues/22 for details\n     */\n    console.log(\"STEP #5: once ChunkURLs are listed, go fetchAllChunks\");\n    console.log(\"fetchAllChunks\", this.props.store.chunkURLs);\n    if (!this.props.store.chunkURLs.get(0)) {\n      console.warn(\"No chunk URL defined.\");\n      return;\n    }\n    for (let chunkPath of this.props.store.chunkURLs) {\n      //TODO: conditional on jsonCache not already having chunk\n      console.log(\"fetchAllChunks - START reading: \" + chunkPath);\n      this.schematic.jsonFetch(chunkPath).then((data) => {\n        console.log(\"fetchAllChunks - END reading: \" + chunkPath);\n        this.schematic.loadJsonCache(chunkPath, data);\n      });\n    }\n  }\n\n  updateSchematicMetadata() {\n    if (\n      arraysEqual(this.props.store.chunkURLs, this.props.store.chunksProcessed)\n    ) {\n      console.log(\n        \"updateSchematicMetadata #components: \" +\n          this.schematic.components.length\n      );\n      console.log(\n        \"STEP #8: chunksProcessed finishing triggers updateSchematicMetadata with final rendering info for this loaded chunks\"\n      );\n\n      // console.log(this.schematic.components);\n      this.setState(\n        {\n          schematize: this.schematic.components,\n          pathNames: this.schematic.pathNames,\n        },\n        () => {\n          this.recalcXLayout();\n\n          this.compressed_row_mapping = compress_visible_rows(\n            this.schematic.components\n          );\n          this.maxNumRowsAcrossComponents = this.calcMaxNumRowsAcrossComponents(\n            this.schematic.components\n          ); // TODO add this to mobx-state-tree\n          this.props.store.setLoading(false);\n        }\n      );\n    }\n  }\n\n  recalcXLayout() {\n    console.log(\"recalcXLayout\");\n\n    // In this way the updated relativePixelX information is available everywhere for the rendering\n    for (const [\n      i,\n      schematizeComponent,\n    ] of this.schematic.components.entries()) {\n      schematizeComponent.relativePixelX = this.leftXStart(\n        schematizeComponent,\n        i,\n        0,\n        0\n      );\n    }\n\n    const sum = (accumulator, currentValue) => accumulator + currentValue;\n    const columnsInComponents = this.schematic.components\n      .map(\n        (component) =>\n          component.arrivals.length +\n          (component.departures.length - 1) +\n          (this.props.store.useWidthCompression\n            ? this.props.store.binScalingFactor\n            : component.lastBin - component.firstBin) +\n          1\n      )\n      .reduce(sum, 0);\n    const paddingBetweenComponents =\n      this.props.store.pixelsPerColumn * this.schematic.components.length;\n    const actualWidth =\n      columnsInComponents * this.props.store.pixelsPerColumn +\n      paddingBetweenComponents;\n    this.setState({\n      actualWidth: actualWidth,\n    });\n    const [links, top] = calculateLinkCoordinates(\n      this.schematic.components,\n      this.props.store.pixelsPerColumn,\n      this.props.store.topOffset,\n      this.props.store.useWidthCompression,\n      this.props.store.binScalingFactor,\n      this.leftXStart.bind(this)\n    );\n    this.distanceSortedLinks = links;\n    this.props.store.updateTopOffset(parseInt(top));\n  }\n\n  recalcY() {\n    // forceUpdate() doesn't work with callback function\n    this.setState({ highlightedLink: null }); // nothing code to force update.\n  }\n\n  calcMaxNumRowsAcrossComponents(components) {\n      let lengths = components.map((x) => {\n          return x.occupants.length;\n      })\n      return Math.max(...lengths); //this should likely be faster than doing a search for true values\n  }\n\n  visibleHeightPixels() {\n    if (\n      this.props.store.useVerticalCompression ||\n      !this.compressed_row_mapping\n    ) {\n      // this.state.schematize.forEach(value => Math.max(value.occupants.filter(Boolean).length, maxNumberRowsInOneComponent));\n      if (this.maxNumRowsAcrossComponents === undefined) {\n        this.maxNumRowsAcrossComponents = this.calcMaxNumRowsAcrossComponents(\n          this.schematic.components\n        );\n      }\n      console.log(\n        \"maxNumRowsAcrossComponents\",\n        this.maxNumRowsAcrossComponents\n      );\n\n      return (\n        (this.maxNumRowsAcrossComponents + 2.5) * this.props.store.pixelsPerRow\n      );\n    } else {\n      return (\n        //TODO: NOTE that Object.keys is wrong if you change compressed_row_mapping to a mobx object\n        (Object.keys(this.compressed_row_mapping).length + 0.25) *\n        this.props.store.pixelsPerRow\n      );\n    }\n  }\n\n  componentDidMount = () => {\n    let buttonContainerDiv = document.getElementById(\"button-container\");\n    let clientHeight = buttonContainerDiv.clientHeight;\n\n    const arrowsDiv = document.getElementsByClassName(\"konvajs-content\")[0];\n    arrowsDiv.style.position = \"relative\";\n\n    this.setState({ buttonsHeight: clientHeight });\n\n    this.layerRef.current.getCanvas()._canvas.id = \"cnvs\";\n    this.layerRef.current.getCanvas()._canvas.position = \"relative\";\n\n    this.layerRef2.current.getCanvas()._canvas.id = \"arrow\";\n    this.layerRef2.current.getCanvas()._canvas.position = \"relative\";\n    //this.layerRef2.current.getCanvas()._canvas.style.top = \"95px\";\n    /*if(this.props.store.useVerticalCompression) {\n      this.props.store.resetRenderStats(); //FIXME: should not require two renders to get the correct number\n    }*/\n  };\n\n  // Now it is wrapped in the updateHighlightedNode() function\n  _updateHighlightedNode = (linkRect) => {\n    this.setState({ highlightedLink: linkRect });\n    this.recalcXLayout();\n  };\n\n  // Wrapper function to wrap the logic (no link selected and time delay)\n  updateHighlightedNode = (linkRect) => {\n    // The highlighting has to work only if there isn't any selected link\n    if (!this.state.selectedLink) {\n      if (linkRect != null) {\n        // It comes from an handleMouseOver event\n\n        clearTimeout(this.timerHighlightingLink);\n\n        // To avoid unnecessary rendering when linkRect is still the this.state.highlightedLink link.\n        if (this.state.highlightedLink !== linkRect) {\n          // This ES6 syntaxt avoid to pass the result of the callback to setTimeoutwork.\n          // It works because the ES6 arrow function does not change the context of this.\n          this.timerHighlightingLink = setTimeout(\n            () => {\n              this._updateHighlightedNode(linkRect);\n            },\n            600 // TODO: value to tune. Create a config file where all these hard-coded settings will be\n          );\n        }\n      } else {\n        // It comes from an handleMouseOut event\n\n        clearTimeout(this.timerHighlightingLink);\n\n        // To avoid unnecessary rendering when linkRect == null and this.state.highlightedLink is already null for any reason.\n        if (this.state.highlightedLink != null) {\n          this.timerHighlightingLink = setTimeout(\n            () => {\n              this._updateHighlightedNode(linkRect);\n            },\n            600 // TODO: value to tune. Create a config file where all these hard-coded settings will be\n          );\n        }\n      }\n    }\n  };\n\n  updateSelectedLink = (linkRect, newBeginBin, newEndBin) => {\n    console.log(\"updateSelectedLink\");\n\n    const [beginBin, endBin] = this.props.store.beginEndBin;\n\n    // if (linkRect !== this.state.selectedLink) //else it is a re-clik on the same link, so do nothing here\n    // TODO: simplify this part, avoiding operations if the arrow is already visibile in the screen\n    let update_state = false;\n    if (!(beginBin <= newBeginBin && newEndBin <= endBin)) {\n      console.log(\"updateSelectedLink - NewBeginEndBin\");\n\n      this.props.store.updateBeginEndBin(newBeginBin, newEndBin);\n      update_state = true;\n    }\n\n    clearTimeout(this.timerHighlightingLink);\n\n    // Update the rendering if it is selected a new arrow (or deselected the last one) or\n    // if the range in changed (clicking on a new arrow or recliking on the same one)\n    if (linkRect !== this.selectedLink || update_state) {\n      console.log(\"updateSelectedLink - NewSelection\");\n\n      this.setState({\n        highlightedLink: linkRect,\n        selectedLink: linkRect,\n      });\n    }\n\n    // Auto de-selection after a delay\n    if (linkRect) {\n      console.log(\"Timer deselection\");\n\n      // Eventually restart the timer if it was already ongoing\n      clearTimeout(this.timerSelectionLink);\n\n      this.timerSelectionLink = setTimeout(\n        () => {\n          const [beginBin, endBin] = this.props.store.beginEndBin;\n          this.updateSelectedLink(null, beginBin, endBin);\n        },\n        5000 // TODO: to tune. Create a config file where all these hard-coded settings will be\n      );\n    }\n  };\n\n  leftXStart(schematizeComponent, i, firstDepartureColumn, j) {\n    /*\n    Return the x coordinate pixel that starts the LinkColumn at i, j\n    \n    If this.props.store.useWidthCompression is false:\n    - \"schematizeComponent.columnX - this.props.store.beginColumnX\" calculates the offset of the current chunk respect to the first chunk loaded\n    - \"this.props.store.getBeginBin() - this.props.store.chunkBeginBin\":\" calculates the offset of the current visualized window respect to the starting bin coordinate\n    */\n\n    let previousColumns = !this.props.store.useWidthCompression\n      ? schematizeComponent.columnX -\n        this.props.store.beginColumnX -\n        (this.props.store.getBeginBin() - this.props.store.chunkBeginBin - 1)\n      : schematizeComponent.columnX +\n        (schematizeComponent.index - this.schematic.components[0].index) *\n          this.props.store.binScalingFactor;\n\n    let pixelsFromColumns =\n      (previousColumns + firstDepartureColumn + j) *\n      this.props.store.pixelsPerColumn;\n\n    /*console.log(i, firstDepartureColumn, j)\n    console.log('previousColumns (' + previousColumns + ') = columnX (\n    ' + schematizeComponent.columnX + ') - beginColumnX (' + this.props.store.beginColumnX + ')\n     - (getBeginBin (' + this.props.store.getBeginBin() + ') -\n     chunkBeginBin (' + this.props.store.chunkBeginBin + ') - 1)')\n    console.log('pixelsFromColumns: ' + pixelsFromColumns)*/\n\n    return pixelsFromColumns + i * this.props.store.pixelsPerColumn;\n  }\n\n  renderComponent(schematizeComponent, i, pathNames) {\n    return (\n      <>\n        <ComponentRect\n          store={this.props.store}\n          item={schematizeComponent}\n          key={\"r\" + i}\n          height={this.visibleHeightPixels()}\n          widthInColumns={\n            schematizeComponent.arrivals.length +\n            (this.props.store.useWidthCompression\n              ? this.props.store.binScalingFactor\n              : schematizeComponent.num_bin) +\n            (schematizeComponent.departures.length - 1)\n          }\n          compressed_row_mapping={this.compressed_row_mapping}\n          pathNames={pathNames}\n        />\n\n        {schematizeComponent.arrivals.map((linkColumn, j) => {\n          return this.renderLinkColumn(\n            schematizeComponent,\n            i,\n            0,\n            j,\n            linkColumn\n          );\n        })}\n        {schematizeComponent.departures.slice(0, -1).map((linkColumn, j) => {\n          let leftPad =\n            schematizeComponent.arrivals.length +\n            (this.props.store.useWidthCompression\n              ? this.props.store.binScalingFactor\n              : schematizeComponent.num_bin);\n          return this.renderLinkColumn(\n            schematizeComponent,\n            i,\n            leftPad,\n            j,\n            linkColumn\n          );\n        })}\n      </>\n    );\n  }\n\n  renderLinkColumn(\n    schematizeComponent,\n    i,\n    firstDepartureColumn,\n    j,\n    linkColumn\n  ) {\n    const xCoordArrival = this.leftXStart(\n      schematizeComponent,\n      i,\n      firstDepartureColumn,\n      j\n    );\n    const [localColor, localOpacity, localStroke] = stringToColorAndOpacity(\n      linkColumn,\n      this.state.highlightedLink,\n      this.state.selectedLink\n    );\n    return (\n      <LinkColumn\n        store={this.props.store}\n        key={\"departure\" + i + j}\n        item={linkColumn}\n        pathNames={this.state.pathNames}\n        x={xCoordArrival}\n        pixelsPerRow={this.props.store.pixelsPerRow}\n        width={this.props.store.pixelsPerColumn}\n        color={localColor}\n        opacity={localOpacity}\n        stroke={localStroke}\n        updateHighlightedNode={this.updateHighlightedNode}\n        compressed_row_mapping={this.compressed_row_mapping}\n      />\n    );\n  }\n\n  renderLink(link) {\n    const [localColor, localOpacity] = stringToColorAndOpacity(\n      link.linkColumn,\n      this.state.highlightedLink,\n      this.state.selectedLink\n    );\n\n    return (\n      <LinkArrow\n        store={this.props.store}\n        key={\"arrow\" + link.linkColumn.key}\n        link={link}\n        color={localColor}\n        opacity={localOpacity}\n        updateHighlightedNode={this.updateHighlightedNode}\n        updateSelectedLink={this.updateSelectedLink}\n      />\n    );\n  }\n\n  renderNucleotidesSchematic = () => {\n    if (\n      !this.props.store.loading &&\n      // The conditions on bitWidht and useWidthCompression are lifted here,\n      // avoiding any computation if nucleotides have not to be visualized.\n      this.props.store.getBinWidth() === 1 &&\n      !this.props.store.useWidthCompression &&\n      this.props.store.pixelsPerColumn >= 10 &&\n      this.schematic.nucleotides.length > 0\n    ) {\n      //console.log('renderNucleotidesSchematic - START')\n      return this.schematic.components.map((schematizeComponent, i) => {\n        //TODO: maybe it is not necessary, to confirm its elimination\n        // Check if there are nucleotides (which cover the range [this.schematic.first_bin, this.schematic.last_bin])\n        // associated to the component to visualize (which cover the range [schematizeComponent.firstBin, schematizeComponent.lastBin])\n        /*if (\n          !(\n            this.schematic.first_bin <= schematizeComponent.firstBin &&\n            schematizeComponent.firstBin <= schematizeComponent.lastBin &&\n            schematizeComponent.lastBin <= this.schematic.last_bin\n          )\n        ) {\n          return null;\n        }*/\n\n        /*if (\n          schematizeComponent.firstBin === schematizeComponent.lastBin &&\n          schematizeComponent.firstBin === 0\n        ) {\n          return null; // Dummy component\n        }*/\n\n        //TODO: question if this.props.store.chunkBeginBin is necessary\n        const nucleotides_slice = this.schematic.nucleotides.slice(\n          schematizeComponent.firstBin - this.props.store.chunkBeginBin,\n          schematizeComponent.lastBin - this.props.store.chunkBeginBin + 1\n        );\n\n        //console.log(\"nucleotides_slice: \" + nucleotides_slice);\n\n        return (\n          <React.Fragment key={\"nt\" + i}>\n            <ComponentNucleotides\n              store={this.props.store}\n              item={schematizeComponent}\n              key={i}\n              height={this.visibleHeightPixels()}\n              width={\n                schematizeComponent.arrivals.length +\n                (this.props.store.useWidthCompression\n                  ? this.props.store.binScalingFactor\n                  : schematizeComponent.num_bin) +\n                (schematizeComponent.departures.length - 1)\n              }\n              // They are passed only the nucleotides associated to the current component\n              nucleotides={nucleotides_slice}\n            />\n          </React.Fragment>\n        );\n      });\n    }\n  };\n\n  renderSchematic() {\n    console.log(\"renderSchematic\");\n\n    if (this.props.store.loading) {\n      return;\n    }\n\n    return this.schematic.components.map((schematizeComponent, i) => {\n      return (\n        <React.Fragment key={\"f\" + i}>\n          {this.renderComponent(schematizeComponent, i, this.state.pathNames)}\n        </React.Fragment>\n      );\n    });\n  }\n\n  renderSortedLinks() {\n    if (this.props.store.loading) {\n      return;\n    }\n\n    return this.distanceSortedLinks.map((record, i) => {\n      return this.renderLink(record);\n    });\n  }\n\n  loadingMessage() {\n    if (this.props.store.loading) {\n      return (\n        <Text\n          y={100}\n          fontSize={60}\n          width={300}\n          align=\"center\"\n          text=\"Loading...\"\n        />\n      );\n    }\n  }\n\n  render() {\n    console.log(\"Start render\");\n\n    return (\n      <>\n        <div\n          style={{\n            position: \"sticky\",\n            top: 0,\n            zIndex: \"2\",\n            background: \"white\",\n\n            // To keep the matrix under the container with the vertical scrolling\n            // when the matrix is larger than the page\n            width: this.state.actualWidth + 60,\n\n            // To avoid width too low with large bin_width\n            minWidth: \"100%\",\n          }}\n        >\n          <ControlHeader store={this.props.store} schematic={this.schematic} />\n\n          <Stage\n            x={this.props.store.leftOffset}\n            y={this.props.topOffset}\n            width={this.state.actualWidth + 60}\n            height={this.props.store.topOffset}\n          >\n            <Layer ref={this.layerRef2}>\n              {this.renderSortedLinks()}\n              {this.renderNucleotidesSchematic()}\n            </Layer>\n          </Stage>\n        </div>\n\n        <Stage\n          x={this.props.store.leftOffset} // removed leftOffset to simplify code. Relative coordinates are always better.\n          y={-this.props.store.topOffset} // For some reason, I have to put this, but I'd like to put 0\n          width={this.state.actualWidth + 60}\n          height={\n            this.visibleHeightPixels() + this.props.store.nucleotideHeight\n          }\n        >\n          <Layer ref={this.layerRef}>\n            {this.loadingMessage()}\n            {this.renderSchematic()}\n          </Layer>\n        </Stage>\n\n        <NucleotideTooltip store={this.props.store} />\n      </>\n    );\n  }\n}\n\n// render(<App />, document.getElementById('root'));\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === \"localhost\" ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === \"[::1]\" ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === \"production\" && \"serviceWorker\" in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener(\"load\", () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            \"This web app is being served cache-first by a service \" +\n              \"worker. To learn more, visit https://bit.ly/CRA-PWA\"\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then((registration) => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === \"installed\") {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                \"New content is available and will be used when all \" +\n                  \"tabs for this page are closed. See https://bit.ly/CRA-PWA.\"\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log(\"Content is cached for offline use.\");\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch((error) => {\n      console.error(\"Error during service worker registration:\", error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then((response) => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get(\"content-type\");\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf(\"javascript\") === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then((registration) => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        \"No internet connection found. App is running in offline mode.\"\n      );\n    });\n}\n\nexport function unregister() {\n  if (\"serviceWorker\" in navigator) {\n    navigator.serviceWorker.ready.then((registration) => {\n      registration.unregister();\n    });\n  }\n}\n","import { types } from \"mobx-state-tree\";\nimport { urlExists } from \"./URL\";\nimport { arraysEqual } from \"./utilities\";\n\nconst Chunk = types.model({\n  file: types.string,\n  fasta: types.maybeNull(types.string),\n  first_bin: types.integer,\n  last_bin: types.integer,\n  component_count: types.integer,\n  link_count: types.integer,\n});\nconst ZoomLevel = types.model({\n  bin_width: types.integer,\n  last_bin: types.integer,\n  files: types.array(Chunk),\n});\nconst ChunkIndex = types.maybeNull(\n  types.model({\n    json_version: 14,\n    pangenome_length: types.integer,\n    zoom_levels: types.map(ZoomLevel),\n  })\n);\nconst PathNucPos = types.model(\"PathNucPos\", {\n  path: types.string,\n  nucPos: types.integer,\n});\n\nlet RootStore;\nRootStore = types\n  .model({\n    chunkIndex: ChunkIndex,\n    beginEndBin: types.optional(types.array(types.integer), [1, 60]),\n    useVerticalCompression: false,\n    useWidthCompression: false,\n    binScalingFactor: 3,\n    useConnector: true,\n    pixelsPerColumn: 10,\n    pixelsPerRow: 10,\n    leftOffset: 0,\n    topOffset: 400,\n    highlightedLink: 0, // we will compare linkColumns\n    maximumHeightThisFrame: 150,\n    cellToolTipContent: \"\",\n    // TODO: to change 'jsonName' in 'jsonNameDir'?\n    jsonName: \"SARS-CoV-b2\",\n    // Added attributes for the zoom level management\n    availableZoomLevels: types.optional(types.array(types.string), [\"1\"]),\n    indexSelectedZoomLevel: 0,\n    chunkURLs: types.optional(types.array(types.string), []),\n    chunkFastaURLs: types.optional(types.array(types.string), []),\n    //to be compared against chunkURLs\n    chunksProcessed: types.optional(types.array(types.string), []),\n    chunkBeginBin: -1,\n\n    pathNucPos: types.optional(PathNucPos, { path: \"path\", nucPos: 0 }), // OR: types.maybe(PathNucPos)\n    pathIndexServerAddress: \"http://193.196.29.24:3010/\",\n    nucleotideHeight: 10,\n    pangenomelast_bin: -1, //TODO: don't add values unless they're needed\n    // TODO: Set when bin2file is read\n    beginColumnX: 0, //TODO: copied and stored from bin2file.json in calculateEndBinFromScreen()\n    loading: true,\n  })\n  .actions((self) => {\n    function setChunkIndex(json) {\n      console.log(\"STEP #2: chunkIndex contents loaded\");\n      console.log(\"Index updated with content:\", json);\n      self.chunkIndex = json;\n    }\n    function updateBeginEndBin(newBegin, newEnd) {\n      console.log(\"updateBeginEndBin - \" + newBegin + \" - \" + newEnd);\n\n      /*This method needs to be atomic to avoid spurious updates and out of date validation.*/\n      newBegin = Math.max(1, Math.round(newBegin));\n      newEnd = Math.max(1, Math.round(newEnd));\n      const beginBin = getBeginBin();\n      const endBin = getEndBin();\n      if (newEnd === endBin) {\n        //end has not changed\n        let diff = endBin - beginBin;\n        newEnd = newBegin + diff; //Allows start to push End to new chunks\n      }\n      if (newEnd < newBegin) {\n        //crush newStart\n        newBegin = newEnd - 1;\n      }\n      if (newBegin !== beginBin) {\n        setBeginEndBin(newBegin, newEnd);\n        console.log(\"updated begin and end: \" + newBegin + \" \" + newEnd);\n      } else {\n        self.beginEndBin[1] = newEnd; // quietly update without refresh\n      }\n    }\n    function updateTopOffset(newTopOffset) {\n      if (Number.isFinite(newTopOffset) && Number.isSafeInteger(newTopOffset)) {\n        self.topOffset = newTopOffset + 10;\n      }\n    }\n    function updateBinScalingFactor(event) {\n      let newFactor = event.target.value;\n      self.binScalingFactor = Math.max(1, Number(newFactor));\n    }\n    function updateHighlightedLink(linkRect) {\n      self.highlightedLink = linkRect;\n    }\n    function updateMaxHeight(latestHeight) {\n      self.maximumHeightThisFrame = Math.max(\n        self.maximumHeightThisFrame,\n        latestHeight\n      );\n    }\n    function resetRenderStats() {\n      self.maximumHeightThisFrame = 1;\n    }\n    function updateCellTooltipContent(newContents) {\n      self.cellToolTipContent = String(newContents);\n    }\n    function toggleUseVerticalCompression() {\n      self.useVerticalCompression = !self.useVerticalCompression;\n    }\n    function toggleUseWidthCompression() {\n      self.useWidthCompression = !self.useWidthCompression;\n    }\n    function toggleUseConnector() {\n      self.useConnector = !self.useConnector;\n    }\n    function updateHeight(event) {\n      self.pixelsPerRow = Math.max(1, Number(event.target.value));\n    }\n    function updateWidth(event) {\n      self.pixelsPerColumn = Number(event.target.value);\n    }\n\n    function tryJSONpath(event) {\n      const url =\n        process.env.REACT_APP_FETCH + event.target.value + \"/bin2file.json\";\n      if (urlExists(url)) {\n        console.log(\"STEP#1: New Data Source: \" + event.target.value);\n        self.jsonName = event.target.value;\n      }\n    }\n\n    // Lifted down the control of the emptyness of the arrays\n    function switchChunkURLs(arrayOfFile) {\n      if (!arraysEqual(arrayOfFile, self.chunkURLs)) {\n        console.log(\"STEP #4: Set switchChunkURLs: \" + arrayOfFile);\n        self.chunkURLs = arrayOfFile;\n        self.chunksProcessed = []; //clear\n\n        return true;\n      }\n      return false;\n    }\n    function switchChunkFastaURLs(arrayOfFile) {\n      if (!arraysEqual(arrayOfFile, self.chunkFastaURLs)) {\n        console.log(\"STEP #4.fasta: Set switchChunkFastaURLs: \" + arrayOfFile);\n        self.chunkFastaURLs = arrayOfFile;\n      }\n    }\n    function addChunkProcessed(singleChunk) {\n      console.log(\"STEP #7: processed \" + singleChunk);\n      self.chunksProcessed.push(singleChunk);\n    }\n    function getBeginBin() {\n      return self.beginEndBin[0];\n    }\n    function getEndBin() {\n      return self.beginEndBin[1];\n    }\n\n    // Getter and setter for zoom info management\n    function getBinWidth() {\n      //Zoom level and BinWidth are actually the same thing\n      return Number(self.getSelectedZoomLevel());\n    }\n    function getSelectedZoomLevel() {\n      //This is a genuinely useful getter\n      let a = self.availableZoomLevels[self.indexSelectedZoomLevel];\n      return a ? a : \"1\";\n    }\n    function setIndexSelectedZoomLevel(index) {\n      self.indexSelectedZoomLevel = index;\n    }\n\n    function setAvailableZoomLevels(availableZoomLevels) {\n      let arr = [...availableZoomLevels];\n\n      self.availableZoomLevels = arr;\n    }\n\n    function setBeginEndBin(newBeginBin, newEndBin) {\n      self.beginEndBin = [newBeginBin, newEndBin];\n    }\n    function updatePathNucPos(path, nucPos) {\n      if (nucPos) {\n        nucPos = parseInt(nucPos);\n      } else {\n        nucPos = 0;\n      }\n      self.pathNucPos = { path: path, nucPos: nucPos };\n    }\n    function setBeginColumnX(x) {\n      self.beginColumnX = x;\n    }\n    function setChunkBeginBin(x) {\n      self.chunkBeginBin = x;\n    }\n\n    function setLoading(val) {\n      self.loading = val;\n    }\n    return {\n      setChunkIndex,\n      updateBeginEndBin,\n      updateTopOffset,\n      updateHighlightedLink,\n      updateMaxHeight,\n      resetRenderStats,\n      updateCellTooltipContent,\n      updateBinScalingFactor,\n      toggleUseVerticalCompression,\n      toggleUseWidthCompression,\n      toggleUseConnector,\n      updateHeight,\n      updateWidth,\n      tryJSONpath,\n\n      switchChunkURLs,\n      switchChunkFastaURLs,\n      addChunkProcessed,\n\n      getBeginBin,\n      getEndBin,\n      updatePathNucPos,\n      setBeginColumnX,\n      setChunkBeginBin,\n      //NOTE: DO NOT ADD GETTERS here.  They are not necessary in mobx.\n      // You can reference store.val directly without store.getVal()\n      //Only write getters to encapsulate useful logic for derived values\n\n      // Added zoom actions\n      getBinWidth,\n      getSelectedZoomLevel,\n      setIndexSelectedZoomLevel,\n      setAvailableZoomLevels,\n\n      setLoading,\n    };\n  })\n  .views((self) => ({}));\n\nexport const store = RootStore.create({});\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport \"./index.css\";\nimport App from \"./App\";\nimport * as serviceWorker from \"./serviceWorker\";\nimport { store } from \"./ViewportInputsStore\";\n\nReactDOM.render(<App store={store} />, document.getElementById(\"root\"));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}